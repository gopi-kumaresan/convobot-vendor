{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[1,31],{\"+rOU\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return BasePortalOutlet}),__webpack_require__.d(__webpack_exports__,\"b\",function(){return CdkPortal}),__webpack_require__.d(__webpack_exports__,\"c\",function(){return CdkPortalOutlet}),__webpack_require__.d(__webpack_exports__,\"d\",function(){return ComponentPortal}),__webpack_require__.d(__webpack_exports__,\"e\",function(){return DomPortalOutlet}),__webpack_require__.d(__webpack_exports__,\"f\",function(){return PortalModule}),__webpack_require__.d(__webpack_exports__,\"g\",function(){return TemplatePortal});var _angular_core__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"fXoL\"),_angular_common__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"ofXK\");class Portal{attach(host){return this._attachedHost=host,host.attach(this)}detach(){let host=this._attachedHost;null!=host&&(this._attachedHost=null,host.detach())}get isAttached(){return null!=this._attachedHost}setAttachedHost(host){this._attachedHost=host}}class ComponentPortal extends Portal{constructor(component,viewContainerRef,injector,componentFactoryResolver){super(),this.component=component,this.viewContainerRef=viewContainerRef,this.injector=injector,this.componentFactoryResolver=componentFactoryResolver}}class TemplatePortal extends Portal{constructor(template,viewContainerRef,context){super(),this.templateRef=template,this.viewContainerRef=viewContainerRef,this.context=context}get origin(){return this.templateRef.elementRef}attach(host,context=this.context){return this.context=context,super.attach(host)}detach(){return this.context=void 0,super.detach()}}class DomPortal extends Portal{constructor(element){super(),this.element=element instanceof _angular_core__WEBPACK_IMPORTED_MODULE_0__.m?element.nativeElement:element}}class BasePortalOutlet{constructor(){this._isDisposed=!1,this.attachDomPortal=null}hasAttached(){return!!this._attachedPortal}attach(portal){return portal instanceof ComponentPortal?(this._attachedPortal=portal,this.attachComponentPortal(portal)):portal instanceof TemplatePortal?(this._attachedPortal=portal,this.attachTemplatePortal(portal)):this.attachDomPortal&&portal instanceof DomPortal?(this._attachedPortal=portal,this.attachDomPortal(portal)):void 0}detach(){this._attachedPortal&&(this._attachedPortal.setAttachedHost(null),this._attachedPortal=null),this._invokeDisposeFn()}dispose(){this.hasAttached()&&this.detach(),this._invokeDisposeFn(),this._isDisposed=!0}setDisposeFn(fn){this._disposeFn=fn}_invokeDisposeFn(){this._disposeFn&&(this._disposeFn(),this._disposeFn=null)}}class DomPortalOutlet extends BasePortalOutlet{constructor(outletElement,_componentFactoryResolver,_appRef,_defaultInjector,_document){super(),this.outletElement=outletElement,this._componentFactoryResolver=_componentFactoryResolver,this._appRef=_appRef,this._defaultInjector=_defaultInjector,this.attachDomPortal=portal=>{const element=portal.element,anchorNode=this._document.createComment(\"dom-portal\");element.parentNode.insertBefore(anchorNode,element),this.outletElement.appendChild(element),this._attachedPortal=portal,super.setDisposeFn(()=>{anchorNode.parentNode&&anchorNode.parentNode.replaceChild(element,anchorNode)})},this._document=_document}attachComponentPortal(portal){const componentFactory=(portal.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(portal.component);let componentRef;return portal.viewContainerRef?(componentRef=portal.viewContainerRef.createComponent(componentFactory,portal.viewContainerRef.length,portal.injector||portal.viewContainerRef.injector),this.setDisposeFn(()=>componentRef.destroy())):(componentRef=componentFactory.create(portal.injector||this._defaultInjector),this._appRef.attachView(componentRef.hostView),this.setDisposeFn(()=>{this._appRef.detachView(componentRef.hostView),componentRef.destroy()})),this.outletElement.appendChild(this._getComponentRootNode(componentRef)),this._attachedPortal=portal,componentRef}attachTemplatePortal(portal){let viewContainer=portal.viewContainerRef,viewRef=viewContainer.createEmbeddedView(portal.templateRef,portal.context);return viewRef.rootNodes.forEach(rootNode=>this.outletElement.appendChild(rootNode)),viewRef.detectChanges(),this.setDisposeFn(()=>{let index=viewContainer.indexOf(viewRef);-1!==index&&viewContainer.remove(index)}),this._attachedPortal=portal,viewRef}dispose(){super.dispose(),null!=this.outletElement.parentNode&&this.outletElement.parentNode.removeChild(this.outletElement)}_getComponentRootNode(componentRef){return componentRef.hostView.rootNodes[0]}}let CdkPortal=(()=>{class CdkPortal extends TemplatePortal{constructor(templateRef,viewContainerRef){super(templateRef,viewContainerRef)}}return CdkPortal.ɵfac=function(t){return new(t||CdkPortal)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_0__.R),_angular_core__WEBPACK_IMPORTED_MODULE_0__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_0__.V))},CdkPortal.ɵdir=_angular_core__WEBPACK_IMPORTED_MODULE_0__.Ob({type:CdkPortal,selectors:[[\"\",\"cdkPortal\",\"\"]],exportAs:[\"cdkPortal\"],features:[_angular_core__WEBPACK_IMPORTED_MODULE_0__.Db]}),CdkPortal})(),CdkPortalOutlet=(()=>{class CdkPortalOutlet extends BasePortalOutlet{constructor(_componentFactoryResolver,_viewContainerRef,_document){super(),this._componentFactoryResolver=_componentFactoryResolver,this._viewContainerRef=_viewContainerRef,this._isInitialized=!1,this.attached=new _angular_core__WEBPACK_IMPORTED_MODULE_0__.p,this.attachDomPortal=portal=>{const element=portal.element,anchorNode=this._document.createComment(\"dom-portal\");portal.setAttachedHost(this),element.parentNode.insertBefore(anchorNode,element),this._getRootNode().appendChild(element),this._attachedPortal=portal,super.setDisposeFn(()=>{anchorNode.parentNode&&anchorNode.parentNode.replaceChild(element,anchorNode)})},this._document=_document}get portal(){return this._attachedPortal}set portal(portal){(!this.hasAttached()||portal||this._isInitialized)&&(this.hasAttached()&&super.detach(),portal&&super.attach(portal),this._attachedPortal=portal)}get attachedRef(){return this._attachedRef}ngOnInit(){this._isInitialized=!0}ngOnDestroy(){super.dispose(),this._attachedPortal=null,this._attachedRef=null}attachComponentPortal(portal){portal.setAttachedHost(this);const viewContainerRef=null!=portal.viewContainerRef?portal.viewContainerRef:this._viewContainerRef,componentFactory=(portal.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(portal.component),ref=viewContainerRef.createComponent(componentFactory,viewContainerRef.length,portal.injector||viewContainerRef.injector);return viewContainerRef!==this._viewContainerRef&&this._getRootNode().appendChild(ref.hostView.rootNodes[0]),super.setDisposeFn(()=>ref.destroy()),this._attachedPortal=portal,this._attachedRef=ref,this.attached.emit(ref),ref}attachTemplatePortal(portal){portal.setAttachedHost(this);const viewRef=this._viewContainerRef.createEmbeddedView(portal.templateRef,portal.context);return super.setDisposeFn(()=>this._viewContainerRef.clear()),this._attachedPortal=portal,this._attachedRef=viewRef,this.attached.emit(viewRef),viewRef}_getRootNode(){const nativeElement=this._viewContainerRef.element.nativeElement;return nativeElement.nodeType===nativeElement.ELEMENT_NODE?nativeElement:nativeElement.parentNode}}return CdkPortalOutlet.ɵfac=function(t){return new(t||CdkPortalOutlet)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_0__.k),_angular_core__WEBPACK_IMPORTED_MODULE_0__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_0__.V),_angular_core__WEBPACK_IMPORTED_MODULE_0__.Tb(_angular_common__WEBPACK_IMPORTED_MODULE_1__.d))},CdkPortalOutlet.ɵdir=_angular_core__WEBPACK_IMPORTED_MODULE_0__.Ob({type:CdkPortalOutlet,selectors:[[\"\",\"cdkPortalOutlet\",\"\"]],inputs:{portal:[\"cdkPortalOutlet\",\"portal\"]},outputs:{attached:\"attached\"},exportAs:[\"cdkPortalOutlet\"],features:[_angular_core__WEBPACK_IMPORTED_MODULE_0__.Db]}),CdkPortalOutlet})(),PortalModule=(()=>{class PortalModule{}return PortalModule.ɵmod=_angular_core__WEBPACK_IMPORTED_MODULE_0__.Rb({type:PortalModule}),PortalModule.ɵinj=_angular_core__WEBPACK_IMPORTED_MODULE_0__.Qb({factory:function(t){return new(t||PortalModule)}}),PortalModule})()},\"0EQZ\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return ArrayDataSource}),__webpack_require__.d(__webpack_exports__,\"b\",function(){return DataSource}),__webpack_require__.d(__webpack_exports__,\"c\",function(){return SelectionModel}),__webpack_require__.d(__webpack_exports__,\"d\",function(){return UniqueSelectionDispatcher}),__webpack_require__.d(__webpack_exports__,\"e\",function(){return _DisposeViewRepeaterStrategy}),__webpack_require__.d(__webpack_exports__,\"f\",function(){return _RecycleViewRepeaterStrategy}),__webpack_require__.d(__webpack_exports__,\"g\",function(){return _VIEW_REPEATER_STRATEGY}),__webpack_require__.d(__webpack_exports__,\"h\",function(){return isDataSource});var rxjs__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"7+OI\"),rxjs__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"LRne\"),rxjs__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"XNiG\"),_angular_core__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(\"fXoL\");class DataSource{}function isDataSource(value){return value&&\"function\"==typeof value.connect}class ArrayDataSource extends DataSource{constructor(_data){super(),this._data=_data}connect(){return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__.a)(this._data)?this._data:Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)(this._data)}disconnect(){}}class _DisposeViewRepeaterStrategy{applyChanges(changes,viewContainerRef,itemContextFactory,itemValueResolver,itemViewChanged){changes.forEachOperation((record,adjustedPreviousIndex,currentIndex)=>{let view,operation;if(null==record.previousIndex){const insertContext=itemContextFactory(record,adjustedPreviousIndex,currentIndex);view=viewContainerRef.createEmbeddedView(insertContext.templateRef,insertContext.context,insertContext.index),operation=1}else null==currentIndex?(viewContainerRef.remove(adjustedPreviousIndex),operation=3):(view=viewContainerRef.get(adjustedPreviousIndex),viewContainerRef.move(view,currentIndex),operation=2);itemViewChanged&&itemViewChanged({context:null==view?void 0:view.context,operation:operation,record:record})})}detach(){}}class _RecycleViewRepeaterStrategy{constructor(){this.viewCacheSize=20,this._viewCache=[]}applyChanges(changes,viewContainerRef,itemContextFactory,itemValueResolver,itemViewChanged){changes.forEachOperation((record,adjustedPreviousIndex,currentIndex)=>{let view,operation;null==record.previousIndex?(view=this._insertView(()=>itemContextFactory(record,adjustedPreviousIndex,currentIndex),currentIndex,viewContainerRef,itemValueResolver(record)),operation=view?1:0):null==currentIndex?(this._detachAndCacheView(adjustedPreviousIndex,viewContainerRef),operation=3):(view=this._moveView(adjustedPreviousIndex,currentIndex,viewContainerRef,itemValueResolver(record)),operation=2),itemViewChanged&&itemViewChanged({context:null==view?void 0:view.context,operation:operation,record:record})})}detach(){for(const view of this._viewCache)view.destroy();this._viewCache=[]}_insertView(viewArgsFactory,currentIndex,viewContainerRef,value){const cachedView=this._insertViewFromCache(currentIndex,viewContainerRef);if(cachedView)return void(cachedView.context.$implicit=value);const viewArgs=viewArgsFactory();return viewContainerRef.createEmbeddedView(viewArgs.templateRef,viewArgs.context,viewArgs.index)}_detachAndCacheView(index,viewContainerRef){const detachedView=viewContainerRef.detach(index);this._maybeCacheView(detachedView,viewContainerRef)}_moveView(adjustedPreviousIndex,currentIndex,viewContainerRef,value){const view=viewContainerRef.get(adjustedPreviousIndex);return viewContainerRef.move(view,currentIndex),view.context.$implicit=value,view}_maybeCacheView(view,viewContainerRef){if(this._viewCache.length<this.viewCacheSize)this._viewCache.push(view);else{const index=viewContainerRef.indexOf(view);-1===index?view.destroy():viewContainerRef.remove(index)}}_insertViewFromCache(index,viewContainerRef){const cachedView=this._viewCache.pop();return cachedView&&viewContainerRef.insert(cachedView,index),cachedView||null}}class SelectionModel{constructor(_multiple=!1,initiallySelectedValues,_emitChanges=!0){this._multiple=_multiple,this._emitChanges=_emitChanges,this._selection=new Set,this._deselectedToEmit=[],this._selectedToEmit=[],this.changed=new rxjs__WEBPACK_IMPORTED_MODULE_2__.a,initiallySelectedValues&&initiallySelectedValues.length&&(_multiple?initiallySelectedValues.forEach(value=>this._markSelected(value)):this._markSelected(initiallySelectedValues[0]),this._selectedToEmit.length=0)}get selected(){return this._selected||(this._selected=Array.from(this._selection.values())),this._selected}select(...values){this._verifyValueAssignment(values),values.forEach(value=>this._markSelected(value)),this._emitChangeEvent()}deselect(...values){this._verifyValueAssignment(values),values.forEach(value=>this._unmarkSelected(value)),this._emitChangeEvent()}toggle(value){this.isSelected(value)?this.deselect(value):this.select(value)}clear(){this._unmarkAll(),this._emitChangeEvent()}isSelected(value){return this._selection.has(value)}isEmpty(){return 0===this._selection.size}hasValue(){return!this.isEmpty()}sort(predicate){this._multiple&&this.selected&&this._selected.sort(predicate)}isMultipleSelection(){return this._multiple}_emitChangeEvent(){this._selected=null,(this._selectedToEmit.length||this._deselectedToEmit.length)&&(this.changed.next({source:this,added:this._selectedToEmit,removed:this._deselectedToEmit}),this._deselectedToEmit=[],this._selectedToEmit=[])}_markSelected(value){this.isSelected(value)||(this._multiple||this._unmarkAll(),this._selection.add(value),this._emitChanges&&this._selectedToEmit.push(value))}_unmarkSelected(value){this.isSelected(value)&&(this._selection.delete(value),this._emitChanges&&this._deselectedToEmit.push(value))}_unmarkAll(){this.isEmpty()||this._selection.forEach(value=>this._unmarkSelected(value))}_verifyValueAssignment(values){}}let UniqueSelectionDispatcher=(()=>{class UniqueSelectionDispatcher{constructor(){this._listeners=[]}notify(id,name){for(let listener of this._listeners)listener(id,name)}listen(listener){return this._listeners.push(listener),()=>{this._listeners=this._listeners.filter(registered=>listener!==registered)}}ngOnDestroy(){this._listeners=[]}}return UniqueSelectionDispatcher.ɵfac=function(t){return new(t||UniqueSelectionDispatcher)},UniqueSelectionDispatcher.ɵprov=Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__.Pb)({factory:function(){return new UniqueSelectionDispatcher},token:UniqueSelectionDispatcher,providedIn:\"root\"}),UniqueSelectionDispatcher})();const _VIEW_REPEATER_STRATEGY=new _angular_core__WEBPACK_IMPORTED_MODULE_3__.u(\"_ViewRepeater\")},\"7Hc7\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return asapScheduler});let nextHandle=1;const RESOLVED=(()=>Promise.resolve())(),activeHandles={};function findAndClearHandle(handle){return handle in activeHandles&&(delete activeHandles[handle],!0)}const Immediate={setImmediate(cb){const handle=nextHandle++;return activeHandles[handle]=!0,RESOLVED.then(()=>findAndClearHandle(handle)&&cb()),handle},clearImmediate(handle){findAndClearHandle(handle)}};var AsyncAction=__webpack_require__(\"3N8a\");class AsapAction_AsapAction extends AsyncAction.a{constructor(scheduler,work){super(scheduler,work),this.scheduler=scheduler,this.work=work}requestAsyncId(scheduler,id,delay=0){return null!==delay&&delay>0?super.requestAsyncId(scheduler,id,delay):(scheduler.actions.push(this),scheduler.scheduled||(scheduler.scheduled=Immediate.setImmediate(scheduler.flush.bind(scheduler,null))))}recycleAsyncId(scheduler,id,delay=0){if(null!==delay&&delay>0||null===delay&&this.delay>0)return super.recycleAsyncId(scheduler,id,delay);0===scheduler.actions.length&&(Immediate.clearImmediate(id),scheduler.scheduled=void 0)}}var AsyncScheduler=__webpack_require__(\"IjjT\");class AsapScheduler_AsapScheduler extends AsyncScheduler.a{flush(action){this.active=!0,this.scheduled=void 0;const{actions:actions}=this;let error,index=-1,count=actions.length;action=action||actions.shift();do{if(error=action.execute(action.state,action.delay))break}while(++index<count&&(action=actions.shift()));if(this.active=!1,error){for(;++index<count&&(action=actions.shift());)action.unsubscribe();throw error}}}const asapScheduler=new AsapScheduler_AsapScheduler(AsapAction_AsapAction)},vxfF:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return scrolling_CdkScrollable}),__webpack_require__.d(__webpack_exports__,\"b\",function(){return scrolling_CdkScrollableModule}),__webpack_require__.d(__webpack_exports__,\"c\",function(){return scrolling_ScrollDispatcher}),__webpack_require__.d(__webpack_exports__,\"d\",function(){return scrolling_ScrollingModule}),__webpack_require__.d(__webpack_exports__,\"e\",function(){return scrolling_ViewportRuler});var coercion=__webpack_require__(\"8LU1\"),core=__webpack_require__(\"fXoL\"),Subject=__webpack_require__(\"XNiG\"),of=__webpack_require__(\"LRne\"),Observable=__webpack_require__(\"HDdC\"),fromEvent=__webpack_require__(\"xgIS\"),auditTime=(__webpack_require__(\"eNwd\"),__webpack_require__(\"7Hc7\"),__webpack_require__(\"quSY\"),__webpack_require__(\"7+OI\"),__webpack_require__(\"/uUt\"),__webpack_require__(\"3UWI\")),filter=__webpack_require__(\"pLZG\"),takeUntil=__webpack_require__(\"1G5W\");__webpack_require__(\"JX91\"),__webpack_require__(\"7o/Q\"),__webpack_require__(\"eIep\"),__webpack_require__(\"UXun\");var platform=__webpack_require__(\"nLfN\"),common=__webpack_require__(\"ofXK\"),bidi=__webpack_require__(\"cH1L\");__webpack_require__(\"0EQZ\");let scrolling_ScrollDispatcher=(()=>{class ScrollDispatcher{constructor(_ngZone,_platform,document){this._ngZone=_ngZone,this._platform=_platform,this._scrolled=new Subject.a,this._globalSubscription=null,this._scrolledCount=0,this.scrollContainers=new Map,this._document=document}register(scrollable){this.scrollContainers.has(scrollable)||this.scrollContainers.set(scrollable,scrollable.elementScrolled().subscribe(()=>this._scrolled.next(scrollable)))}deregister(scrollable){const scrollableReference=this.scrollContainers.get(scrollable);scrollableReference&&(scrollableReference.unsubscribe(),this.scrollContainers.delete(scrollable))}scrolled(auditTimeInMs=20){return this._platform.isBrowser?new Observable.a(observer=>{this._globalSubscription||this._addGlobalListener();const subscription=auditTimeInMs>0?this._scrolled.pipe(Object(auditTime.a)(auditTimeInMs)).subscribe(observer):this._scrolled.subscribe(observer);return this._scrolledCount++,()=>{subscription.unsubscribe(),this._scrolledCount--,this._scrolledCount||this._removeGlobalListener()}}):Object(of.a)()}ngOnDestroy(){this._removeGlobalListener(),this.scrollContainers.forEach((_,container)=>this.deregister(container)),this._scrolled.complete()}ancestorScrolled(elementOrElementRef,auditTimeInMs){const ancestors=this.getAncestorScrollContainers(elementOrElementRef);return this.scrolled(auditTimeInMs).pipe(Object(filter.a)(target=>!target||ancestors.indexOf(target)>-1))}getAncestorScrollContainers(elementOrElementRef){const scrollingContainers=[];return this.scrollContainers.forEach((_subscription,scrollable)=>{this._scrollableContainsElement(scrollable,elementOrElementRef)&&scrollingContainers.push(scrollable)}),scrollingContainers}_getWindow(){return this._document.defaultView||window}_scrollableContainsElement(scrollable,elementOrElementRef){let element=Object(coercion.e)(elementOrElementRef),scrollableElement=scrollable.getElementRef().nativeElement;do{if(element==scrollableElement)return!0}while(element=element.parentElement);return!1}_addGlobalListener(){this._globalSubscription=this._ngZone.runOutsideAngular(()=>{const window=this._getWindow();return Object(fromEvent.a)(window.document,\"scroll\").subscribe(()=>this._scrolled.next())})}_removeGlobalListener(){this._globalSubscription&&(this._globalSubscription.unsubscribe(),this._globalSubscription=null)}}return ScrollDispatcher.ɵfac=function(t){return new(t||ScrollDispatcher)(core.gc(core.F),core.gc(platform.a),core.gc(common.d,8))},ScrollDispatcher.ɵprov=Object(core.Pb)({factory:function(){return new ScrollDispatcher(Object(core.gc)(core.F),Object(core.gc)(platform.a),Object(core.gc)(common.d,8))},token:ScrollDispatcher,providedIn:\"root\"}),ScrollDispatcher})(),scrolling_CdkScrollable=(()=>{class CdkScrollable{constructor(elementRef,scrollDispatcher,ngZone,dir){this.elementRef=elementRef,this.scrollDispatcher=scrollDispatcher,this.ngZone=ngZone,this.dir=dir,this._destroyed=new Subject.a,this._elementScrolled=new Observable.a(observer=>this.ngZone.runOutsideAngular(()=>Object(fromEvent.a)(this.elementRef.nativeElement,\"scroll\").pipe(Object(takeUntil.a)(this._destroyed)).subscribe(observer)))}ngOnInit(){this.scrollDispatcher.register(this)}ngOnDestroy(){this.scrollDispatcher.deregister(this),this._destroyed.next(),this._destroyed.complete()}elementScrolled(){return this._elementScrolled}getElementRef(){return this.elementRef}scrollTo(options){const el=this.elementRef.nativeElement,isRtl=this.dir&&\"rtl\"==this.dir.value;null==options.left&&(options.left=isRtl?options.end:options.start),null==options.right&&(options.right=isRtl?options.start:options.end),null!=options.bottom&&(options.top=el.scrollHeight-el.clientHeight-options.bottom),isRtl&&0!=Object(platform.d)()?(null!=options.left&&(options.right=el.scrollWidth-el.clientWidth-options.left),2==Object(platform.d)()?options.left=options.right:1==Object(platform.d)()&&(options.left=options.right?-options.right:options.right)):null!=options.right&&(options.left=el.scrollWidth-el.clientWidth-options.right),this._applyScrollToOptions(options)}_applyScrollToOptions(options){const el=this.elementRef.nativeElement;Object(platform.g)()?el.scrollTo(options):(null!=options.top&&(el.scrollTop=options.top),null!=options.left&&(el.scrollLeft=options.left))}measureScrollOffset(from){const el=this.elementRef.nativeElement;if(\"top\"==from)return el.scrollTop;if(\"bottom\"==from)return el.scrollHeight-el.clientHeight-el.scrollTop;const isRtl=this.dir&&\"rtl\"==this.dir.value;return\"start\"==from?from=isRtl?\"right\":\"left\":\"end\"==from&&(from=isRtl?\"left\":\"right\"),isRtl&&2==Object(platform.d)()?\"left\"==from?el.scrollWidth-el.clientWidth-el.scrollLeft:el.scrollLeft:isRtl&&1==Object(platform.d)()?\"left\"==from?el.scrollLeft+el.scrollWidth-el.clientWidth:-el.scrollLeft:\"left\"==from?el.scrollLeft:el.scrollWidth-el.clientWidth-el.scrollLeft}}return CdkScrollable.ɵfac=function(t){return new(t||CdkScrollable)(core.Tb(core.m),core.Tb(scrolling_ScrollDispatcher),core.Tb(core.F),core.Tb(bidi.b,8))},CdkScrollable.ɵdir=core.Ob({type:CdkScrollable,selectors:[[\"\",\"cdk-scrollable\",\"\"],[\"\",\"cdkScrollable\",\"\"]]}),CdkScrollable})(),scrolling_ViewportRuler=(()=>{class ViewportRuler{constructor(_platform,ngZone,document){this._platform=_platform,this._change=new Subject.a,this._changeListener=event=>{this._change.next(event)},this._document=document,ngZone.runOutsideAngular(()=>{if(_platform.isBrowser){const window=this._getWindow();window.addEventListener(\"resize\",this._changeListener),window.addEventListener(\"orientationchange\",this._changeListener)}this.change().subscribe(()=>this._updateViewportSize())})}ngOnDestroy(){if(this._platform.isBrowser){const window=this._getWindow();window.removeEventListener(\"resize\",this._changeListener),window.removeEventListener(\"orientationchange\",this._changeListener)}this._change.complete()}getViewportSize(){this._viewportSize||this._updateViewportSize();const output={width:this._viewportSize.width,height:this._viewportSize.height};return this._platform.isBrowser||(this._viewportSize=null),output}getViewportRect(){const scrollPosition=this.getViewportScrollPosition(),{width:width,height:height}=this.getViewportSize();return{top:scrollPosition.top,left:scrollPosition.left,bottom:scrollPosition.top+height,right:scrollPosition.left+width,height:height,width:width}}getViewportScrollPosition(){if(!this._platform.isBrowser)return{top:0,left:0};const document=this._document,window=this._getWindow(),documentElement=document.documentElement,documentRect=documentElement.getBoundingClientRect();return{top:-documentRect.top||document.body.scrollTop||window.scrollY||documentElement.scrollTop||0,left:-documentRect.left||document.body.scrollLeft||window.scrollX||documentElement.scrollLeft||0}}change(throttleTime=20){return throttleTime>0?this._change.pipe(Object(auditTime.a)(throttleTime)):this._change}_getWindow(){return this._document.defaultView||window}_updateViewportSize(){const window=this._getWindow();this._viewportSize=this._platform.isBrowser?{width:window.innerWidth,height:window.innerHeight}:{width:0,height:0}}}return ViewportRuler.ɵfac=function(t){return new(t||ViewportRuler)(core.gc(platform.a),core.gc(core.F),core.gc(common.d,8))},ViewportRuler.ɵprov=Object(core.Pb)({factory:function(){return new ViewportRuler(Object(core.gc)(platform.a),Object(core.gc)(core.F),Object(core.gc)(common.d,8))},token:ViewportRuler,providedIn:\"root\"}),ViewportRuler})(),scrolling_CdkScrollableModule=(()=>{class CdkScrollableModule{}return CdkScrollableModule.ɵmod=core.Rb({type:CdkScrollableModule}),CdkScrollableModule.ɵinj=core.Qb({factory:function(t){return new(t||CdkScrollableModule)}}),CdkScrollableModule})(),scrolling_ScrollingModule=(()=>{class ScrollingModule{}return ScrollingModule.ɵmod=core.Rb({type:ScrollingModule}),ScrollingModule.ɵinj=core.Qb({factory:function(t){return new(t||ScrollingModule)},imports:[[bidi.a,platform.b,scrolling_CdkScrollableModule],bidi.a,scrolling_CdkScrollableModule]}),ScrollingModule})()},wZkO:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return MatTab}),__webpack_require__.d(__webpack_exports__,\"b\",function(){return MatTabGroup}),__webpack_require__.d(__webpack_exports__,\"c\",function(){return MatTabLabel}),__webpack_require__.d(__webpack_exports__,\"d\",function(){return MatTabsModule});var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"u47x\"),_angular_cdk_observers__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"GU7r\"),_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"+rOU\"),_angular_common__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(\"ofXK\"),_angular_core__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(\"fXoL\"),_angular_material_core__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__(\"FKr1\"),_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_6__=__webpack_require__(\"R1ws\"),rxjs__WEBPACK_IMPORTED_MODULE_7__=__webpack_require__(\"XNiG\"),rxjs__WEBPACK_IMPORTED_MODULE_8__=__webpack_require__(\"quSY\"),rxjs__WEBPACK_IMPORTED_MODULE_9__=__webpack_require__(\"VRyK\"),rxjs__WEBPACK_IMPORTED_MODULE_10__=__webpack_require__(\"xgIS\"),rxjs__WEBPACK_IMPORTED_MODULE_11__=__webpack_require__(\"LRne\"),rxjs__WEBPACK_IMPORTED_MODULE_12__=__webpack_require__(\"PqYM\"),_angular_animations__WEBPACK_IMPORTED_MODULE_13__=__webpack_require__(\"R0Ic\"),rxjs_operators__WEBPACK_IMPORTED_MODULE_14__=__webpack_require__(\"JX91\"),rxjs_operators__WEBPACK_IMPORTED_MODULE_15__=__webpack_require__(\"/uUt\"),rxjs_operators__WEBPACK_IMPORTED_MODULE_16__=__webpack_require__(\"1G5W\"),_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_17__=__webpack_require__(\"8LU1\"),_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_18__=__webpack_require__(\"nLfN\"),_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_19__=__webpack_require__(\"FtGj\"),_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_20__=__webpack_require__(\"cH1L\"),_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_21__=__webpack_require__(\"vxfF\");function MatTab_ng_template_0_Template(rf,ctx){1&rf&&_angular_core__WEBPACK_IMPORTED_MODULE_4__.rc(0)}const _c0=[\"*\"];function MatTabBody_ng_template_2_Template(rf,ctx){}const _c1=function(a0){return{animationDuration:a0}},_c2=function(a0,a1){return{value:a0,params:a1}},_c3=[\"tabBodyWrapper\"],_c4=[\"tabHeader\"];function MatTabGroup_div_2_ng_template_2_ng_template_0_Template(rf,ctx){}function MatTabGroup_div_2_ng_template_2_Template(rf,ctx){if(1&rf&&_angular_core__WEBPACK_IMPORTED_MODULE_4__.Sc(0,MatTabGroup_div_2_ng_template_2_ng_template_0_Template,0,0,\"ng-template\",9),2&rf){const tab_r4=_angular_core__WEBPACK_IMPORTED_MODULE_4__.nc().$implicit;_angular_core__WEBPACK_IMPORTED_MODULE_4__.tc(\"cdkPortalOutlet\",tab_r4.templateLabel)}}function MatTabGroup_div_2_ng_template_3_Template(rf,ctx){if(1&rf&&_angular_core__WEBPACK_IMPORTED_MODULE_4__.Uc(0),2&rf){const tab_r4=_angular_core__WEBPACK_IMPORTED_MODULE_4__.nc().$implicit;_angular_core__WEBPACK_IMPORTED_MODULE_4__.Vc(tab_r4.textLabel)}}function MatTabGroup_div_2_Template(rf,ctx){if(1&rf){const _r12=_angular_core__WEBPACK_IMPORTED_MODULE_4__.ac();_angular_core__WEBPACK_IMPORTED_MODULE_4__.Zb(0,\"div\",6),_angular_core__WEBPACK_IMPORTED_MODULE_4__.jc(\"click\",function(){_angular_core__WEBPACK_IMPORTED_MODULE_4__.Ic(_r12);const tab_r4=ctx.$implicit,i_r5=ctx.index,ctx_r11=_angular_core__WEBPACK_IMPORTED_MODULE_4__.nc(),_r0=_angular_core__WEBPACK_IMPORTED_MODULE_4__.Gc(1);return ctx_r11._handleClick(tab_r4,_r0,i_r5)})(\"cdkFocusChange\",function($event){_angular_core__WEBPACK_IMPORTED_MODULE_4__.Ic(_r12);const i_r5=ctx.index;return _angular_core__WEBPACK_IMPORTED_MODULE_4__.nc()._tabFocusChanged($event,i_r5)}),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Zb(1,\"div\",7),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Sc(2,MatTabGroup_div_2_ng_template_2_Template,1,1,\"ng-template\",8),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Sc(3,MatTabGroup_div_2_ng_template_3_Template,1,1,\"ng-template\",8),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Yb(),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Yb()}if(2&rf){const tab_r4=ctx.$implicit,i_r5=ctx.index,ctx_r1=_angular_core__WEBPACK_IMPORTED_MODULE_4__.nc();_angular_core__WEBPACK_IMPORTED_MODULE_4__.Lb(\"mat-tab-label-active\",ctx_r1.selectedIndex==i_r5),_angular_core__WEBPACK_IMPORTED_MODULE_4__.tc(\"id\",ctx_r1._getTabLabelId(i_r5))(\"disabled\",tab_r4.disabled)(\"matRippleDisabled\",tab_r4.disabled||ctx_r1.disableRipple),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Hb(\"tabIndex\",ctx_r1._getTabIndex(tab_r4,i_r5))(\"aria-posinset\",i_r5+1)(\"aria-setsize\",ctx_r1._tabs.length)(\"aria-controls\",ctx_r1._getTabContentId(i_r5))(\"aria-selected\",ctx_r1.selectedIndex==i_r5)(\"aria-label\",tab_r4.ariaLabel||null)(\"aria-labelledby\",!tab_r4.ariaLabel&&tab_r4.ariaLabelledby?tab_r4.ariaLabelledby:null),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Gb(2),_angular_core__WEBPACK_IMPORTED_MODULE_4__.tc(\"ngIf\",tab_r4.templateLabel),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Gb(1),_angular_core__WEBPACK_IMPORTED_MODULE_4__.tc(\"ngIf\",!tab_r4.templateLabel)}}function MatTabGroup_mat_tab_body_5_Template(rf,ctx){if(1&rf){const _r17=_angular_core__WEBPACK_IMPORTED_MODULE_4__.ac();_angular_core__WEBPACK_IMPORTED_MODULE_4__.Zb(0,\"mat-tab-body\",10),_angular_core__WEBPACK_IMPORTED_MODULE_4__.jc(\"_onCentered\",function(){return _angular_core__WEBPACK_IMPORTED_MODULE_4__.Ic(_r17),_angular_core__WEBPACK_IMPORTED_MODULE_4__.nc()._removeTabBodyWrapperHeight()})(\"_onCentering\",function($event){return _angular_core__WEBPACK_IMPORTED_MODULE_4__.Ic(_r17),_angular_core__WEBPACK_IMPORTED_MODULE_4__.nc()._setTabBodyWrapperHeight($event)}),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Yb()}if(2&rf){const tab_r14=ctx.$implicit,i_r15=ctx.index,ctx_r3=_angular_core__WEBPACK_IMPORTED_MODULE_4__.nc();_angular_core__WEBPACK_IMPORTED_MODULE_4__.Lb(\"mat-tab-body-active\",ctx_r3.selectedIndex==i_r15),_angular_core__WEBPACK_IMPORTED_MODULE_4__.tc(\"id\",ctx_r3._getTabContentId(i_r15))(\"content\",tab_r14.content)(\"position\",tab_r14.position)(\"origin\",tab_r14.origin)(\"animationDuration\",ctx_r3.animationDuration),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Hb(\"aria-labelledby\",ctx_r3._getTabLabelId(i_r15))}}const _c5=[\"tabListContainer\"],_c6=[\"tabList\"],_c7=[\"nextPaginator\"],_c8=[\"previousPaginator\"],_MAT_INK_BAR_POSITIONER=new _angular_core__WEBPACK_IMPORTED_MODULE_4__.u(\"MatInkBarPositioner\",{providedIn:\"root\",factory:function(){return element=>({left:element?(element.offsetLeft||0)+\"px\":\"0\",width:element?(element.offsetWidth||0)+\"px\":\"0\"})}});let MatInkBar=(()=>{class MatInkBar{constructor(_elementRef,_ngZone,_inkBarPositioner,_animationMode){this._elementRef=_elementRef,this._ngZone=_ngZone,this._inkBarPositioner=_inkBarPositioner,this._animationMode=_animationMode}alignToElement(element){this.show(),\"undefined\"!=typeof requestAnimationFrame?this._ngZone.runOutsideAngular(()=>{requestAnimationFrame(()=>this._setStyles(element))}):this._setStyles(element)}show(){this._elementRef.nativeElement.style.visibility=\"visible\"}hide(){this._elementRef.nativeElement.style.visibility=\"hidden\"}_setStyles(element){const positions=this._inkBarPositioner(element),inkBar=this._elementRef.nativeElement;inkBar.style.left=positions.left,inkBar.style.width=positions.width}}return MatInkBar.ɵfac=function(t){return new(t||MatInkBar)(_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_4__.m),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_4__.F),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_MAT_INK_BAR_POSITIONER),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_6__.a,8))},MatInkBar.ɵdir=_angular_core__WEBPACK_IMPORTED_MODULE_4__.Ob({type:MatInkBar,selectors:[[\"mat-ink-bar\"]],hostAttrs:[1,\"mat-ink-bar\"],hostVars:2,hostBindings:function(rf,ctx){2&rf&&_angular_core__WEBPACK_IMPORTED_MODULE_4__.Lb(\"_mat-animation-noopable\",\"NoopAnimations\"===ctx._animationMode)}}),MatInkBar})();const MAT_TAB_CONTENT=new _angular_core__WEBPACK_IMPORTED_MODULE_4__.u(\"MatTabContent\"),MAT_TAB_LABEL=new _angular_core__WEBPACK_IMPORTED_MODULE_4__.u(\"MatTabLabel\");let MatTabLabel=(()=>{class MatTabLabel extends _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_2__.b{}return MatTabLabel.ɵfac=function(t){return ɵMatTabLabel_BaseFactory(t||MatTabLabel)},MatTabLabel.ɵdir=_angular_core__WEBPACK_IMPORTED_MODULE_4__.Ob({type:MatTabLabel,selectors:[[\"\",\"mat-tab-label\",\"\"],[\"\",\"matTabLabel\",\"\"]],features:[_angular_core__WEBPACK_IMPORTED_MODULE_4__.Fb([{provide:MAT_TAB_LABEL,useExisting:MatTabLabel}]),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Db]}),MatTabLabel})();const ɵMatTabLabel_BaseFactory=_angular_core__WEBPACK_IMPORTED_MODULE_4__.bc(MatTabLabel);class MatTabBase{}const _MatTabMixinBase=Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_5__.A)(MatTabBase),MAT_TAB_GROUP=new _angular_core__WEBPACK_IMPORTED_MODULE_4__.u(\"MAT_TAB_GROUP\");let MatTab=(()=>{class MatTab extends _MatTabMixinBase{constructor(_viewContainerRef,_closestTabGroup){super(),this._viewContainerRef=_viewContainerRef,this._closestTabGroup=_closestTabGroup,this.textLabel=\"\",this._contentPortal=null,this._stateChanges=new rxjs__WEBPACK_IMPORTED_MODULE_7__.a,this.position=null,this.origin=null,this.isActive=!1}get templateLabel(){return this._templateLabel}set templateLabel(value){this._setTemplateLabelInput(value)}get content(){return this._contentPortal}ngOnChanges(changes){(changes.hasOwnProperty(\"textLabel\")||changes.hasOwnProperty(\"disabled\"))&&this._stateChanges.next()}ngOnDestroy(){this._stateChanges.complete()}ngOnInit(){this._contentPortal=new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_2__.g(this._explicitContent||this._implicitContent,this._viewContainerRef)}_setTemplateLabelInput(value){value&&(this._templateLabel=value)}}return MatTab.ɵfac=function(t){return new(t||MatTab)(_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_4__.V),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(MAT_TAB_GROUP))},MatTab.ɵcmp=_angular_core__WEBPACK_IMPORTED_MODULE_4__.Nb({type:MatTab,selectors:[[\"mat-tab\"]],contentQueries:function(rf,ctx,dirIndex){if(1&rf&&(_angular_core__WEBPACK_IMPORTED_MODULE_4__.Mb(dirIndex,MAT_TAB_LABEL,!0),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Mc(dirIndex,MAT_TAB_CONTENT,!0,_angular_core__WEBPACK_IMPORTED_MODULE_4__.R)),2&rf){let _t;_angular_core__WEBPACK_IMPORTED_MODULE_4__.Fc(_t=_angular_core__WEBPACK_IMPORTED_MODULE_4__.kc())&&(ctx.templateLabel=_t.first),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Fc(_t=_angular_core__WEBPACK_IMPORTED_MODULE_4__.kc())&&(ctx._explicitContent=_t.first)}},viewQuery:function(rf,ctx){if(1&rf&&_angular_core__WEBPACK_IMPORTED_MODULE_4__.Nc(_angular_core__WEBPACK_IMPORTED_MODULE_4__.R,!0),2&rf){let _t;_angular_core__WEBPACK_IMPORTED_MODULE_4__.Fc(_t=_angular_core__WEBPACK_IMPORTED_MODULE_4__.kc())&&(ctx._implicitContent=_t.first)}},inputs:{disabled:\"disabled\",textLabel:[\"label\",\"textLabel\"],ariaLabel:[\"aria-label\",\"ariaLabel\"],ariaLabelledby:[\"aria-labelledby\",\"ariaLabelledby\"]},exportAs:[\"matTab\"],features:[_angular_core__WEBPACK_IMPORTED_MODULE_4__.Db,_angular_core__WEBPACK_IMPORTED_MODULE_4__.Eb],ngContentSelectors:_c0,decls:1,vars:0,template:function(rf,ctx){1&rf&&(_angular_core__WEBPACK_IMPORTED_MODULE_4__.sc(),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Sc(0,MatTab_ng_template_0_Template,1,0,\"ng-template\"))},encapsulation:2}),MatTab})();const matTabsAnimations={translateTab:Object(_angular_animations__WEBPACK_IMPORTED_MODULE_13__.n)(\"translateTab\",[Object(_angular_animations__WEBPACK_IMPORTED_MODULE_13__.k)(\"center, void, left-origin-center, right-origin-center\",Object(_angular_animations__WEBPACK_IMPORTED_MODULE_13__.l)({transform:\"none\"})),Object(_angular_animations__WEBPACK_IMPORTED_MODULE_13__.k)(\"left\",Object(_angular_animations__WEBPACK_IMPORTED_MODULE_13__.l)({transform:\"translate3d(-100%, 0, 0)\",minHeight:\"1px\"})),Object(_angular_animations__WEBPACK_IMPORTED_MODULE_13__.k)(\"right\",Object(_angular_animations__WEBPACK_IMPORTED_MODULE_13__.l)({transform:\"translate3d(100%, 0, 0)\",minHeight:\"1px\"})),Object(_angular_animations__WEBPACK_IMPORTED_MODULE_13__.m)(\"* => left, * => right, left => center, right => center\",Object(_angular_animations__WEBPACK_IMPORTED_MODULE_13__.e)(\"{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)\")),Object(_angular_animations__WEBPACK_IMPORTED_MODULE_13__.m)(\"void => left-origin-center\",[Object(_angular_animations__WEBPACK_IMPORTED_MODULE_13__.l)({transform:\"translate3d(-100%, 0, 0)\"}),Object(_angular_animations__WEBPACK_IMPORTED_MODULE_13__.e)(\"{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)\")]),Object(_angular_animations__WEBPACK_IMPORTED_MODULE_13__.m)(\"void => right-origin-center\",[Object(_angular_animations__WEBPACK_IMPORTED_MODULE_13__.l)({transform:\"translate3d(100%, 0, 0)\"}),Object(_angular_animations__WEBPACK_IMPORTED_MODULE_13__.e)(\"{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)\")])])};let MatTabBodyPortal=(()=>{class MatTabBodyPortal extends _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_2__.c{constructor(componentFactoryResolver,viewContainerRef,_host,_document){super(componentFactoryResolver,viewContainerRef,_document),this._host=_host,this._centeringSub=rxjs__WEBPACK_IMPORTED_MODULE_8__.a.EMPTY,this._leavingSub=rxjs__WEBPACK_IMPORTED_MODULE_8__.a.EMPTY}ngOnInit(){super.ngOnInit(),this._centeringSub=this._host._beforeCentering.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__.a)(this._host._isCenterPosition(this._host._position))).subscribe(isCentering=>{isCentering&&!this.hasAttached()&&this.attach(this._host._content)}),this._leavingSub=this._host._afterLeavingCenter.subscribe(()=>{this.detach()})}ngOnDestroy(){super.ngOnDestroy(),this._centeringSub.unsubscribe(),this._leavingSub.unsubscribe()}}return MatTabBodyPortal.ɵfac=function(t){return new(t||MatTabBodyPortal)(_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_4__.k),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_4__.V),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(Object(_angular_core__WEBPACK_IMPORTED_MODULE_4__.Z)(()=>MatTabBody)),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_common__WEBPACK_IMPORTED_MODULE_3__.d))},MatTabBodyPortal.ɵdir=_angular_core__WEBPACK_IMPORTED_MODULE_4__.Ob({type:MatTabBodyPortal,selectors:[[\"\",\"matTabBodyHost\",\"\"]],features:[_angular_core__WEBPACK_IMPORTED_MODULE_4__.Db]}),MatTabBodyPortal})(),_MatTabBodyBase=(()=>{class _MatTabBodyBase{constructor(_elementRef,_dir,changeDetectorRef){this._elementRef=_elementRef,this._dir=_dir,this._dirChangeSubscription=rxjs__WEBPACK_IMPORTED_MODULE_8__.a.EMPTY,this._translateTabComplete=new rxjs__WEBPACK_IMPORTED_MODULE_7__.a,this._onCentering=new _angular_core__WEBPACK_IMPORTED_MODULE_4__.p,this._beforeCentering=new _angular_core__WEBPACK_IMPORTED_MODULE_4__.p,this._afterLeavingCenter=new _angular_core__WEBPACK_IMPORTED_MODULE_4__.p,this._onCentered=new _angular_core__WEBPACK_IMPORTED_MODULE_4__.p(!0),this.animationDuration=\"500ms\",_dir&&(this._dirChangeSubscription=_dir.change.subscribe(dir=>{this._computePositionAnimationState(dir),changeDetectorRef.markForCheck()})),this._translateTabComplete.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_15__.a)((x,y)=>x.fromState===y.fromState&&x.toState===y.toState)).subscribe(event=>{this._isCenterPosition(event.toState)&&this._isCenterPosition(this._position)&&this._onCentered.emit(),this._isCenterPosition(event.fromState)&&!this._isCenterPosition(this._position)&&this._afterLeavingCenter.emit()})}set position(position){this._positionIndex=position,this._computePositionAnimationState()}ngOnInit(){\"center\"==this._position&&null!=this.origin&&(this._position=this._computePositionFromOrigin(this.origin))}ngOnDestroy(){this._dirChangeSubscription.unsubscribe(),this._translateTabComplete.complete()}_onTranslateTabStarted(event){const isCentering=this._isCenterPosition(event.toState);this._beforeCentering.emit(isCentering),isCentering&&this._onCentering.emit(this._elementRef.nativeElement.clientHeight)}_getLayoutDirection(){return this._dir&&\"rtl\"===this._dir.value?\"rtl\":\"ltr\"}_isCenterPosition(position){return\"center\"==position||\"left-origin-center\"==position||\"right-origin-center\"==position}_computePositionAnimationState(dir=this._getLayoutDirection()){this._position=this._positionIndex<0?\"ltr\"==dir?\"left\":\"right\":this._positionIndex>0?\"ltr\"==dir?\"right\":\"left\":\"center\"}_computePositionFromOrigin(origin){const dir=this._getLayoutDirection();return\"ltr\"==dir&&origin<=0||\"rtl\"==dir&&origin>0?\"left-origin-center\":\"right-origin-center\"}}return _MatTabBodyBase.ɵfac=function(t){return new(t||_MatTabBodyBase)(_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_4__.m),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_20__.b,8),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_4__.i))},_MatTabBodyBase.ɵdir=_angular_core__WEBPACK_IMPORTED_MODULE_4__.Ob({type:_MatTabBodyBase,inputs:{animationDuration:\"animationDuration\",position:\"position\",_content:[\"content\",\"_content\"],origin:\"origin\"},outputs:{_onCentering:\"_onCentering\",_beforeCentering:\"_beforeCentering\",_afterLeavingCenter:\"_afterLeavingCenter\",_onCentered:\"_onCentered\"}}),_MatTabBodyBase})(),MatTabBody=(()=>{class MatTabBody extends _MatTabBodyBase{constructor(elementRef,dir,changeDetectorRef){super(elementRef,dir,changeDetectorRef)}}return MatTabBody.ɵfac=function(t){return new(t||MatTabBody)(_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_4__.m),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_20__.b,8),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_4__.i))},MatTabBody.ɵcmp=_angular_core__WEBPACK_IMPORTED_MODULE_4__.Nb({type:MatTabBody,selectors:[[\"mat-tab-body\"]],viewQuery:function(rf,ctx){if(1&rf&&_angular_core__WEBPACK_IMPORTED_MODULE_4__.Zc(_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_2__.c,!0),2&rf){let _t;_angular_core__WEBPACK_IMPORTED_MODULE_4__.Fc(_t=_angular_core__WEBPACK_IMPORTED_MODULE_4__.kc())&&(ctx._portalHost=_t.first)}},hostAttrs:[1,\"mat-tab-body\"],features:[_angular_core__WEBPACK_IMPORTED_MODULE_4__.Db],decls:3,vars:6,consts:[[\"cdkScrollable\",\"\",1,\"mat-tab-body-content\"],[\"content\",\"\"],[\"matTabBodyHost\",\"\"]],template:function(rf,ctx){1&rf&&(_angular_core__WEBPACK_IMPORTED_MODULE_4__.Zb(0,\"div\",0,1),_angular_core__WEBPACK_IMPORTED_MODULE_4__.jc(\"@translateTab.start\",function($event){return ctx._onTranslateTabStarted($event)})(\"@translateTab.done\",function($event){return ctx._translateTabComplete.next($event)}),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Sc(2,MatTabBody_ng_template_2_Template,0,0,\"ng-template\",2),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Yb()),2&rf&&_angular_core__WEBPACK_IMPORTED_MODULE_4__.tc(\"@translateTab\",_angular_core__WEBPACK_IMPORTED_MODULE_4__.yc(3,_c2,ctx._position,_angular_core__WEBPACK_IMPORTED_MODULE_4__.xc(1,_c1,ctx.animationDuration)))},directives:[MatTabBodyPortal],styles:[\".mat-tab-body-content{height:100%;overflow:auto}.mat-tab-group-dynamic-height .mat-tab-body-content{overflow:hidden}\\n\"],encapsulation:2,data:{animation:[matTabsAnimations.translateTab]}}),MatTabBody})();const MAT_TABS_CONFIG=new _angular_core__WEBPACK_IMPORTED_MODULE_4__.u(\"MAT_TABS_CONFIG\");let nextId=0;class MatTabChangeEvent{}class MatTabGroupMixinBase{constructor(_elementRef){this._elementRef=_elementRef}}const _MatTabGroupMixinBase=Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_5__.y)(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_5__.z)(MatTabGroupMixinBase),\"primary\");let _MatTabGroupBase=(()=>{class _MatTabGroupBase extends _MatTabGroupMixinBase{constructor(elementRef,_changeDetectorRef,defaultConfig,_animationMode){super(elementRef),this._changeDetectorRef=_changeDetectorRef,this._animationMode=_animationMode,this._tabs=new _angular_core__WEBPACK_IMPORTED_MODULE_4__.J,this._indexToSelect=0,this._tabBodyWrapperHeight=0,this._tabsSubscription=rxjs__WEBPACK_IMPORTED_MODULE_8__.a.EMPTY,this._tabLabelSubscription=rxjs__WEBPACK_IMPORTED_MODULE_8__.a.EMPTY,this._selectedIndex=null,this.headerPosition=\"above\",this.selectedIndexChange=new _angular_core__WEBPACK_IMPORTED_MODULE_4__.p,this.focusChange=new _angular_core__WEBPACK_IMPORTED_MODULE_4__.p,this.animationDone=new _angular_core__WEBPACK_IMPORTED_MODULE_4__.p,this.selectedTabChange=new _angular_core__WEBPACK_IMPORTED_MODULE_4__.p(!0),this._groupId=nextId++,this.animationDuration=defaultConfig&&defaultConfig.animationDuration?defaultConfig.animationDuration:\"500ms\",this.disablePagination=!(!defaultConfig||null==defaultConfig.disablePagination)&&defaultConfig.disablePagination,this.dynamicHeight=!(!defaultConfig||null==defaultConfig.dynamicHeight)&&defaultConfig.dynamicHeight}get dynamicHeight(){return this._dynamicHeight}set dynamicHeight(value){this._dynamicHeight=Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_17__.c)(value)}get selectedIndex(){return this._selectedIndex}set selectedIndex(value){this._indexToSelect=Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_17__.f)(value,null)}get animationDuration(){return this._animationDuration}set animationDuration(value){this._animationDuration=/^\\d+$/.test(value)?value+\"ms\":value}get backgroundColor(){return this._backgroundColor}set backgroundColor(value){const nativeElement=this._elementRef.nativeElement;nativeElement.classList.remove(\"mat-background-\"+this.backgroundColor),value&&nativeElement.classList.add(\"mat-background-\"+value),this._backgroundColor=value}ngAfterContentChecked(){const indexToSelect=this._indexToSelect=this._clampTabIndex(this._indexToSelect);if(this._selectedIndex!=indexToSelect){const isFirstRun=null==this._selectedIndex;if(!isFirstRun){this.selectedTabChange.emit(this._createChangeEvent(indexToSelect));const wrapper=this._tabBodyWrapper.nativeElement;wrapper.style.minHeight=wrapper.clientHeight+\"px\"}Promise.resolve().then(()=>{this._tabs.forEach((tab,index)=>tab.isActive=index===indexToSelect),isFirstRun||(this.selectedIndexChange.emit(indexToSelect),this._tabBodyWrapper.nativeElement.style.minHeight=\"\")})}this._tabs.forEach((tab,index)=>{tab.position=index-indexToSelect,null==this._selectedIndex||0!=tab.position||tab.origin||(tab.origin=indexToSelect-this._selectedIndex)}),this._selectedIndex!==indexToSelect&&(this._selectedIndex=indexToSelect,this._changeDetectorRef.markForCheck())}ngAfterContentInit(){this._subscribeToAllTabChanges(),this._subscribeToTabLabels(),this._tabsSubscription=this._tabs.changes.subscribe(()=>{if(this._clampTabIndex(this._indexToSelect)===this._selectedIndex){const tabs=this._tabs.toArray();for(let i=0;i<tabs.length;i++)if(tabs[i].isActive){this._indexToSelect=this._selectedIndex=i;break}}this._changeDetectorRef.markForCheck()})}_subscribeToAllTabChanges(){this._allTabs.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__.a)(this._allTabs)).subscribe(tabs=>{this._tabs.reset(tabs.filter(tab=>tab._closestTabGroup===this)),this._tabs.notifyOnChanges()})}ngOnDestroy(){this._tabs.destroy(),this._tabsSubscription.unsubscribe(),this._tabLabelSubscription.unsubscribe()}realignInkBar(){this._tabHeader&&this._tabHeader._alignInkBarToSelectedTab()}_focusChanged(index){this.focusChange.emit(this._createChangeEvent(index))}_createChangeEvent(index){const event=new MatTabChangeEvent;return event.index=index,this._tabs&&this._tabs.length&&(event.tab=this._tabs.toArray()[index]),event}_subscribeToTabLabels(){this._tabLabelSubscription&&this._tabLabelSubscription.unsubscribe(),this._tabLabelSubscription=Object(rxjs__WEBPACK_IMPORTED_MODULE_9__.a)(...this._tabs.map(tab=>tab._stateChanges)).subscribe(()=>this._changeDetectorRef.markForCheck())}_clampTabIndex(index){return Math.min(this._tabs.length-1,Math.max(index||0,0))}_getTabLabelId(i){return`mat-tab-label-${this._groupId}-${i}`}_getTabContentId(i){return`mat-tab-content-${this._groupId}-${i}`}_setTabBodyWrapperHeight(tabHeight){if(!this._dynamicHeight||!this._tabBodyWrapperHeight)return;const wrapper=this._tabBodyWrapper.nativeElement;wrapper.style.height=this._tabBodyWrapperHeight+\"px\",this._tabBodyWrapper.nativeElement.offsetHeight&&(wrapper.style.height=tabHeight+\"px\")}_removeTabBodyWrapperHeight(){const wrapper=this._tabBodyWrapper.nativeElement;this._tabBodyWrapperHeight=wrapper.clientHeight,wrapper.style.height=\"\",this.animationDone.emit()}_handleClick(tab,tabHeader,index){tab.disabled||(this.selectedIndex=tabHeader.focusIndex=index)}_getTabIndex(tab,idx){return tab.disabled?null:this.selectedIndex===idx?0:-1}_tabFocusChanged(focusOrigin,index){focusOrigin&&(this._tabHeader.focusIndex=index)}}return _MatTabGroupBase.ɵfac=function(t){return new(t||_MatTabGroupBase)(_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_4__.m),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_4__.i),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(MAT_TABS_CONFIG,8),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_6__.a,8))},_MatTabGroupBase.ɵdir=_angular_core__WEBPACK_IMPORTED_MODULE_4__.Ob({type:_MatTabGroupBase,inputs:{headerPosition:\"headerPosition\",animationDuration:\"animationDuration\",disablePagination:\"disablePagination\",dynamicHeight:\"dynamicHeight\",selectedIndex:\"selectedIndex\",backgroundColor:\"backgroundColor\"},outputs:{selectedIndexChange:\"selectedIndexChange\",focusChange:\"focusChange\",animationDone:\"animationDone\",selectedTabChange:\"selectedTabChange\"},features:[_angular_core__WEBPACK_IMPORTED_MODULE_4__.Db]}),_MatTabGroupBase})(),MatTabGroup=(()=>{class MatTabGroup extends _MatTabGroupBase{constructor(elementRef,changeDetectorRef,defaultConfig,animationMode){super(elementRef,changeDetectorRef,defaultConfig,animationMode)}}return MatTabGroup.ɵfac=function(t){return new(t||MatTabGroup)(_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_4__.m),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_4__.i),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(MAT_TABS_CONFIG,8),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_6__.a,8))},MatTabGroup.ɵcmp=_angular_core__WEBPACK_IMPORTED_MODULE_4__.Nb({type:MatTabGroup,selectors:[[\"mat-tab-group\"]],contentQueries:function(rf,ctx,dirIndex){if(1&rf&&_angular_core__WEBPACK_IMPORTED_MODULE_4__.Mb(dirIndex,MatTab,!0),2&rf){let _t;_angular_core__WEBPACK_IMPORTED_MODULE_4__.Fc(_t=_angular_core__WEBPACK_IMPORTED_MODULE_4__.kc())&&(ctx._allTabs=_t)}},viewQuery:function(rf,ctx){if(1&rf&&(_angular_core__WEBPACK_IMPORTED_MODULE_4__.Zc(_c3,!0),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Zc(_c4,!0)),2&rf){let _t;_angular_core__WEBPACK_IMPORTED_MODULE_4__.Fc(_t=_angular_core__WEBPACK_IMPORTED_MODULE_4__.kc())&&(ctx._tabBodyWrapper=_t.first),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Fc(_t=_angular_core__WEBPACK_IMPORTED_MODULE_4__.kc())&&(ctx._tabHeader=_t.first)}},hostAttrs:[1,\"mat-tab-group\"],hostVars:4,hostBindings:function(rf,ctx){2&rf&&_angular_core__WEBPACK_IMPORTED_MODULE_4__.Lb(\"mat-tab-group-dynamic-height\",ctx.dynamicHeight)(\"mat-tab-group-inverted-header\",\"below\"===ctx.headerPosition)},inputs:{color:\"color\",disableRipple:\"disableRipple\"},exportAs:[\"matTabGroup\"],features:[_angular_core__WEBPACK_IMPORTED_MODULE_4__.Fb([{provide:MAT_TAB_GROUP,useExisting:MatTabGroup}]),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Db],decls:6,vars:7,consts:[[3,\"selectedIndex\",\"disableRipple\",\"disablePagination\",\"indexFocused\",\"selectFocusedIndex\"],[\"tabHeader\",\"\"],[\"class\",\"mat-tab-label mat-focus-indicator\",\"role\",\"tab\",\"matTabLabelWrapper\",\"\",\"mat-ripple\",\"\",\"cdkMonitorElementFocus\",\"\",3,\"id\",\"mat-tab-label-active\",\"disabled\",\"matRippleDisabled\",\"click\",\"cdkFocusChange\",4,\"ngFor\",\"ngForOf\"],[1,\"mat-tab-body-wrapper\"],[\"tabBodyWrapper\",\"\"],[\"role\",\"tabpanel\",3,\"id\",\"mat-tab-body-active\",\"content\",\"position\",\"origin\",\"animationDuration\",\"_onCentered\",\"_onCentering\",4,\"ngFor\",\"ngForOf\"],[\"role\",\"tab\",\"matTabLabelWrapper\",\"\",\"mat-ripple\",\"\",\"cdkMonitorElementFocus\",\"\",1,\"mat-tab-label\",\"mat-focus-indicator\",3,\"id\",\"disabled\",\"matRippleDisabled\",\"click\",\"cdkFocusChange\"],[1,\"mat-tab-label-content\"],[3,\"ngIf\"],[3,\"cdkPortalOutlet\"],[\"role\",\"tabpanel\",3,\"id\",\"content\",\"position\",\"origin\",\"animationDuration\",\"_onCentered\",\"_onCentering\"]],template:function(rf,ctx){1&rf&&(_angular_core__WEBPACK_IMPORTED_MODULE_4__.Zb(0,\"mat-tab-header\",0,1),_angular_core__WEBPACK_IMPORTED_MODULE_4__.jc(\"indexFocused\",function($event){return ctx._focusChanged($event)})(\"selectFocusedIndex\",function($event){return ctx.selectedIndex=$event}),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Sc(2,MatTabGroup_div_2_Template,4,14,\"div\",2),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Yb(),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Zb(3,\"div\",3,4),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Sc(5,MatTabGroup_mat_tab_body_5_Template,1,8,\"mat-tab-body\",5),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Yb()),2&rf&&(_angular_core__WEBPACK_IMPORTED_MODULE_4__.tc(\"selectedIndex\",ctx.selectedIndex||0)(\"disableRipple\",ctx.disableRipple)(\"disablePagination\",ctx.disablePagination),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Gb(2),_angular_core__WEBPACK_IMPORTED_MODULE_4__.tc(\"ngForOf\",ctx._tabs),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Gb(1),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Lb(\"_mat-animation-noopable\",\"NoopAnimations\"===ctx._animationMode),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Gb(2),_angular_core__WEBPACK_IMPORTED_MODULE_4__.tc(\"ngForOf\",ctx._tabs))},directives:function(){return[MatTabHeader,_angular_common__WEBPACK_IMPORTED_MODULE_3__.m,MatTabLabelWrapper,_angular_material_core__WEBPACK_IMPORTED_MODULE_5__.t,_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__.e,_angular_common__WEBPACK_IMPORTED_MODULE_3__.n,_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_2__.c,MatTabBody]},styles:[\".mat-tab-group{display:flex;flex-direction:column}.mat-tab-group.mat-tab-group-inverted-header{flex-direction:column-reverse}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:none}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}.cdk-high-contrast-active .mat-tab-label:focus{outline:dotted 2px;outline-offset:-2px}.mat-tab-label.mat-tab-disabled{cursor:default}.cdk-high-contrast-active .mat-tab-label.mat-tab-disabled{opacity:.5}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.cdk-high-contrast-active .mat-tab-label{opacity:1}@media(max-width: 599px){.mat-tab-label{padding:0 12px}}@media(max-width: 959px){.mat-tab-label{padding:0 12px}}.mat-tab-group[mat-stretch-tabs]>.mat-tab-header .mat-tab-label{flex-basis:0;flex-grow:1}.mat-tab-body-wrapper{position:relative;overflow:hidden;display:flex;transition:height 500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-tab-body-wrapper{transition:none;animation:none}.mat-tab-body{top:0;left:0;right:0;bottom:0;position:absolute;display:block;overflow:hidden;flex-basis:100%}.mat-tab-body.mat-tab-body-active{position:relative;overflow-x:hidden;overflow-y:auto;z-index:1;flex-grow:1}.mat-tab-group.mat-tab-group-dynamic-height .mat-tab-body.mat-tab-body-active{overflow-y:hidden}\\n\"],encapsulation:2}),MatTabGroup})();class MatTabLabelWrapperBase{}const _MatTabLabelWrapperMixinBase=Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_5__.A)(MatTabLabelWrapperBase);let MatTabLabelWrapper=(()=>{class MatTabLabelWrapper extends _MatTabLabelWrapperMixinBase{constructor(elementRef){super(),this.elementRef=elementRef}focus(){this.elementRef.nativeElement.focus()}getOffsetLeft(){return this.elementRef.nativeElement.offsetLeft}getOffsetWidth(){return this.elementRef.nativeElement.offsetWidth}}return MatTabLabelWrapper.ɵfac=function(t){return new(t||MatTabLabelWrapper)(_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_4__.m))},MatTabLabelWrapper.ɵdir=_angular_core__WEBPACK_IMPORTED_MODULE_4__.Ob({type:MatTabLabelWrapper,selectors:[[\"\",\"matTabLabelWrapper\",\"\"]],hostVars:3,hostBindings:function(rf,ctx){2&rf&&(_angular_core__WEBPACK_IMPORTED_MODULE_4__.Hb(\"aria-disabled\",!!ctx.disabled),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Lb(\"mat-tab-disabled\",ctx.disabled))},inputs:{disabled:\"disabled\"},features:[_angular_core__WEBPACK_IMPORTED_MODULE_4__.Db]}),MatTabLabelWrapper})();const passiveEventListenerOptions=Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_18__.f)({passive:!0});let MatPaginatedTabHeader=(()=>{class MatPaginatedTabHeader{constructor(_elementRef,_changeDetectorRef,_viewportRuler,_dir,_ngZone,_platform,_animationMode){this._elementRef=_elementRef,this._changeDetectorRef=_changeDetectorRef,this._viewportRuler=_viewportRuler,this._dir=_dir,this._ngZone=_ngZone,this._platform=_platform,this._animationMode=_animationMode,this._scrollDistance=0,this._selectedIndexChanged=!1,this._destroyed=new rxjs__WEBPACK_IMPORTED_MODULE_7__.a,this._showPaginationControls=!1,this._disableScrollAfter=!0,this._disableScrollBefore=!0,this._stopScrolling=new rxjs__WEBPACK_IMPORTED_MODULE_7__.a,this.disablePagination=!1,this._selectedIndex=0,this.selectFocusedIndex=new _angular_core__WEBPACK_IMPORTED_MODULE_4__.p,this.indexFocused=new _angular_core__WEBPACK_IMPORTED_MODULE_4__.p,_ngZone.runOutsideAngular(()=>{Object(rxjs__WEBPACK_IMPORTED_MODULE_10__.a)(_elementRef.nativeElement,\"mouseleave\").pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_16__.a)(this._destroyed)).subscribe(()=>{this._stopInterval()})})}get selectedIndex(){return this._selectedIndex}set selectedIndex(value){value=Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_17__.f)(value),this._selectedIndex!=value&&(this._selectedIndexChanged=!0,this._selectedIndex=value,this._keyManager&&this._keyManager.updateActiveItem(value))}ngAfterViewInit(){Object(rxjs__WEBPACK_IMPORTED_MODULE_10__.a)(this._previousPaginator.nativeElement,\"touchstart\",passiveEventListenerOptions).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_16__.a)(this._destroyed)).subscribe(()=>{this._handlePaginatorPress(\"before\")}),Object(rxjs__WEBPACK_IMPORTED_MODULE_10__.a)(this._nextPaginator.nativeElement,\"touchstart\",passiveEventListenerOptions).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_16__.a)(this._destroyed)).subscribe(()=>{this._handlePaginatorPress(\"after\")})}ngAfterContentInit(){const dirChange=this._dir?this._dir.change:Object(rxjs__WEBPACK_IMPORTED_MODULE_11__.a)(null),resize=this._viewportRuler.change(150),realign=()=>{this.updatePagination(),this._alignInkBarToSelectedTab()};this._keyManager=new _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__.g(this._items).withHorizontalOrientation(this._getLayoutDirection()).withHomeAndEnd().withWrap(),this._keyManager.updateActiveItem(this._selectedIndex),\"undefined\"!=typeof requestAnimationFrame?requestAnimationFrame(realign):realign(),Object(rxjs__WEBPACK_IMPORTED_MODULE_9__.a)(dirChange,resize,this._items.changes).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_16__.a)(this._destroyed)).subscribe(()=>{this._ngZone.run(()=>Promise.resolve().then(realign)),this._keyManager.withHorizontalOrientation(this._getLayoutDirection())}),this._keyManager.change.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_16__.a)(this._destroyed)).subscribe(newFocusIndex=>{this.indexFocused.emit(newFocusIndex),this._setTabFocus(newFocusIndex)})}ngAfterContentChecked(){this._tabLabelCount!=this._items.length&&(this.updatePagination(),this._tabLabelCount=this._items.length,this._changeDetectorRef.markForCheck()),this._selectedIndexChanged&&(this._scrollToLabel(this._selectedIndex),this._checkScrollingControls(),this._alignInkBarToSelectedTab(),this._selectedIndexChanged=!1,this._changeDetectorRef.markForCheck()),this._scrollDistanceChanged&&(this._updateTabScrollPosition(),this._scrollDistanceChanged=!1,this._changeDetectorRef.markForCheck())}ngOnDestroy(){this._destroyed.next(),this._destroyed.complete(),this._stopScrolling.complete()}_handleKeydown(event){if(!Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_19__.t)(event))switch(event.keyCode){case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_19__.g:case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_19__.o:this.focusIndex!==this.selectedIndex&&(this.selectFocusedIndex.emit(this.focusIndex),this._itemSelected(event));break;default:this._keyManager.onKeydown(event)}}_onContentChanges(){const textContent=this._elementRef.nativeElement.textContent;textContent!==this._currentTextContent&&(this._currentTextContent=textContent||\"\",this._ngZone.run(()=>{this.updatePagination(),this._alignInkBarToSelectedTab(),this._changeDetectorRef.markForCheck()}))}updatePagination(){this._checkPaginationEnabled(),this._checkScrollingControls(),this._updateTabScrollPosition()}get focusIndex(){return this._keyManager?this._keyManager.activeItemIndex:0}set focusIndex(value){this._isValidIndex(value)&&this.focusIndex!==value&&this._keyManager&&this._keyManager.setActiveItem(value)}_isValidIndex(index){if(!this._items)return!0;const tab=this._items?this._items.toArray()[index]:null;return!!tab&&!tab.disabled}_setTabFocus(tabIndex){if(this._showPaginationControls&&this._scrollToLabel(tabIndex),this._items&&this._items.length){this._items.toArray()[tabIndex].focus();const containerEl=this._tabListContainer.nativeElement,dir=this._getLayoutDirection();containerEl.scrollLeft=\"ltr\"==dir?0:containerEl.scrollWidth-containerEl.offsetWidth}}_getLayoutDirection(){return this._dir&&\"rtl\"===this._dir.value?\"rtl\":\"ltr\"}_updateTabScrollPosition(){if(this.disablePagination)return;const scrollDistance=this.scrollDistance,translateX=\"ltr\"===this._getLayoutDirection()?-scrollDistance:scrollDistance;this._tabList.nativeElement.style.transform=`translateX(${Math.round(translateX)}px)`,(this._platform.TRIDENT||this._platform.EDGE)&&(this._tabListContainer.nativeElement.scrollLeft=0)}get scrollDistance(){return this._scrollDistance}set scrollDistance(value){this._scrollTo(value)}_scrollHeader(direction){return this._scrollTo(this._scrollDistance+(\"before\"==direction?-1:1)*this._tabListContainer.nativeElement.offsetWidth/3)}_handlePaginatorClick(direction){this._stopInterval(),this._scrollHeader(direction)}_scrollToLabel(labelIndex){if(this.disablePagination)return;const selectedLabel=this._items?this._items.toArray()[labelIndex]:null;if(!selectedLabel)return;const viewLength=this._tabListContainer.nativeElement.offsetWidth,{offsetLeft:offsetLeft,offsetWidth:offsetWidth}=selectedLabel.elementRef.nativeElement;let labelBeforePos,labelAfterPos;\"ltr\"==this._getLayoutDirection()?(labelBeforePos=offsetLeft,labelAfterPos=labelBeforePos+offsetWidth):(labelAfterPos=this._tabList.nativeElement.offsetWidth-offsetLeft,labelBeforePos=labelAfterPos-offsetWidth);const beforeVisiblePos=this.scrollDistance,afterVisiblePos=this.scrollDistance+viewLength;labelBeforePos<beforeVisiblePos?this.scrollDistance-=beforeVisiblePos-labelBeforePos+60:labelAfterPos>afterVisiblePos&&(this.scrollDistance+=labelAfterPos-afterVisiblePos+60)}_checkPaginationEnabled(){if(this.disablePagination)this._showPaginationControls=!1;else{const isEnabled=this._tabList.nativeElement.scrollWidth>this._elementRef.nativeElement.offsetWidth;isEnabled||(this.scrollDistance=0),isEnabled!==this._showPaginationControls&&this._changeDetectorRef.markForCheck(),this._showPaginationControls=isEnabled}}_checkScrollingControls(){this.disablePagination?this._disableScrollAfter=this._disableScrollBefore=!0:(this._disableScrollBefore=0==this.scrollDistance,this._disableScrollAfter=this.scrollDistance==this._getMaxScrollDistance(),this._changeDetectorRef.markForCheck())}_getMaxScrollDistance(){return this._tabList.nativeElement.scrollWidth-this._tabListContainer.nativeElement.offsetWidth||0}_alignInkBarToSelectedTab(){const selectedItem=this._items&&this._items.length?this._items.toArray()[this.selectedIndex]:null,selectedLabelWrapper=selectedItem?selectedItem.elementRef.nativeElement:null;selectedLabelWrapper?this._inkBar.alignToElement(selectedLabelWrapper):this._inkBar.hide()}_stopInterval(){this._stopScrolling.next()}_handlePaginatorPress(direction,mouseEvent){mouseEvent&&null!=mouseEvent.button&&0!==mouseEvent.button||(this._stopInterval(),Object(rxjs__WEBPACK_IMPORTED_MODULE_12__.a)(650,100).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_16__.a)(Object(rxjs__WEBPACK_IMPORTED_MODULE_9__.a)(this._stopScrolling,this._destroyed))).subscribe(()=>{const{maxScrollDistance:maxScrollDistance,distance:distance}=this._scrollHeader(direction);(0===distance||distance>=maxScrollDistance)&&this._stopInterval()}))}_scrollTo(position){if(this.disablePagination)return{maxScrollDistance:0,distance:0};const maxScrollDistance=this._getMaxScrollDistance();return this._scrollDistance=Math.max(0,Math.min(maxScrollDistance,position)),this._scrollDistanceChanged=!0,this._checkScrollingControls(),{maxScrollDistance:maxScrollDistance,distance:this._scrollDistance}}}return MatPaginatedTabHeader.ɵfac=function(t){return new(t||MatPaginatedTabHeader)(_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_4__.m),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_4__.i),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_21__.e),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_20__.b,8),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_4__.F),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_18__.a),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_6__.a,8))},MatPaginatedTabHeader.ɵdir=_angular_core__WEBPACK_IMPORTED_MODULE_4__.Ob({type:MatPaginatedTabHeader,inputs:{disablePagination:\"disablePagination\"}}),MatPaginatedTabHeader})(),_MatTabHeaderBase=(()=>{class _MatTabHeaderBase extends MatPaginatedTabHeader{constructor(elementRef,changeDetectorRef,viewportRuler,dir,ngZone,platform,animationMode){super(elementRef,changeDetectorRef,viewportRuler,dir,ngZone,platform,animationMode),this._disableRipple=!1}get disableRipple(){return this._disableRipple}set disableRipple(value){this._disableRipple=Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_17__.c)(value)}_itemSelected(event){event.preventDefault()}}return _MatTabHeaderBase.ɵfac=function(t){return new(t||_MatTabHeaderBase)(_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_4__.m),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_4__.i),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_21__.e),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_20__.b,8),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_4__.F),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_18__.a),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_6__.a,8))},_MatTabHeaderBase.ɵdir=_angular_core__WEBPACK_IMPORTED_MODULE_4__.Ob({type:_MatTabHeaderBase,inputs:{disableRipple:\"disableRipple\"},features:[_angular_core__WEBPACK_IMPORTED_MODULE_4__.Db]}),_MatTabHeaderBase})(),MatTabHeader=(()=>{class MatTabHeader extends _MatTabHeaderBase{constructor(elementRef,changeDetectorRef,viewportRuler,dir,ngZone,platform,animationMode){super(elementRef,changeDetectorRef,viewportRuler,dir,ngZone,platform,animationMode)}}return MatTabHeader.ɵfac=function(t){return new(t||MatTabHeader)(_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_4__.m),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_4__.i),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_21__.e),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_20__.b,8),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_4__.F),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_18__.a),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Tb(_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_6__.a,8))},MatTabHeader.ɵcmp=_angular_core__WEBPACK_IMPORTED_MODULE_4__.Nb({type:MatTabHeader,selectors:[[\"mat-tab-header\"]],contentQueries:function(rf,ctx,dirIndex){if(1&rf&&_angular_core__WEBPACK_IMPORTED_MODULE_4__.Mb(dirIndex,MatTabLabelWrapper,!1),2&rf){let _t;_angular_core__WEBPACK_IMPORTED_MODULE_4__.Fc(_t=_angular_core__WEBPACK_IMPORTED_MODULE_4__.kc())&&(ctx._items=_t)}},viewQuery:function(rf,ctx){if(1&rf&&(_angular_core__WEBPACK_IMPORTED_MODULE_4__.Nc(MatInkBar,!0),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Nc(_c5,!0),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Nc(_c6,!0),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Zc(_c7,!0),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Zc(_c8,!0)),2&rf){let _t;_angular_core__WEBPACK_IMPORTED_MODULE_4__.Fc(_t=_angular_core__WEBPACK_IMPORTED_MODULE_4__.kc())&&(ctx._inkBar=_t.first),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Fc(_t=_angular_core__WEBPACK_IMPORTED_MODULE_4__.kc())&&(ctx._tabListContainer=_t.first),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Fc(_t=_angular_core__WEBPACK_IMPORTED_MODULE_4__.kc())&&(ctx._tabList=_t.first),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Fc(_t=_angular_core__WEBPACK_IMPORTED_MODULE_4__.kc())&&(ctx._nextPaginator=_t.first),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Fc(_t=_angular_core__WEBPACK_IMPORTED_MODULE_4__.kc())&&(ctx._previousPaginator=_t.first)}},hostAttrs:[1,\"mat-tab-header\"],hostVars:4,hostBindings:function(rf,ctx){2&rf&&_angular_core__WEBPACK_IMPORTED_MODULE_4__.Lb(\"mat-tab-header-pagination-controls-enabled\",ctx._showPaginationControls)(\"mat-tab-header-rtl\",\"rtl\"==ctx._getLayoutDirection())},inputs:{selectedIndex:\"selectedIndex\"},outputs:{selectFocusedIndex:\"selectFocusedIndex\",indexFocused:\"indexFocused\"},features:[_angular_core__WEBPACK_IMPORTED_MODULE_4__.Db],ngContentSelectors:_c0,decls:13,vars:8,consts:[[\"aria-hidden\",\"true\",\"mat-ripple\",\"\",1,\"mat-tab-header-pagination\",\"mat-tab-header-pagination-before\",\"mat-elevation-z4\",3,\"matRippleDisabled\",\"click\",\"mousedown\",\"touchend\"],[\"previousPaginator\",\"\"],[1,\"mat-tab-header-pagination-chevron\"],[1,\"mat-tab-label-container\",3,\"keydown\"],[\"tabListContainer\",\"\"],[\"role\",\"tablist\",1,\"mat-tab-list\",3,\"cdkObserveContent\"],[\"tabList\",\"\"],[1,\"mat-tab-labels\"],[\"aria-hidden\",\"true\",\"mat-ripple\",\"\",1,\"mat-tab-header-pagination\",\"mat-tab-header-pagination-after\",\"mat-elevation-z4\",3,\"matRippleDisabled\",\"mousedown\",\"click\",\"touchend\"],[\"nextPaginator\",\"\"]],template:function(rf,ctx){1&rf&&(_angular_core__WEBPACK_IMPORTED_MODULE_4__.sc(),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Zb(0,\"div\",0,1),_angular_core__WEBPACK_IMPORTED_MODULE_4__.jc(\"click\",function(){return ctx._handlePaginatorClick(\"before\")})(\"mousedown\",function($event){return ctx._handlePaginatorPress(\"before\",$event)})(\"touchend\",function(){return ctx._stopInterval()}),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Ub(2,\"div\",2),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Yb(),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Zb(3,\"div\",3,4),_angular_core__WEBPACK_IMPORTED_MODULE_4__.jc(\"keydown\",function($event){return ctx._handleKeydown($event)}),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Zb(5,\"div\",5,6),_angular_core__WEBPACK_IMPORTED_MODULE_4__.jc(\"cdkObserveContent\",function(){return ctx._onContentChanges()}),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Zb(7,\"div\",7),_angular_core__WEBPACK_IMPORTED_MODULE_4__.rc(8),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Yb(),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Ub(9,\"mat-ink-bar\"),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Yb(),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Yb(),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Zb(10,\"div\",8,9),_angular_core__WEBPACK_IMPORTED_MODULE_4__.jc(\"mousedown\",function($event){return ctx._handlePaginatorPress(\"after\",$event)})(\"click\",function(){return ctx._handlePaginatorClick(\"after\")})(\"touchend\",function(){return ctx._stopInterval()}),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Ub(12,\"div\",2),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Yb()),2&rf&&(_angular_core__WEBPACK_IMPORTED_MODULE_4__.Lb(\"mat-tab-header-pagination-disabled\",ctx._disableScrollBefore),_angular_core__WEBPACK_IMPORTED_MODULE_4__.tc(\"matRippleDisabled\",ctx._disableScrollBefore||ctx.disableRipple),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Gb(5),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Lb(\"_mat-animation-noopable\",\"NoopAnimations\"===ctx._animationMode),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Gb(5),_angular_core__WEBPACK_IMPORTED_MODULE_4__.Lb(\"mat-tab-header-pagination-disabled\",ctx._disableScrollAfter),_angular_core__WEBPACK_IMPORTED_MODULE_4__.tc(\"matRippleDisabled\",ctx._disableScrollAfter||ctx.disableRipple))},directives:[_angular_material_core__WEBPACK_IMPORTED_MODULE_5__.t,_angular_cdk_observers__WEBPACK_IMPORTED_MODULE_1__.a,MatInkBar],styles:['.mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-header-pagination{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:transparent;touch-action:none}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-rtl .mat-tab-header-pagination-before,.mat-tab-header-pagination-after{padding-right:4px}.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:\"\";height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-list{flex-grow:1;position:relative;transition:transform 500ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-ink-bar{transition:none;animation:none}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}.cdk-high-contrast-active .mat-ink-bar{outline:solid 2px;height:0}.mat-tab-labels{display:flex}[mat-align-tabs=center]>.mat-tab-header .mat-tab-labels{justify-content:center}[mat-align-tabs=end]>.mat-tab-header .mat-tab-labels{justify-content:flex-end}.mat-tab-label-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}._mat-animation-noopable.mat-tab-list{transition:none;animation:none}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:none}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}.cdk-high-contrast-active .mat-tab-label:focus{outline:dotted 2px;outline-offset:-2px}.mat-tab-label.mat-tab-disabled{cursor:default}.cdk-high-contrast-active .mat-tab-label.mat-tab-disabled{opacity:.5}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.cdk-high-contrast-active .mat-tab-label{opacity:1}@media(max-width: 599px){.mat-tab-label{min-width:72px}}\\n'],encapsulation:2}),MatTabHeader})(),MatTabsModule=(()=>{class MatTabsModule{}return MatTabsModule.ɵmod=_angular_core__WEBPACK_IMPORTED_MODULE_4__.Rb({type:MatTabsModule}),MatTabsModule.ɵinj=_angular_core__WEBPACK_IMPORTED_MODULE_4__.Qb({factory:function(t){return new(t||MatTabsModule)},imports:[[_angular_common__WEBPACK_IMPORTED_MODULE_3__.c,_angular_material_core__WEBPACK_IMPORTED_MODULE_5__.j,_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_2__.f,_angular_material_core__WEBPACK_IMPORTED_MODULE_5__.u,_angular_cdk_observers__WEBPACK_IMPORTED_MODULE_1__.c,_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__.a],_angular_material_core__WEBPACK_IMPORTED_MODULE_5__.j]}),MatTabsModule})()}}]);","name":"1-es2015.47574b4e95ea50cdf3b2.js","input":"(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[1,31],{\n\n/***/ \"+rOU\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export BasePortalHost */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return BasePortalOutlet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return CdkPortal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return CdkPortalOutlet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return ComponentPortal; });\n/* unused harmony export DomPortal */\n/* unused harmony export DomPortalHost */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return DomPortalOutlet; });\n/* unused harmony export Portal */\n/* unused harmony export PortalHostDirective */\n/* unused harmony export PortalInjector */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return PortalModule; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return TemplatePortal; });\n/* unused harmony export TemplatePortalDirective */\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"fXoL\");\n/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"ofXK\");\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Throws an exception when attempting to attach a null portal to a host.\n * @docs-private\n */\n\nfunction throwNullPortalError() {\n    throw Error('Must provide a portal to attach');\n}\n/**\n * Throws an exception when attempting to attach a portal to a host that is already attached.\n * @docs-private\n */\nfunction throwPortalAlreadyAttachedError() {\n    throw Error('Host already has a portal attached');\n}\n/**\n * Throws an exception when attempting to attach a portal to an already-disposed host.\n * @docs-private\n */\nfunction throwPortalOutletAlreadyDisposedError() {\n    throw Error('This PortalOutlet has already been disposed');\n}\n/**\n * Throws an exception when attempting to attach an unknown portal type.\n * @docs-private\n */\nfunction throwUnknownPortalTypeError() {\n    throw Error('Attempting to attach an unknown Portal type. BasePortalOutlet accepts either ' +\n        'a ComponentPortal or a TemplatePortal.');\n}\n/**\n * Throws an exception when attempting to attach a portal to a null host.\n * @docs-private\n */\nfunction throwNullPortalOutletError() {\n    throw Error('Attempting to attach a portal to a null PortalOutlet');\n}\n/**\n * Throws an exception when attempting to detach a portal that is not attached.\n * @docs-private\n */\nfunction throwNoPortalAttachedError() {\n    throw Error('Attempting to detach a portal that is not attached to a host');\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A `Portal` is something that you want to render somewhere else.\n * It can be attach to / detached from a `PortalOutlet`.\n */\nclass Portal {\n    /** Attach this portal to a host. */\n    attach(host) {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            if (host == null) {\n                throwNullPortalOutletError();\n            }\n            if (host.hasAttached()) {\n                throwPortalAlreadyAttachedError();\n            }\n        }\n        this._attachedHost = host;\n        return host.attach(this);\n    }\n    /** Detach this portal from its host */\n    detach() {\n        let host = this._attachedHost;\n        if (host != null) {\n            this._attachedHost = null;\n            host.detach();\n        }\n        else if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            throwNoPortalAttachedError();\n        }\n    }\n    /** Whether this portal is attached to a host. */\n    get isAttached() {\n        return this._attachedHost != null;\n    }\n    /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     */\n    setAttachedHost(host) {\n        this._attachedHost = host;\n    }\n}\n/**\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\n */\nclass ComponentPortal extends Portal {\n    constructor(component, viewContainerRef, injector, componentFactoryResolver) {\n        super();\n        this.component = component;\n        this.viewContainerRef = viewContainerRef;\n        this.injector = injector;\n        this.componentFactoryResolver = componentFactoryResolver;\n    }\n}\n/**\n * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).\n */\nclass TemplatePortal extends Portal {\n    constructor(template, viewContainerRef, context) {\n        super();\n        this.templateRef = template;\n        this.viewContainerRef = viewContainerRef;\n        this.context = context;\n    }\n    get origin() {\n        return this.templateRef.elementRef;\n    }\n    /**\n     * Attach the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     */\n    attach(host, context = this.context) {\n        this.context = context;\n        return super.attach(host);\n    }\n    detach() {\n        this.context = undefined;\n        return super.detach();\n    }\n}\n/**\n * A `DomPortal` is a portal whose DOM element will be taken from its current position\n * in the DOM and moved into a portal outlet, when it is attached. On detach, the content\n * will be restored to its original position.\n */\nclass DomPortal extends Portal {\n    constructor(element) {\n        super();\n        this.element = element instanceof _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ElementRef */ \"m\"] ? element.nativeElement : element;\n    }\n}\n/**\n * Partial implementation of PortalOutlet that handles attaching\n * ComponentPortal and TemplatePortal.\n */\nclass BasePortalOutlet {\n    constructor() {\n        /** Whether this host has already been permanently disposed. */\n        this._isDisposed = false;\n        // @breaking-change 10.0.0 `attachDomPortal` to become a required abstract method.\n        this.attachDomPortal = null;\n    }\n    /** Whether this host has an attached portal. */\n    hasAttached() {\n        return !!this._attachedPortal;\n    }\n    /** Attaches a portal. */\n    attach(portal) {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            if (!portal) {\n                throwNullPortalError();\n            }\n            if (this.hasAttached()) {\n                throwPortalAlreadyAttachedError();\n            }\n            if (this._isDisposed) {\n                throwPortalOutletAlreadyDisposedError();\n            }\n        }\n        if (portal instanceof ComponentPortal) {\n            this._attachedPortal = portal;\n            return this.attachComponentPortal(portal);\n        }\n        else if (portal instanceof TemplatePortal) {\n            this._attachedPortal = portal;\n            return this.attachTemplatePortal(portal);\n            // @breaking-change 10.0.0 remove null check for `this.attachDomPortal`.\n        }\n        else if (this.attachDomPortal && portal instanceof DomPortal) {\n            this._attachedPortal = portal;\n            return this.attachDomPortal(portal);\n        }\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            throwUnknownPortalTypeError();\n        }\n    }\n    /** Detaches a previously attached portal. */\n    detach() {\n        if (this._attachedPortal) {\n            this._attachedPortal.setAttachedHost(null);\n            this._attachedPortal = null;\n        }\n        this._invokeDisposeFn();\n    }\n    /** Permanently dispose of this portal host. */\n    dispose() {\n        if (this.hasAttached()) {\n            this.detach();\n        }\n        this._invokeDisposeFn();\n        this._isDisposed = true;\n    }\n    /** @docs-private */\n    setDisposeFn(fn) {\n        this._disposeFn = fn;\n    }\n    _invokeDisposeFn() {\n        if (this._disposeFn) {\n            this._disposeFn();\n            this._disposeFn = null;\n        }\n    }\n}\n/**\n * @deprecated Use `BasePortalOutlet` instead.\n * @breaking-change 9.0.0\n */\nclass BasePortalHost extends BasePortalOutlet {\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular\n * application context.\n */\nclass DomPortalOutlet extends BasePortalOutlet {\n    constructor(\n    /** Element into which the content is projected. */\n    outletElement, _componentFactoryResolver, _appRef, _defaultInjector, \n    /**\n     * @deprecated `_document` Parameter to be made required.\n     * @breaking-change 10.0.0\n     */\n    _document) {\n        super();\n        this.outletElement = outletElement;\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._appRef = _appRef;\n        this._defaultInjector = _defaultInjector;\n        /**\n         * Attaches a DOM portal by transferring its content into the outlet.\n         * @param portal Portal to be attached.\n         * @deprecated To be turned into a method.\n         * @breaking-change 10.0.0\n         */\n        this.attachDomPortal = (portal) => {\n            // @breaking-change 10.0.0 Remove check and error once the\n            // `_document` constructor parameter is required.\n            if (!this._document && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw Error('Cannot attach DOM portal without _document constructor parameter');\n            }\n            const element = portal.element;\n            if (!element.parentNode && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw Error('DOM portal content must be attached to a parent node.');\n            }\n            // Anchor used to save the element's previous position so\n            // that we can restore it when the portal is detached.\n            const anchorNode = this._document.createComment('dom-portal');\n            element.parentNode.insertBefore(anchorNode, element);\n            this.outletElement.appendChild(element);\n            this._attachedPortal = portal;\n            super.setDisposeFn(() => {\n                // We can't use `replaceWith` here because IE doesn't support it.\n                if (anchorNode.parentNode) {\n                    anchorNode.parentNode.replaceChild(element, anchorNode);\n                }\n            });\n        };\n        this._document = _document;\n    }\n    /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @param portal Portal to be attached\n     * @returns Reference to the created component.\n     */\n    attachComponentPortal(portal) {\n        const resolver = portal.componentFactoryResolver || this._componentFactoryResolver;\n        const componentFactory = resolver.resolveComponentFactory(portal.component);\n        let componentRef;\n        // If the portal specifies a ViewContainerRef, we will use that as the attachment point\n        // for the component (in terms of Angular's component tree, not rendering).\n        // When the ViewContainerRef is missing, we use the factory to create the component directly\n        // and then manually attach the view to the application.\n        if (portal.viewContainerRef) {\n            componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.injector);\n            this.setDisposeFn(() => componentRef.destroy());\n        }\n        else {\n            componentRef = componentFactory.create(portal.injector || this._defaultInjector);\n            this._appRef.attachView(componentRef.hostView);\n            this.setDisposeFn(() => {\n                this._appRef.detachView(componentRef.hostView);\n                componentRef.destroy();\n            });\n        }\n        // At this point the component has been instantiated, so we move it to the location in the DOM\n        // where we want it to be rendered.\n        this.outletElement.appendChild(this._getComponentRootNode(componentRef));\n        this._attachedPortal = portal;\n        return componentRef;\n    }\n    /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @param portal Portal to be attached.\n     * @returns Reference to the created embedded view.\n     */\n    attachTemplatePortal(portal) {\n        let viewContainer = portal.viewContainerRef;\n        let viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context);\n        // The method `createEmbeddedView` will add the view as a child of the viewContainer.\n        // But for the DomPortalOutlet the view can be added everywhere in the DOM\n        // (e.g Overlay Container) To move the view to the specified host element. We just\n        // re-append the existing root nodes.\n        viewRef.rootNodes.forEach(rootNode => this.outletElement.appendChild(rootNode));\n        // Note that we want to detect changes after the nodes have been moved so that\n        // any directives inside the portal that are looking at the DOM inside a lifecycle\n        // hook won't be invoked too early.\n        viewRef.detectChanges();\n        this.setDisposeFn((() => {\n            let index = viewContainer.indexOf(viewRef);\n            if (index !== -1) {\n                viewContainer.remove(index);\n            }\n        }));\n        this._attachedPortal = portal;\n        // TODO(jelbourn): Return locals from view.\n        return viewRef;\n    }\n    /**\n     * Clears out a portal from the DOM.\n     */\n    dispose() {\n        super.dispose();\n        if (this.outletElement.parentNode != null) {\n            this.outletElement.parentNode.removeChild(this.outletElement);\n        }\n    }\n    /** Gets the root HTMLElement for an instantiated component. */\n    _getComponentRootNode(componentRef) {\n        return componentRef.hostView.rootNodes[0];\n    }\n}\n/**\n * @deprecated Use `DomPortalOutlet` instead.\n * @breaking-change 9.0.0\n */\nclass DomPortalHost extends DomPortalOutlet {\n}\nlet CdkPortal = /*@__PURE__*/ (() => {\n    class CdkPortal extends TemplatePortal {\n        constructor(templateRef, viewContainerRef) {\n            super(templateRef, viewContainerRef);\n        }\n    }\n    CdkPortal.ɵfac = function CdkPortal_Factory(t) { return new (t || CdkPortal)(_angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_0__[/* TemplateRef */ \"R\"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ViewContainerRef */ \"V\"])); };\n    CdkPortal.ɵdir = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdefineDirective */ \"Ob\"]({ type: CdkPortal, selectors: [[\"\", \"cdkPortal\", \"\"]], exportAs: [\"cdkPortal\"], features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵInheritDefinitionFeature */ \"Db\"]] });\n    return CdkPortal;\n})();\nlet TemplatePortalDirective = /*@__PURE__*/ (() => {\n    class TemplatePortalDirective extends CdkPortal {\n    }\n    TemplatePortalDirective.ɵfac = function TemplatePortalDirective_Factory(t) { return ɵTemplatePortalDirective_BaseFactory(t || TemplatePortalDirective); };\n    TemplatePortalDirective.ɵdir = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdefineDirective */ \"Ob\"]({ type: TemplatePortalDirective, selectors: [[\"\", \"cdk-portal\", \"\"], [\"\", \"portal\", \"\"]], exportAs: [\"cdkPortal\"], features: [/*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵProvidersFeature */ \"Fb\"]([{\n                    provide: CdkPortal,\n                    useExisting: TemplatePortalDirective\n                }]), _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵInheritDefinitionFeature */ \"Db\"]] });\n    return TemplatePortalDirective;\n})();\nconst ɵTemplatePortalDirective_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵgetInheritedFactory */ \"bc\"](TemplatePortalDirective);\nlet CdkPortalOutlet = /*@__PURE__*/ (() => {\n    class CdkPortalOutlet extends BasePortalOutlet {\n        constructor(_componentFactoryResolver, _viewContainerRef, \n        /**\n         * @deprecated `_document` parameter to be made required.\n         * @breaking-change 9.0.0\n         */\n        _document) {\n            super();\n            this._componentFactoryResolver = _componentFactoryResolver;\n            this._viewContainerRef = _viewContainerRef;\n            /** Whether the portal component is initialized. */\n            this._isInitialized = false;\n            /** Emits when a portal is attached to the outlet. */\n            this.attached = new _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* EventEmitter */ \"p\"]();\n            /**\n             * Attaches the given DomPortal to this PortalHost by moving all of the portal content into it.\n             * @param portal Portal to be attached.\n             * @deprecated To be turned into a method.\n             * @breaking-change 10.0.0\n             */\n            this.attachDomPortal = (portal) => {\n                // @breaking-change 9.0.0 Remove check and error once the\n                // `_document` constructor parameter is required.\n                if (!this._document && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                    throw Error('Cannot attach DOM portal without _document constructor parameter');\n                }\n                const element = portal.element;\n                if (!element.parentNode && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                    throw Error('DOM portal content must be attached to a parent node.');\n                }\n                // Anchor used to save the element's previous position so\n                // that we can restore it when the portal is detached.\n                const anchorNode = this._document.createComment('dom-portal');\n                portal.setAttachedHost(this);\n                element.parentNode.insertBefore(anchorNode, element);\n                this._getRootNode().appendChild(element);\n                this._attachedPortal = portal;\n                super.setDisposeFn(() => {\n                    if (anchorNode.parentNode) {\n                        anchorNode.parentNode.replaceChild(element, anchorNode);\n                    }\n                });\n            };\n            this._document = _document;\n        }\n        /** Portal associated with the Portal outlet. */\n        get portal() {\n            return this._attachedPortal;\n        }\n        set portal(portal) {\n            // Ignore the cases where the `portal` is set to a falsy value before the lifecycle hooks have\n            // run. This handles the cases where the user might do something like `<div cdkPortalOutlet>`\n            // and attach a portal programmatically in the parent component. When Angular does the first CD\n            // round, it will fire the setter with empty string, causing the user's content to be cleared.\n            if (this.hasAttached() && !portal && !this._isInitialized) {\n                return;\n            }\n            if (this.hasAttached()) {\n                super.detach();\n            }\n            if (portal) {\n                super.attach(portal);\n            }\n            this._attachedPortal = portal;\n        }\n        /** Component or view reference that is attached to the portal. */\n        get attachedRef() {\n            return this._attachedRef;\n        }\n        ngOnInit() {\n            this._isInitialized = true;\n        }\n        ngOnDestroy() {\n            super.dispose();\n            this._attachedPortal = null;\n            this._attachedRef = null;\n        }\n        /**\n         * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n         *\n         * @param portal Portal to be attached to the portal outlet.\n         * @returns Reference to the created component.\n         */\n        attachComponentPortal(portal) {\n            portal.setAttachedHost(this);\n            // If the portal specifies an origin, use that as the logical location of the component\n            // in the application tree. Otherwise use the location of this PortalOutlet.\n            const viewContainerRef = portal.viewContainerRef != null ?\n                portal.viewContainerRef :\n                this._viewContainerRef;\n            const resolver = portal.componentFactoryResolver || this._componentFactoryResolver;\n            const componentFactory = resolver.resolveComponentFactory(portal.component);\n            const ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.injector);\n            // If we're using a view container that's different from the injected one (e.g. when the portal\n            // specifies its own) we need to move the component into the outlet, otherwise it'll be rendered\n            // inside of the alternate view container.\n            if (viewContainerRef !== this._viewContainerRef) {\n                this._getRootNode().appendChild(ref.hostView.rootNodes[0]);\n            }\n            super.setDisposeFn(() => ref.destroy());\n            this._attachedPortal = portal;\n            this._attachedRef = ref;\n            this.attached.emit(ref);\n            return ref;\n        }\n        /**\n         * Attach the given TemplatePortal to this PortalHost as an embedded View.\n         * @param portal Portal to be attached.\n         * @returns Reference to the created embedded view.\n         */\n        attachTemplatePortal(portal) {\n            portal.setAttachedHost(this);\n            const viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context);\n            super.setDisposeFn(() => this._viewContainerRef.clear());\n            this._attachedPortal = portal;\n            this._attachedRef = viewRef;\n            this.attached.emit(viewRef);\n            return viewRef;\n        }\n        /** Gets the root node of the portal outlet. */\n        _getRootNode() {\n            const nativeElement = this._viewContainerRef.element.nativeElement;\n            // The directive could be set on a template which will result in a comment\n            // node being the root. Use the comment's parent node if that is the case.\n            return (nativeElement.nodeType === nativeElement.ELEMENT_NODE ?\n                nativeElement : nativeElement.parentNode);\n        }\n    }\n    CdkPortalOutlet.ɵfac = function CdkPortalOutlet_Factory(t) { return new (t || CdkPortalOutlet)(_angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ComponentFactoryResolver */ \"k\"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ViewContainerRef */ \"V\"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_common__WEBPACK_IMPORTED_MODULE_1__[/* DOCUMENT */ \"d\"])); };\n    CdkPortalOutlet.ɵdir = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdefineDirective */ \"Ob\"]({ type: CdkPortalOutlet, selectors: [[\"\", \"cdkPortalOutlet\", \"\"]], inputs: { portal: [\"cdkPortalOutlet\", \"portal\"] }, outputs: { attached: \"attached\" }, exportAs: [\"cdkPortalOutlet\"], features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵInheritDefinitionFeature */ \"Db\"]] });\n    return CdkPortalOutlet;\n})();\nlet PortalHostDirective = /*@__PURE__*/ (() => {\n    class PortalHostDirective extends CdkPortalOutlet {\n    }\n    PortalHostDirective.ɵfac = function PortalHostDirective_Factory(t) { return ɵPortalHostDirective_BaseFactory(t || PortalHostDirective); };\n    PortalHostDirective.ɵdir = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdefineDirective */ \"Ob\"]({ type: PortalHostDirective, selectors: [[\"\", \"cdkPortalHost\", \"\"], [\"\", \"portalHost\", \"\"]], inputs: { portal: [\"cdkPortalHost\", \"portal\"] }, exportAs: [\"cdkPortalHost\"], features: [/*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵProvidersFeature */ \"Fb\"]([{\n                    provide: CdkPortalOutlet,\n                    useExisting: PortalHostDirective\n                }]), _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵInheritDefinitionFeature */ \"Db\"]] });\n    return PortalHostDirective;\n})();\nconst ɵPortalHostDirective_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵgetInheritedFactory */ \"bc\"](PortalHostDirective);\nlet PortalModule = /*@__PURE__*/ (() => {\n    class PortalModule {\n    }\n    PortalModule.ɵmod = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdefineNgModule */ \"Rb\"]({ type: PortalModule });\n    PortalModule.ɵinj = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdefineInjector */ \"Qb\"]({ factory: function PortalModule_Factory(t) { return new (t || PortalModule)(); } });\n    return PortalModule;\n})();\n/*@__PURE__*/ (function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵsetNgModuleScope */ \"Lc\"](PortalModule, { declarations: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective], exports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective] }); })();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Custom injector to be used when providing custom\n * injection tokens to components inside a portal.\n * @docs-private\n * @deprecated Use `Injector.create` instead.\n * @breaking-change 11.0.0\n */\nclass PortalInjector {\n    constructor(_parentInjector, _customTokens) {\n        this._parentInjector = _parentInjector;\n        this._customTokens = _customTokens;\n    }\n    get(token, notFoundValue) {\n        const value = this._customTokens.get(token);\n        if (typeof value !== 'undefined') {\n            return value;\n        }\n        return this._parentInjector.get(token, notFoundValue);\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=portal.js.map\n\n\n/***/ }),\n\n/***/ \"0EQZ\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return ArrayDataSource; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return DataSource; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return SelectionModel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return UniqueSelectionDispatcher; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return _DisposeViewRepeaterStrategy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return _RecycleViewRepeaterStrategy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return _VIEW_REPEATER_STRATEGY; });\n/* unused harmony export getMultipleValuesInSingleSelectionError */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return isDataSource; });\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"7+OI\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"LRne\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"XNiG\");\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"fXoL\");\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nclass DataSource {\n}\n/** Checks whether an object is a data source. */\nfunction isDataSource(value) {\n    // Check if the value is a DataSource by observing if it has a connect function. Cannot\n    // be checked as an `instanceof DataSource` since people could create their own sources\n    // that match the interface, but don't extend DataSource.\n    return value && typeof value.connect === 'function';\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** DataSource wrapper for a native array. */\nclass ArrayDataSource extends DataSource {\n    constructor(_data) {\n        super();\n        this._data = _data;\n    }\n    connect() {\n        return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__[/* isObservable */ \"a\"])(this._data) ? this._data : Object(rxjs__WEBPACK_IMPORTED_MODULE_1__[/* of */ \"a\"])(this._data);\n    }\n    disconnect() { }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A repeater that destroys views when they are removed from a\n * {@link ViewContainerRef}. When new items are inserted into the container,\n * the repeater will always construct a new embedded view for each item.\n *\n * @template T The type for the embedded view's $implicit property.\n * @template R The type for the item in each IterableDiffer change record.\n * @template C The type for the context passed to each embedded view.\n */\nclass _DisposeViewRepeaterStrategy {\n    applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {\n        changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {\n            let view;\n            let operation;\n            if (record.previousIndex == null) {\n                const insertContext = itemContextFactory(record, adjustedPreviousIndex, currentIndex);\n                view = viewContainerRef.createEmbeddedView(insertContext.templateRef, insertContext.context, insertContext.index);\n                operation = 1 /* INSERTED */;\n            }\n            else if (currentIndex == null) {\n                viewContainerRef.remove(adjustedPreviousIndex);\n                operation = 3 /* REMOVED */;\n            }\n            else {\n                view = viewContainerRef.get(adjustedPreviousIndex);\n                viewContainerRef.move(view, currentIndex);\n                operation = 2 /* MOVED */;\n            }\n            if (itemViewChanged) {\n                itemViewChanged({\n                    context: view === null || view === void 0 ? void 0 : view.context,\n                    operation,\n                    record,\n                });\n            }\n        });\n    }\n    detach() {\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A repeater that caches views when they are removed from a\n * {@link ViewContainerRef}. When new items are inserted into the container,\n * the repeater will reuse one of the cached views instead of creating a new\n * embedded view. Recycling cached views reduces the quantity of expensive DOM\n * inserts.\n *\n * @template T The type for the embedded view's $implicit property.\n * @template R The type for the item in each IterableDiffer change record.\n * @template C The type for the context passed to each embedded view.\n */\nclass _RecycleViewRepeaterStrategy {\n    constructor() {\n        /**\n         * The size of the cache used to store unused views.\n         * Setting the cache size to `0` will disable caching. Defaults to 20 views.\n         */\n        this.viewCacheSize = 20;\n        /**\n         * View cache that stores embedded view instances that have been previously stamped out,\n         * but don't are not currently rendered. The view repeater will reuse these views rather than\n         * creating brand new ones.\n         *\n         * TODO(michaeljamesparsons) Investigate whether using a linked list would improve performance.\n         */\n        this._viewCache = [];\n    }\n    /** Apply changes to the DOM. */\n    applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {\n        // Rearrange the views to put them in the right location.\n        changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {\n            let view;\n            let operation;\n            if (record.previousIndex == null) { // Item added.\n                const viewArgsFactory = () => itemContextFactory(record, adjustedPreviousIndex, currentIndex);\n                view = this._insertView(viewArgsFactory, currentIndex, viewContainerRef, itemValueResolver(record));\n                operation = view ? 1 /* INSERTED */ : 0 /* REPLACED */;\n            }\n            else if (currentIndex == null) { // Item removed.\n                this._detachAndCacheView(adjustedPreviousIndex, viewContainerRef);\n                operation = 3 /* REMOVED */;\n            }\n            else { // Item moved.\n                view = this._moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, itemValueResolver(record));\n                operation = 2 /* MOVED */;\n            }\n            if (itemViewChanged) {\n                itemViewChanged({\n                    context: view === null || view === void 0 ? void 0 : view.context,\n                    operation,\n                    record,\n                });\n            }\n        });\n    }\n    detach() {\n        for (const view of this._viewCache) {\n            view.destroy();\n        }\n        this._viewCache = [];\n    }\n    /**\n     * Inserts a view for a new item, either from the cache or by creating a new\n     * one. Returns `undefined` if the item was inserted into a cached view.\n     */\n    _insertView(viewArgsFactory, currentIndex, viewContainerRef, value) {\n        const cachedView = this._insertViewFromCache(currentIndex, viewContainerRef);\n        if (cachedView) {\n            cachedView.context.$implicit = value;\n            return undefined;\n        }\n        const viewArgs = viewArgsFactory();\n        return viewContainerRef.createEmbeddedView(viewArgs.templateRef, viewArgs.context, viewArgs.index);\n    }\n    /** Detaches the view at the given index and inserts into the view cache. */\n    _detachAndCacheView(index, viewContainerRef) {\n        const detachedView = viewContainerRef.detach(index);\n        this._maybeCacheView(detachedView, viewContainerRef);\n    }\n    /** Moves view at the previous index to the current index. */\n    _moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, value) {\n        const view = viewContainerRef.get(adjustedPreviousIndex);\n        viewContainerRef.move(view, currentIndex);\n        view.context.$implicit = value;\n        return view;\n    }\n    /**\n     * Cache the given detached view. If the cache is full, the view will be\n     * destroyed.\n     */\n    _maybeCacheView(view, viewContainerRef) {\n        if (this._viewCache.length < this.viewCacheSize) {\n            this._viewCache.push(view);\n        }\n        else {\n            const index = viewContainerRef.indexOf(view);\n            // The host component could remove views from the container outside of\n            // the view repeater. It's unlikely this will occur, but just in case,\n            // destroy the view on its own, otherwise destroy it through the\n            // container to ensure that all the references are removed.\n            if (index === -1) {\n                view.destroy();\n            }\n            else {\n                viewContainerRef.remove(index);\n            }\n        }\n    }\n    /** Inserts a recycled view from the cache at the given index. */\n    _insertViewFromCache(index, viewContainerRef) {\n        const cachedView = this._viewCache.pop();\n        if (cachedView) {\n            viewContainerRef.insert(cachedView, index);\n        }\n        return cachedView || null;\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Class to be used to power selecting one or more options from a list.\n */\nclass SelectionModel {\n    constructor(_multiple = false, initiallySelectedValues, _emitChanges = true) {\n        this._multiple = _multiple;\n        this._emitChanges = _emitChanges;\n        /** Currently-selected values. */\n        this._selection = new Set();\n        /** Keeps track of the deselected options that haven't been emitted by the change event. */\n        this._deselectedToEmit = [];\n        /** Keeps track of the selected options that haven't been emitted by the change event. */\n        this._selectedToEmit = [];\n        /** Event emitted when the value has changed. */\n        this.changed = new rxjs__WEBPACK_IMPORTED_MODULE_2__[/* Subject */ \"a\"]();\n        if (initiallySelectedValues && initiallySelectedValues.length) {\n            if (_multiple) {\n                initiallySelectedValues.forEach(value => this._markSelected(value));\n            }\n            else {\n                this._markSelected(initiallySelectedValues[0]);\n            }\n            // Clear the array in order to avoid firing the change event for preselected values.\n            this._selectedToEmit.length = 0;\n        }\n    }\n    /** Selected values. */\n    get selected() {\n        if (!this._selected) {\n            this._selected = Array.from(this._selection.values());\n        }\n        return this._selected;\n    }\n    /**\n     * Selects a value or an array of values.\n     */\n    select(...values) {\n        this._verifyValueAssignment(values);\n        values.forEach(value => this._markSelected(value));\n        this._emitChangeEvent();\n    }\n    /**\n     * Deselects a value or an array of values.\n     */\n    deselect(...values) {\n        this._verifyValueAssignment(values);\n        values.forEach(value => this._unmarkSelected(value));\n        this._emitChangeEvent();\n    }\n    /**\n     * Toggles a value between selected and deselected.\n     */\n    toggle(value) {\n        this.isSelected(value) ? this.deselect(value) : this.select(value);\n    }\n    /**\n     * Clears all of the selected values.\n     */\n    clear() {\n        this._unmarkAll();\n        this._emitChangeEvent();\n    }\n    /**\n     * Determines whether a value is selected.\n     */\n    isSelected(value) {\n        return this._selection.has(value);\n    }\n    /**\n     * Determines whether the model does not have a value.\n     */\n    isEmpty() {\n        return this._selection.size === 0;\n    }\n    /**\n     * Determines whether the model has a value.\n     */\n    hasValue() {\n        return !this.isEmpty();\n    }\n    /**\n     * Sorts the selected values based on a predicate function.\n     */\n    sort(predicate) {\n        if (this._multiple && this.selected) {\n            this._selected.sort(predicate);\n        }\n    }\n    /**\n     * Gets whether multiple values can be selected.\n     */\n    isMultipleSelection() {\n        return this._multiple;\n    }\n    /** Emits a change event and clears the records of selected and deselected values. */\n    _emitChangeEvent() {\n        // Clear the selected values so they can be re-cached.\n        this._selected = null;\n        if (this._selectedToEmit.length || this._deselectedToEmit.length) {\n            this.changed.next({\n                source: this,\n                added: this._selectedToEmit,\n                removed: this._deselectedToEmit\n            });\n            this._deselectedToEmit = [];\n            this._selectedToEmit = [];\n        }\n    }\n    /** Selects a value. */\n    _markSelected(value) {\n        if (!this.isSelected(value)) {\n            if (!this._multiple) {\n                this._unmarkAll();\n            }\n            this._selection.add(value);\n            if (this._emitChanges) {\n                this._selectedToEmit.push(value);\n            }\n        }\n    }\n    /** Deselects a value. */\n    _unmarkSelected(value) {\n        if (this.isSelected(value)) {\n            this._selection.delete(value);\n            if (this._emitChanges) {\n                this._deselectedToEmit.push(value);\n            }\n        }\n    }\n    /** Clears out the selected values. */\n    _unmarkAll() {\n        if (!this.isEmpty()) {\n            this._selection.forEach(value => this._unmarkSelected(value));\n        }\n    }\n    /**\n     * Verifies the value assignment and throws an error if the specified value array is\n     * including multiple values while the selection model is not supporting multiple values.\n     */\n    _verifyValueAssignment(values) {\n        if (values.length > 1 && !this._multiple && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw getMultipleValuesInSingleSelectionError();\n        }\n    }\n}\n/**\n * Returns an error that reports that multiple values are passed into a selection model\n * with a single value.\n * @docs-private\n */\nfunction getMultipleValuesInSingleSelectionError() {\n    return Error('Cannot pass multiple values into SelectionModel with single-value mode.');\n}\nlet UniqueSelectionDispatcher = /*@__PURE__*/ (() => {\n    class UniqueSelectionDispatcher {\n        constructor() {\n            this._listeners = [];\n        }\n        /**\n         * Notify other items that selection for the given name has been set.\n         * @param id ID of the item.\n         * @param name Name of the item.\n         */\n        notify(id, name) {\n            for (let listener of this._listeners) {\n                listener(id, name);\n            }\n        }\n        /**\n         * Listen for future changes to item selection.\n         * @return Function used to deregister listener\n         */\n        listen(listener) {\n            this._listeners.push(listener);\n            return () => {\n                this._listeners = this._listeners.filter((registered) => {\n                    return listener !== registered;\n                });\n            };\n        }\n        ngOnDestroy() {\n            this._listeners = [];\n        }\n    }\n    UniqueSelectionDispatcher.ɵfac = function UniqueSelectionDispatcher_Factory(t) { return new (t || UniqueSelectionDispatcher)(); };\n    UniqueSelectionDispatcher.ɵprov = /*@__PURE__*/ Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdefineInjectable */ \"Pb\"])({ factory: function UniqueSelectionDispatcher_Factory() { return new UniqueSelectionDispatcher(); }, token: UniqueSelectionDispatcher, providedIn: \"root\" });\n    return UniqueSelectionDispatcher;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injection token for {@link _ViewRepeater}. This token is for use by Angular Material only.\n * @docs-private\n */\nconst _VIEW_REPEATER_STRATEGY = /*@__PURE__*/ new _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* InjectionToken */ \"u\"]('_ViewRepeater');\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=collections.js.map\n\n\n/***/ }),\n\n/***/ \"7Hc7\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ asapScheduler; });\n\n// UNUSED EXPORTS: asap\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/util/Immediate.js\nlet nextHandle = 1;\nconst RESOLVED = /*@__PURE__*/ (() => Promise.resolve())();\nconst activeHandles = {};\nfunction findAndClearHandle(handle) {\n    if (handle in activeHandles) {\n        delete activeHandles[handle];\n        return true;\n    }\n    return false;\n}\nconst Immediate = {\n    setImmediate(cb) {\n        const handle = nextHandle++;\n        activeHandles[handle] = true;\n        RESOLVED.then(() => findAndClearHandle(handle) && cb());\n        return handle;\n    },\n    clearImmediate(handle) {\n        findAndClearHandle(handle);\n    },\n};\nconst TestTools = {\n    pending() {\n        return Object.keys(activeHandles).length;\n    }\n};\n//# sourceMappingURL=Immediate.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/AsyncAction.js + 1 modules\nvar AsyncAction = __webpack_require__(\"3N8a\");\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/AsapAction.js\n\n\nclass AsapAction_AsapAction extends AsyncAction[\"a\" /* AsyncAction */] {\n    constructor(scheduler, work) {\n        super(scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n    }\n    requestAsyncId(scheduler, id, delay = 0) {\n        if (delay !== null && delay > 0) {\n            return super.requestAsyncId(scheduler, id, delay);\n        }\n        scheduler.actions.push(this);\n        return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));\n    }\n    recycleAsyncId(scheduler, id, delay = 0) {\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n            return super.recycleAsyncId(scheduler, id, delay);\n        }\n        if (scheduler.actions.length === 0) {\n            Immediate.clearImmediate(id);\n            scheduler.scheduled = undefined;\n        }\n        return undefined;\n    }\n}\n//# sourceMappingURL=AsapAction.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/AsyncScheduler.js + 1 modules\nvar AsyncScheduler = __webpack_require__(\"IjjT\");\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/AsapScheduler.js\n\nclass AsapScheduler_AsapScheduler extends AsyncScheduler[\"a\" /* AsyncScheduler */] {\n    flush(action) {\n        this.active = true;\n        this.scheduled = undefined;\n        const { actions } = this;\n        let error;\n        let index = -1;\n        let count = actions.length;\n        action = action || actions.shift();\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (++index < count && (action = actions.shift()));\n        this.active = false;\n        if (error) {\n            while (++index < count && (action = actions.shift())) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    }\n}\n//# sourceMappingURL=AsapScheduler.js.map\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/asap.js\n\n\nconst asapScheduler = /*@__PURE__*/ new AsapScheduler_AsapScheduler(AsapAction_AsapAction);\nconst asap = asapScheduler;\n//# sourceMappingURL=asap.js.map\n\n\n/***/ }),\n\n/***/ \"vxfF\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ scrolling_CdkScrollable; });\n__webpack_require__.d(__webpack_exports__, \"b\", function() { return /* binding */ scrolling_CdkScrollableModule; });\n__webpack_require__.d(__webpack_exports__, \"c\", function() { return /* binding */ scrolling_ScrollDispatcher; });\n__webpack_require__.d(__webpack_exports__, \"d\", function() { return /* binding */ scrolling_ScrollingModule; });\n__webpack_require__.d(__webpack_exports__, \"e\", function() { return /* binding */ scrolling_ViewportRuler; });\n\n// UNUSED EXPORTS: CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport, DEFAULT_RESIZE_TIME, DEFAULT_SCROLL_TIME, FixedSizeVirtualScrollStrategy, VIRTUAL_SCROLL_STRATEGY, _fixedSizeVirtualScrollStrategyFactory\n\n// EXTERNAL MODULE: ./node_modules/@angular/cdk/fesm2015/coercion.js\nvar coercion = __webpack_require__(\"8LU1\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js\nvar core = __webpack_require__(\"fXoL\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subject.js\nvar Subject = __webpack_require__(\"XNiG\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/of.js\nvar of = __webpack_require__(\"LRne\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Observable.js + 3 modules\nvar Observable = __webpack_require__(\"HDdC\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/fromEvent.js\nvar fromEvent = __webpack_require__(\"xgIS\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/animationFrame.js + 2 modules\nvar animationFrame = __webpack_require__(\"eNwd\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/asap.js + 3 modules\nvar asap = __webpack_require__(\"7Hc7\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subscription.js + 1 modules\nvar Subscription = __webpack_require__(\"quSY\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/isObservable.js\nvar isObservable = __webpack_require__(\"7+OI\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/distinctUntilChanged.js\nvar distinctUntilChanged = __webpack_require__(\"/uUt\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/auditTime.js + 1 modules\nvar auditTime = __webpack_require__(\"3UWI\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/filter.js\nvar filter = __webpack_require__(\"pLZG\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/takeUntil.js\nvar takeUntil = __webpack_require__(\"1G5W\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/startWith.js\nvar startWith = __webpack_require__(\"JX91\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subscriber.js\nvar Subscriber = __webpack_require__(\"7o/Q\");\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/pairwise.js\n\nfunction pairwise() {\n    return (source) => source.lift(new PairwiseOperator());\n}\nclass PairwiseOperator {\n    call(subscriber, source) {\n        return source.subscribe(new pairwise_PairwiseSubscriber(subscriber));\n    }\n}\nclass pairwise_PairwiseSubscriber extends Subscriber[\"a\" /* Subscriber */] {\n    constructor(destination) {\n        super(destination);\n        this.hasPrev = false;\n    }\n    _next(value) {\n        let pair;\n        if (this.hasPrev) {\n            pair = [this.prev, value];\n        }\n        else {\n            this.hasPrev = true;\n        }\n        this.prev = value;\n        if (pair) {\n            this.destination.next(pair);\n        }\n    }\n}\n//# sourceMappingURL=pairwise.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/switchMap.js\nvar switchMap = __webpack_require__(\"eIep\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/shareReplay.js + 5 modules\nvar shareReplay = __webpack_require__(\"UXun\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/platform.js\nvar platform = __webpack_require__(\"nLfN\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/common/__ivy_ngcc__/fesm2015/common.js\nvar common = __webpack_require__(\"ofXK\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/bidi.js\nvar bidi = __webpack_require__(\"cH1L\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/collections.js\nvar collections = __webpack_require__(\"0EQZ\");\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/scrolling.js\n\n\n\n\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** The injection token used to specify the virtual scrolling strategy. */\n\n\n\n\nconst _c0 = [\"contentWrapper\"];\nconst _c1 = [\"*\"];\nconst VIRTUAL_SCROLL_STRATEGY = /*@__PURE__*/ new core[\"u\" /* InjectionToken */]('VIRTUAL_SCROLL_STRATEGY');\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Virtual scrolling strategy for lists with items of known fixed size. */\nclass scrolling_FixedSizeVirtualScrollStrategy {\n    /**\n     * @param itemSize The size of the items in the virtually scrolling list.\n     * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more\n     * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.\n     */\n    constructor(itemSize, minBufferPx, maxBufferPx) {\n        this._scrolledIndexChange = new Subject[\"a\" /* Subject */]();\n        /** @docs-private Implemented as part of VirtualScrollStrategy. */\n        this.scrolledIndexChange = this._scrolledIndexChange.pipe(Object(distinctUntilChanged[\"a\" /* distinctUntilChanged */])());\n        /** The attached viewport. */\n        this._viewport = null;\n        this._itemSize = itemSize;\n        this._minBufferPx = minBufferPx;\n        this._maxBufferPx = maxBufferPx;\n    }\n    /**\n     * Attaches this scroll strategy to a viewport.\n     * @param viewport The viewport to attach this strategy to.\n     */\n    attach(viewport) {\n        this._viewport = viewport;\n        this._updateTotalContentSize();\n        this._updateRenderedRange();\n    }\n    /** Detaches this scroll strategy from the currently attached viewport. */\n    detach() {\n        this._scrolledIndexChange.complete();\n        this._viewport = null;\n    }\n    /**\n     * Update the item size and buffer size.\n     * @param itemSize The size of the items in the virtually scrolling list.\n     * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more\n     * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.\n     */\n    updateItemAndBufferSize(itemSize, minBufferPx, maxBufferPx) {\n        if (maxBufferPx < minBufferPx && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw Error('CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx');\n        }\n        this._itemSize = itemSize;\n        this._minBufferPx = minBufferPx;\n        this._maxBufferPx = maxBufferPx;\n        this._updateTotalContentSize();\n        this._updateRenderedRange();\n    }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onContentScrolled() {\n        this._updateRenderedRange();\n    }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onDataLengthChanged() {\n        this._updateTotalContentSize();\n        this._updateRenderedRange();\n    }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onContentRendered() { }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onRenderedOffsetChanged() { }\n    /**\n     * Scroll to the offset for the given index.\n     * @param index The index of the element to scroll to.\n     * @param behavior The ScrollBehavior to use when scrolling.\n     */\n    scrollToIndex(index, behavior) {\n        if (this._viewport) {\n            this._viewport.scrollToOffset(index * this._itemSize, behavior);\n        }\n    }\n    /** Update the viewport's total content size. */\n    _updateTotalContentSize() {\n        if (!this._viewport) {\n            return;\n        }\n        this._viewport.setTotalContentSize(this._viewport.getDataLength() * this._itemSize);\n    }\n    /** Update the viewport's rendered range. */\n    _updateRenderedRange() {\n        if (!this._viewport) {\n            return;\n        }\n        const renderedRange = this._viewport.getRenderedRange();\n        const newRange = { start: renderedRange.start, end: renderedRange.end };\n        const viewportSize = this._viewport.getViewportSize();\n        const dataLength = this._viewport.getDataLength();\n        let scrollOffset = this._viewport.measureScrollOffset();\n        // Prevent NaN as result when dividing by zero.\n        let firstVisibleIndex = (this._itemSize > 0) ? scrollOffset / this._itemSize : 0;\n        // If user scrolls to the bottom of the list and data changes to a smaller list\n        if (newRange.end > dataLength) {\n            // We have to recalculate the first visible index based on new data length and viewport size.\n            const maxVisibleItems = Math.ceil(viewportSize / this._itemSize);\n            const newVisibleIndex = Math.max(0, Math.min(firstVisibleIndex, dataLength - maxVisibleItems));\n            // If first visible index changed we must update scroll offset to handle start/end buffers\n            // Current range must also be adjusted to cover the new position (bottom of new list).\n            if (firstVisibleIndex != newVisibleIndex) {\n                firstVisibleIndex = newVisibleIndex;\n                scrollOffset = newVisibleIndex * this._itemSize;\n                newRange.start = Math.floor(firstVisibleIndex);\n            }\n            newRange.end = Math.max(0, Math.min(dataLength, newRange.start + maxVisibleItems));\n        }\n        const startBuffer = scrollOffset - newRange.start * this._itemSize;\n        if (startBuffer < this._minBufferPx && newRange.start != 0) {\n            const expandStart = Math.ceil((this._maxBufferPx - startBuffer) / this._itemSize);\n            newRange.start = Math.max(0, newRange.start - expandStart);\n            newRange.end = Math.min(dataLength, Math.ceil(firstVisibleIndex + (viewportSize + this._minBufferPx) / this._itemSize));\n        }\n        else {\n            const endBuffer = newRange.end * this._itemSize - (scrollOffset + viewportSize);\n            if (endBuffer < this._minBufferPx && newRange.end != dataLength) {\n                const expandEnd = Math.ceil((this._maxBufferPx - endBuffer) / this._itemSize);\n                if (expandEnd > 0) {\n                    newRange.end = Math.min(dataLength, newRange.end + expandEnd);\n                    newRange.start = Math.max(0, Math.floor(firstVisibleIndex - this._minBufferPx / this._itemSize));\n                }\n            }\n        }\n        this._viewport.setRenderedRange(newRange);\n        this._viewport.setRenderedContentOffset(this._itemSize * newRange.start);\n        this._scrolledIndexChange.next(Math.floor(firstVisibleIndex));\n    }\n}\n/**\n * Provider factory for `FixedSizeVirtualScrollStrategy` that simply extracts the already created\n * `FixedSizeVirtualScrollStrategy` from the given directive.\n * @param fixedSizeDir The instance of `CdkFixedSizeVirtualScroll` to extract the\n *     `FixedSizeVirtualScrollStrategy` from.\n */\nfunction _fixedSizeVirtualScrollStrategyFactory(fixedSizeDir) {\n    return fixedSizeDir._scrollStrategy;\n}\nlet scrolling_CdkFixedSizeVirtualScroll = /*@__PURE__*/ (() => {\n    class CdkFixedSizeVirtualScroll {\n        constructor() {\n            this._itemSize = 20;\n            this._minBufferPx = 100;\n            this._maxBufferPx = 200;\n            /** The scroll strategy used by this directive. */\n            this._scrollStrategy = new scrolling_FixedSizeVirtualScrollStrategy(this.itemSize, this.minBufferPx, this.maxBufferPx);\n        }\n        /** The size of the items in the list (in pixels). */\n        get itemSize() { return this._itemSize; }\n        set itemSize(value) { this._itemSize = Object(coercion[\"f\" /* coerceNumberProperty */])(value); }\n        /**\n         * The minimum amount of buffer rendered beyond the viewport (in pixels).\n         * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.\n         */\n        get minBufferPx() { return this._minBufferPx; }\n        set minBufferPx(value) { this._minBufferPx = Object(coercion[\"f\" /* coerceNumberProperty */])(value); }\n        /**\n         * The number of pixels worth of buffer to render for when rendering new items. Defaults to 200px.\n         */\n        get maxBufferPx() { return this._maxBufferPx; }\n        set maxBufferPx(value) { this._maxBufferPx = Object(coercion[\"f\" /* coerceNumberProperty */])(value); }\n        ngOnChanges() {\n            this._scrollStrategy.updateItemAndBufferSize(this.itemSize, this.minBufferPx, this.maxBufferPx);\n        }\n    }\n    CdkFixedSizeVirtualScroll.ɵfac = function CdkFixedSizeVirtualScroll_Factory(t) { return new (t || CdkFixedSizeVirtualScroll)(); };\n    CdkFixedSizeVirtualScroll.ɵdir = /*@__PURE__*/ core[\"Ob\" /* ɵɵdefineDirective */]({ type: CdkFixedSizeVirtualScroll, selectors: [[\"cdk-virtual-scroll-viewport\", \"itemSize\", \"\"]], inputs: { itemSize: \"itemSize\", minBufferPx: \"minBufferPx\", maxBufferPx: \"maxBufferPx\" }, features: [/*@__PURE__*/ core[\"Fb\" /* ɵɵProvidersFeature */]([{\n                    provide: VIRTUAL_SCROLL_STRATEGY,\n                    useFactory: _fixedSizeVirtualScrollStrategyFactory,\n                    deps: [/*@__PURE__*/ Object(core[\"Z\" /* forwardRef */])(() => CdkFixedSizeVirtualScroll)]\n                }]), core[\"Eb\" /* ɵɵNgOnChangesFeature */]] });\n    return CdkFixedSizeVirtualScroll;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Time in ms to throttle the scrolling events by default. */\nconst DEFAULT_SCROLL_TIME = 20;\nlet scrolling_ScrollDispatcher = /*@__PURE__*/ (() => {\n    class ScrollDispatcher {\n        constructor(_ngZone, _platform, document) {\n            this._ngZone = _ngZone;\n            this._platform = _platform;\n            /** Subject for notifying that a registered scrollable reference element has been scrolled. */\n            this._scrolled = new Subject[\"a\" /* Subject */]();\n            /** Keeps track of the global `scroll` and `resize` subscriptions. */\n            this._globalSubscription = null;\n            /** Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards. */\n            this._scrolledCount = 0;\n            /**\n             * Map of all the scrollable references that are registered with the service and their\n             * scroll event subscriptions.\n             */\n            this.scrollContainers = new Map();\n            this._document = document;\n        }\n        /**\n         * Registers a scrollable instance with the service and listens for its scrolled events. When the\n         * scrollable is scrolled, the service emits the event to its scrolled observable.\n         * @param scrollable Scrollable instance to be registered.\n         */\n        register(scrollable) {\n            if (!this.scrollContainers.has(scrollable)) {\n                this.scrollContainers.set(scrollable, scrollable.elementScrolled()\n                    .subscribe(() => this._scrolled.next(scrollable)));\n            }\n        }\n        /**\n         * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n         * @param scrollable Scrollable instance to be deregistered.\n         */\n        deregister(scrollable) {\n            const scrollableReference = this.scrollContainers.get(scrollable);\n            if (scrollableReference) {\n                scrollableReference.unsubscribe();\n                this.scrollContainers.delete(scrollable);\n            }\n        }\n        /**\n         * Returns an observable that emits an event whenever any of the registered Scrollable\n         * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n         * to override the default \"throttle\" time.\n         *\n         * **Note:** in order to avoid hitting change detection for every scroll event,\n         * all of the events emitted from this stream will be run outside the Angular zone.\n         * If you need to update any data bindings as a result of a scroll event, you have\n         * to run the callback using `NgZone.run`.\n         */\n        scrolled(auditTimeInMs = DEFAULT_SCROLL_TIME) {\n            if (!this._platform.isBrowser) {\n                return Object(of[\"a\" /* of */])();\n            }\n            return new Observable[\"a\" /* Observable */]((observer) => {\n                if (!this._globalSubscription) {\n                    this._addGlobalListener();\n                }\n                // In the case of a 0ms delay, use an observable without auditTime\n                // since it does add a perceptible delay in processing overhead.\n                const subscription = auditTimeInMs > 0 ?\n                    this._scrolled.pipe(Object(auditTime[\"a\" /* auditTime */])(auditTimeInMs)).subscribe(observer) :\n                    this._scrolled.subscribe(observer);\n                this._scrolledCount++;\n                return () => {\n                    subscription.unsubscribe();\n                    this._scrolledCount--;\n                    if (!this._scrolledCount) {\n                        this._removeGlobalListener();\n                    }\n                };\n            });\n        }\n        ngOnDestroy() {\n            this._removeGlobalListener();\n            this.scrollContainers.forEach((_, container) => this.deregister(container));\n            this._scrolled.complete();\n        }\n        /**\n         * Returns an observable that emits whenever any of the\n         * scrollable ancestors of an element are scrolled.\n         * @param elementOrElementRef Element whose ancestors to listen for.\n         * @param auditTimeInMs Time to throttle the scroll events.\n         */\n        ancestorScrolled(elementOrElementRef, auditTimeInMs) {\n            const ancestors = this.getAncestorScrollContainers(elementOrElementRef);\n            return this.scrolled(auditTimeInMs).pipe(Object(filter[\"a\" /* filter */])(target => {\n                return !target || ancestors.indexOf(target) > -1;\n            }));\n        }\n        /** Returns all registered Scrollables that contain the provided element. */\n        getAncestorScrollContainers(elementOrElementRef) {\n            const scrollingContainers = [];\n            this.scrollContainers.forEach((_subscription, scrollable) => {\n                if (this._scrollableContainsElement(scrollable, elementOrElementRef)) {\n                    scrollingContainers.push(scrollable);\n                }\n            });\n            return scrollingContainers;\n        }\n        /** Use defaultView of injected document if available or fallback to global window reference */\n        _getWindow() {\n            return this._document.defaultView || window;\n        }\n        /** Returns true if the element is contained within the provided Scrollable. */\n        _scrollableContainsElement(scrollable, elementOrElementRef) {\n            let element = Object(coercion[\"e\" /* coerceElement */])(elementOrElementRef);\n            let scrollableElement = scrollable.getElementRef().nativeElement;\n            // Traverse through the element parents until we reach null, checking if any of the elements\n            // are the scrollable's element.\n            do {\n                if (element == scrollableElement) {\n                    return true;\n                }\n            } while (element = element.parentElement);\n            return false;\n        }\n        /** Sets up the global scroll listeners. */\n        _addGlobalListener() {\n            this._globalSubscription = this._ngZone.runOutsideAngular(() => {\n                const window = this._getWindow();\n                return Object(fromEvent[\"a\" /* fromEvent */])(window.document, 'scroll').subscribe(() => this._scrolled.next());\n            });\n        }\n        /** Cleans up the global scroll listener. */\n        _removeGlobalListener() {\n            if (this._globalSubscription) {\n                this._globalSubscription.unsubscribe();\n                this._globalSubscription = null;\n            }\n        }\n    }\n    ScrollDispatcher.ɵfac = function ScrollDispatcher_Factory(t) { return new (t || ScrollDispatcher)(core[\"gc\" /* ɵɵinject */](core[\"F\" /* NgZone */]), core[\"gc\" /* ɵɵinject */](platform[\"a\" /* Platform */]), core[\"gc\" /* ɵɵinject */](common[\"d\" /* DOCUMENT */], 8)); };\n    ScrollDispatcher.ɵprov = /*@__PURE__*/ Object(core[\"Pb\" /* ɵɵdefineInjectable */])({ factory: function ScrollDispatcher_Factory() { return new ScrollDispatcher(Object(core[\"gc\" /* ɵɵinject */])(core[\"F\" /* NgZone */]), Object(core[\"gc\" /* ɵɵinject */])(platform[\"a\" /* Platform */]), Object(core[\"gc\" /* ɵɵinject */])(common[\"d\" /* DOCUMENT */], 8)); }, token: ScrollDispatcher, providedIn: \"root\" });\n    return ScrollDispatcher;\n})();\nlet scrolling_CdkScrollable = /*@__PURE__*/ (() => {\n    class CdkScrollable {\n        constructor(elementRef, scrollDispatcher, ngZone, dir) {\n            this.elementRef = elementRef;\n            this.scrollDispatcher = scrollDispatcher;\n            this.ngZone = ngZone;\n            this.dir = dir;\n            this._destroyed = new Subject[\"a\" /* Subject */]();\n            this._elementScrolled = new Observable[\"a\" /* Observable */]((observer) => this.ngZone.runOutsideAngular(() => Object(fromEvent[\"a\" /* fromEvent */])(this.elementRef.nativeElement, 'scroll').pipe(Object(takeUntil[\"a\" /* takeUntil */])(this._destroyed))\n                .subscribe(observer)));\n        }\n        ngOnInit() {\n            this.scrollDispatcher.register(this);\n        }\n        ngOnDestroy() {\n            this.scrollDispatcher.deregister(this);\n            this._destroyed.next();\n            this._destroyed.complete();\n        }\n        /** Returns observable that emits when a scroll event is fired on the host element. */\n        elementScrolled() {\n            return this._elementScrolled;\n        }\n        /** Gets the ElementRef for the viewport. */\n        getElementRef() {\n            return this.elementRef;\n        }\n        /**\n         * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo\n         * method, since browsers are not consistent about what scrollLeft means in RTL. For this method\n         * left and right always refer to the left and right side of the scrolling container irrespective\n         * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\n         * in an RTL context.\n         * @param options specified the offsets to scroll to.\n         */\n        scrollTo(options) {\n            const el = this.elementRef.nativeElement;\n            const isRtl = this.dir && this.dir.value == 'rtl';\n            // Rewrite start & end offsets as right or left offsets.\n            if (options.left == null) {\n                options.left = isRtl ? options.end : options.start;\n            }\n            if (options.right == null) {\n                options.right = isRtl ? options.start : options.end;\n            }\n            // Rewrite the bottom offset as a top offset.\n            if (options.bottom != null) {\n                options.top =\n                    el.scrollHeight - el.clientHeight - options.bottom;\n            }\n            // Rewrite the right offset as a left offset.\n            if (isRtl && Object(platform[\"d\" /* getRtlScrollAxisType */])() != 0 /* NORMAL */) {\n                if (options.left != null) {\n                    options.right =\n                        el.scrollWidth - el.clientWidth - options.left;\n                }\n                if (Object(platform[\"d\" /* getRtlScrollAxisType */])() == 2 /* INVERTED */) {\n                    options.left = options.right;\n                }\n                else if (Object(platform[\"d\" /* getRtlScrollAxisType */])() == 1 /* NEGATED */) {\n                    options.left = options.right ? -options.right : options.right;\n                }\n            }\n            else {\n                if (options.right != null) {\n                    options.left =\n                        el.scrollWidth - el.clientWidth - options.right;\n                }\n            }\n            this._applyScrollToOptions(options);\n        }\n        _applyScrollToOptions(options) {\n            const el = this.elementRef.nativeElement;\n            if (Object(platform[\"g\" /* supportsScrollBehavior */])()) {\n                el.scrollTo(options);\n            }\n            else {\n                if (options.top != null) {\n                    el.scrollTop = options.top;\n                }\n                if (options.left != null) {\n                    el.scrollLeft = options.left;\n                }\n            }\n        }\n        /**\n         * Measures the scroll offset relative to the specified edge of the viewport. This method can be\n         * used instead of directly checking scrollLeft or scrollTop, since browsers are not consistent\n         * about what scrollLeft means in RTL. The values returned by this method are normalized such that\n         * left and right always refer to the left and right side of the scrolling container irrespective\n         * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\n         * in an RTL context.\n         * @param from The edge to measure from.\n         */\n        measureScrollOffset(from) {\n            const LEFT = 'left';\n            const RIGHT = 'right';\n            const el = this.elementRef.nativeElement;\n            if (from == 'top') {\n                return el.scrollTop;\n            }\n            if (from == 'bottom') {\n                return el.scrollHeight - el.clientHeight - el.scrollTop;\n            }\n            // Rewrite start & end as left or right offsets.\n            const isRtl = this.dir && this.dir.value == 'rtl';\n            if (from == 'start') {\n                from = isRtl ? RIGHT : LEFT;\n            }\n            else if (from == 'end') {\n                from = isRtl ? LEFT : RIGHT;\n            }\n            if (isRtl && Object(platform[\"d\" /* getRtlScrollAxisType */])() == 2 /* INVERTED */) {\n                // For INVERTED, scrollLeft is (scrollWidth - clientWidth) when scrolled all the way left and\n                // 0 when scrolled all the way right.\n                if (from == LEFT) {\n                    return el.scrollWidth - el.clientWidth - el.scrollLeft;\n                }\n                else {\n                    return el.scrollLeft;\n                }\n            }\n            else if (isRtl && Object(platform[\"d\" /* getRtlScrollAxisType */])() == 1 /* NEGATED */) {\n                // For NEGATED, scrollLeft is -(scrollWidth - clientWidth) when scrolled all the way left and\n                // 0 when scrolled all the way right.\n                if (from == LEFT) {\n                    return el.scrollLeft + el.scrollWidth - el.clientWidth;\n                }\n                else {\n                    return -el.scrollLeft;\n                }\n            }\n            else {\n                // For NORMAL, as well as non-RTL contexts, scrollLeft is 0 when scrolled all the way left and\n                // (scrollWidth - clientWidth) when scrolled all the way right.\n                if (from == LEFT) {\n                    return el.scrollLeft;\n                }\n                else {\n                    return el.scrollWidth - el.clientWidth - el.scrollLeft;\n                }\n            }\n        }\n    }\n    CdkScrollable.ɵfac = function CdkScrollable_Factory(t) { return new (t || CdkScrollable)(core[\"Tb\" /* ɵɵdirectiveInject */](core[\"m\" /* ElementRef */]), core[\"Tb\" /* ɵɵdirectiveInject */](scrolling_ScrollDispatcher), core[\"Tb\" /* ɵɵdirectiveInject */](core[\"F\" /* NgZone */]), core[\"Tb\" /* ɵɵdirectiveInject */](bidi[\"b\" /* Directionality */], 8)); };\n    CdkScrollable.ɵdir = /*@__PURE__*/ core[\"Ob\" /* ɵɵdefineDirective */]({ type: CdkScrollable, selectors: [[\"\", \"cdk-scrollable\", \"\"], [\"\", \"cdkScrollable\", \"\"]] });\n    return CdkScrollable;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Time in ms to throttle the resize events by default. */\nconst DEFAULT_RESIZE_TIME = 20;\nlet scrolling_ViewportRuler = /*@__PURE__*/ (() => {\n    class ViewportRuler {\n        constructor(_platform, ngZone, document) {\n            this._platform = _platform;\n            /** Stream of viewport change events. */\n            this._change = new Subject[\"a\" /* Subject */]();\n            /** Event listener that will be used to handle the viewport change events. */\n            this._changeListener = (event) => {\n                this._change.next(event);\n            };\n            this._document = document;\n            ngZone.runOutsideAngular(() => {\n                if (_platform.isBrowser) {\n                    const window = this._getWindow();\n                    // Note that bind the events ourselves, rather than going through something like RxJS's\n                    // `fromEvent` so that we can ensure that they're bound outside of the NgZone.\n                    window.addEventListener('resize', this._changeListener);\n                    window.addEventListener('orientationchange', this._changeListener);\n                }\n                // We don't need to keep track of the subscription,\n                // because we complete the `change` stream on destroy.\n                this.change().subscribe(() => this._updateViewportSize());\n            });\n        }\n        ngOnDestroy() {\n            if (this._platform.isBrowser) {\n                const window = this._getWindow();\n                window.removeEventListener('resize', this._changeListener);\n                window.removeEventListener('orientationchange', this._changeListener);\n            }\n            this._change.complete();\n        }\n        /** Returns the viewport's width and height. */\n        getViewportSize() {\n            if (!this._viewportSize) {\n                this._updateViewportSize();\n            }\n            const output = { width: this._viewportSize.width, height: this._viewportSize.height };\n            // If we're not on a browser, don't cache the size since it'll be mocked out anyway.\n            if (!this._platform.isBrowser) {\n                this._viewportSize = null;\n            }\n            return output;\n        }\n        /** Gets a ClientRect for the viewport's bounds. */\n        getViewportRect() {\n            // Use the document element's bounding rect rather than the window scroll properties\n            // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\n            // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\n            // conceptual viewports. Under most circumstances these viewports are equivalent, but they\n            // can disagree when the page is pinch-zoomed (on devices that support touch).\n            // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\n            // We use the documentElement instead of the body because, by default (without a css reset)\n            // browsers typically give the document body an 8px margin, which is not included in\n            // getBoundingClientRect().\n            const scrollPosition = this.getViewportScrollPosition();\n            const { width, height } = this.getViewportSize();\n            return {\n                top: scrollPosition.top,\n                left: scrollPosition.left,\n                bottom: scrollPosition.top + height,\n                right: scrollPosition.left + width,\n                height,\n                width,\n            };\n        }\n        /** Gets the (top, left) scroll position of the viewport. */\n        getViewportScrollPosition() {\n            // While we can get a reference to the fake document\n            // during SSR, it doesn't have getBoundingClientRect.\n            if (!this._platform.isBrowser) {\n                return { top: 0, left: 0 };\n            }\n            // The top-left-corner of the viewport is determined by the scroll position of the document\n            // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\n            // whether `document.body` or `document.documentElement` is the scrolled element, so reading\n            // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\n            // `document.documentElement` works consistently, where the `top` and `left` values will\n            // equal negative the scroll position.\n            const document = this._document;\n            const window = this._getWindow();\n            const documentElement = document.documentElement;\n            const documentRect = documentElement.getBoundingClientRect();\n            const top = -documentRect.top || document.body.scrollTop || window.scrollY ||\n                documentElement.scrollTop || 0;\n            const left = -documentRect.left || document.body.scrollLeft || window.scrollX ||\n                documentElement.scrollLeft || 0;\n            return { top, left };\n        }\n        /**\n         * Returns a stream that emits whenever the size of the viewport changes.\n         * @param throttleTime Time in milliseconds to throttle the stream.\n         */\n        change(throttleTime = DEFAULT_RESIZE_TIME) {\n            return throttleTime > 0 ? this._change.pipe(Object(auditTime[\"a\" /* auditTime */])(throttleTime)) : this._change;\n        }\n        /** Use defaultView of injected document if available or fallback to global window reference */\n        _getWindow() {\n            return this._document.defaultView || window;\n        }\n        /** Updates the cached viewport size. */\n        _updateViewportSize() {\n            const window = this._getWindow();\n            this._viewportSize = this._platform.isBrowser ?\n                { width: window.innerWidth, height: window.innerHeight } :\n                { width: 0, height: 0 };\n        }\n    }\n    ViewportRuler.ɵfac = function ViewportRuler_Factory(t) { return new (t || ViewportRuler)(core[\"gc\" /* ɵɵinject */](platform[\"a\" /* Platform */]), core[\"gc\" /* ɵɵinject */](core[\"F\" /* NgZone */]), core[\"gc\" /* ɵɵinject */](common[\"d\" /* DOCUMENT */], 8)); };\n    ViewportRuler.ɵprov = /*@__PURE__*/ Object(core[\"Pb\" /* ɵɵdefineInjectable */])({ factory: function ViewportRuler_Factory() { return new ViewportRuler(Object(core[\"gc\" /* ɵɵinject */])(platform[\"a\" /* Platform */]), Object(core[\"gc\" /* ɵɵinject */])(core[\"F\" /* NgZone */]), Object(core[\"gc\" /* ɵɵinject */])(common[\"d\" /* DOCUMENT */], 8)); }, token: ViewportRuler, providedIn: \"root\" });\n    return ViewportRuler;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Checks if the given ranges are equal. */\nfunction rangesEqual(r1, r2) {\n    return r1.start == r2.start && r1.end == r2.end;\n}\n/**\n * Scheduler to be used for scroll events. Needs to fall back to\n * something that doesn't rely on requestAnimationFrame on environments\n * that don't support it (e.g. server-side rendering).\n */\nconst SCROLL_SCHEDULER = typeof requestAnimationFrame !== 'undefined' ? animationFrame[\"a\" /* animationFrameScheduler */] : asap[\"a\" /* asapScheduler */];\nlet scrolling_CdkVirtualScrollViewport = /*@__PURE__*/ (() => {\n    class CdkVirtualScrollViewport extends scrolling_CdkScrollable {\n        constructor(elementRef, _changeDetectorRef, ngZone, _scrollStrategy, dir, scrollDispatcher, viewportRuler) {\n            super(elementRef, scrollDispatcher, ngZone, dir);\n            this.elementRef = elementRef;\n            this._changeDetectorRef = _changeDetectorRef;\n            this._scrollStrategy = _scrollStrategy;\n            /** Emits when the viewport is detached from a CdkVirtualForOf. */\n            this._detachedSubject = new Subject[\"a\" /* Subject */]();\n            /** Emits when the rendered range changes. */\n            this._renderedRangeSubject = new Subject[\"a\" /* Subject */]();\n            this._orientation = 'vertical';\n            // Note: we don't use the typical EventEmitter here because we need to subscribe to the scroll\n            // strategy lazily (i.e. only if the user is actually listening to the events). We do this because\n            // depending on how the strategy calculates the scrolled index, it may come at a cost to\n            // performance.\n            /** Emits when the index of the first element visible in the viewport changes. */\n            this.scrolledIndexChange = new Observable[\"a\" /* Observable */]((observer) => this._scrollStrategy.scrolledIndexChange.subscribe(index => Promise.resolve().then(() => this.ngZone.run(() => observer.next(index)))));\n            /** A stream that emits whenever the rendered range changes. */\n            this.renderedRangeStream = this._renderedRangeSubject;\n            /**\n             * The total size of all content (in pixels), including content that is not currently rendered.\n             */\n            this._totalContentSize = 0;\n            /** A string representing the `style.width` property value to be used for the spacer element. */\n            this._totalContentWidth = '';\n            /** A string representing the `style.height` property value to be used for the spacer element. */\n            this._totalContentHeight = '';\n            /** The currently rendered range of indices. */\n            this._renderedRange = { start: 0, end: 0 };\n            /** The length of the data bound to this viewport (in number of items). */\n            this._dataLength = 0;\n            /** The size of the viewport (in pixels). */\n            this._viewportSize = 0;\n            /** The last rendered content offset that was set. */\n            this._renderedContentOffset = 0;\n            /**\n             * Whether the last rendered content offset was to the end of the content (and therefore needs to\n             * be rewritten as an offset to the start of the content).\n             */\n            this._renderedContentOffsetNeedsRewrite = false;\n            /** Whether there is a pending change detection cycle. */\n            this._isChangeDetectionPending = false;\n            /** A list of functions to run after the next change detection cycle. */\n            this._runAfterChangeDetection = [];\n            /** Subscription to changes in the viewport size. */\n            this._viewportChanges = Subscription[\"a\" /* Subscription */].EMPTY;\n            if (!_scrollStrategy && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw Error('Error: cdk-virtual-scroll-viewport requires the \"itemSize\" property to be set.');\n            }\n            this._viewportChanges = viewportRuler.change().subscribe(() => {\n                this.checkViewportSize();\n            });\n        }\n        /** The direction the viewport scrolls. */\n        get orientation() {\n            return this._orientation;\n        }\n        set orientation(orientation) {\n            if (this._orientation !== orientation) {\n                this._orientation = orientation;\n                this._calculateSpacerSize();\n            }\n        }\n        ngOnInit() {\n            super.ngOnInit();\n            // It's still too early to measure the viewport at this point. Deferring with a promise allows\n            // the Viewport to be rendered with the correct size before we measure. We run this outside the\n            // zone to avoid causing more change detection cycles. We handle the change detection loop\n            // ourselves instead.\n            this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {\n                this._measureViewportSize();\n                this._scrollStrategy.attach(this);\n                this.elementScrolled()\n                    .pipe(\n                // Start off with a fake scroll event so we properly detect our initial position.\n                Object(startWith[\"a\" /* startWith */])(null), \n                // Collect multiple events into one until the next animation frame. This way if\n                // there are multiple scroll events in the same frame we only need to recheck\n                // our layout once.\n                Object(auditTime[\"a\" /* auditTime */])(0, SCROLL_SCHEDULER))\n                    .subscribe(() => this._scrollStrategy.onContentScrolled());\n                this._markChangeDetectionNeeded();\n            }));\n        }\n        ngOnDestroy() {\n            this.detach();\n            this._scrollStrategy.detach();\n            // Complete all subjects\n            this._renderedRangeSubject.complete();\n            this._detachedSubject.complete();\n            this._viewportChanges.unsubscribe();\n            super.ngOnDestroy();\n        }\n        /** Attaches a `CdkVirtualScrollRepeater` to this viewport. */\n        attach(forOf) {\n            if (this._forOf && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw Error('CdkVirtualScrollViewport is already attached.');\n            }\n            // Subscribe to the data stream of the CdkVirtualForOf to keep track of when the data length\n            // changes. Run outside the zone to avoid triggering change detection, since we're managing the\n            // change detection loop ourselves.\n            this.ngZone.runOutsideAngular(() => {\n                this._forOf = forOf;\n                this._forOf.dataStream.pipe(Object(takeUntil[\"a\" /* takeUntil */])(this._detachedSubject)).subscribe(data => {\n                    const newLength = data.length;\n                    if (newLength !== this._dataLength) {\n                        this._dataLength = newLength;\n                        this._scrollStrategy.onDataLengthChanged();\n                    }\n                    this._doChangeDetection();\n                });\n            });\n        }\n        /** Detaches the current `CdkVirtualForOf`. */\n        detach() {\n            this._forOf = null;\n            this._detachedSubject.next();\n        }\n        /** Gets the length of the data bound to this viewport (in number of items). */\n        getDataLength() {\n            return this._dataLength;\n        }\n        /** Gets the size of the viewport (in pixels). */\n        getViewportSize() {\n            return this._viewportSize;\n        }\n        // TODO(mmalerba): This is technically out of sync with what's really rendered until a render\n        // cycle happens. I'm being careful to only call it after the render cycle is complete and before\n        // setting it to something else, but its error prone and should probably be split into\n        // `pendingRange` and `renderedRange`, the latter reflecting whats actually in the DOM.\n        /** Get the current rendered range of items. */\n        getRenderedRange() {\n            return this._renderedRange;\n        }\n        /**\n         * Sets the total size of all content (in pixels), including content that is not currently\n         * rendered.\n         */\n        setTotalContentSize(size) {\n            if (this._totalContentSize !== size) {\n                this._totalContentSize = size;\n                this._calculateSpacerSize();\n                this._markChangeDetectionNeeded();\n            }\n        }\n        /** Sets the currently rendered range of indices. */\n        setRenderedRange(range) {\n            if (!rangesEqual(this._renderedRange, range)) {\n                this._renderedRangeSubject.next(this._renderedRange = range);\n                this._markChangeDetectionNeeded(() => this._scrollStrategy.onContentRendered());\n            }\n        }\n        /**\n         * Gets the offset from the start of the viewport to the start of the rendered data (in pixels).\n         */\n        getOffsetToRenderedContentStart() {\n            return this._renderedContentOffsetNeedsRewrite ? null : this._renderedContentOffset;\n        }\n        /**\n         * Sets the offset from the start of the viewport to either the start or end of the rendered data\n         * (in pixels).\n         */\n        setRenderedContentOffset(offset, to = 'to-start') {\n            // For a horizontal viewport in a right-to-left language we need to translate along the x-axis\n            // in the negative direction.\n            const isRtl = this.dir && this.dir.value == 'rtl';\n            const isHorizontal = this.orientation == 'horizontal';\n            const axis = isHorizontal ? 'X' : 'Y';\n            const axisDirection = isHorizontal && isRtl ? -1 : 1;\n            let transform = `translate${axis}(${Number(axisDirection * offset)}px)`;\n            this._renderedContentOffset = offset;\n            if (to === 'to-end') {\n                transform += ` translate${axis}(-100%)`;\n                // The viewport should rewrite this as a `to-start` offset on the next render cycle. Otherwise\n                // elements will appear to expand in the wrong direction (e.g. `mat-expansion-panel` would\n                // expand upward).\n                this._renderedContentOffsetNeedsRewrite = true;\n            }\n            if (this._renderedContentTransform != transform) {\n                // We know this value is safe because we parse `offset` with `Number()` before passing it\n                // into the string.\n                this._renderedContentTransform = transform;\n                this._markChangeDetectionNeeded(() => {\n                    if (this._renderedContentOffsetNeedsRewrite) {\n                        this._renderedContentOffset -= this.measureRenderedContentSize();\n                        this._renderedContentOffsetNeedsRewrite = false;\n                        this.setRenderedContentOffset(this._renderedContentOffset);\n                    }\n                    else {\n                        this._scrollStrategy.onRenderedOffsetChanged();\n                    }\n                });\n            }\n        }\n        /**\n         * Scrolls to the given offset from the start of the viewport. Please note that this is not always\n         * the same as setting `scrollTop` or `scrollLeft`. In a horizontal viewport with right-to-left\n         * direction, this would be the equivalent of setting a fictional `scrollRight` property.\n         * @param offset The offset to scroll to.\n         * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\n         */\n        scrollToOffset(offset, behavior = 'auto') {\n            const options = { behavior };\n            if (this.orientation === 'horizontal') {\n                options.start = offset;\n            }\n            else {\n                options.top = offset;\n            }\n            this.scrollTo(options);\n        }\n        /**\n         * Scrolls to the offset for the given index.\n         * @param index The index of the element to scroll to.\n         * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\n         */\n        scrollToIndex(index, behavior = 'auto') {\n            this._scrollStrategy.scrollToIndex(index, behavior);\n        }\n        /**\n         * Gets the current scroll offset from the start of the viewport (in pixels).\n         * @param from The edge to measure the offset from. Defaults to 'top' in vertical mode and 'start'\n         *     in horizontal mode.\n         */\n        measureScrollOffset(from) {\n            return from ?\n                super.measureScrollOffset(from) :\n                super.measureScrollOffset(this.orientation === 'horizontal' ? 'start' : 'top');\n        }\n        /** Measure the combined size of all of the rendered items. */\n        measureRenderedContentSize() {\n            const contentEl = this._contentWrapper.nativeElement;\n            return this.orientation === 'horizontal' ? contentEl.offsetWidth : contentEl.offsetHeight;\n        }\n        /**\n         * Measure the total combined size of the given range. Throws if the range includes items that are\n         * not rendered.\n         */\n        measureRangeSize(range) {\n            if (!this._forOf) {\n                return 0;\n            }\n            return this._forOf.measureRangeSize(range, this.orientation);\n        }\n        /** Update the viewport dimensions and re-render. */\n        checkViewportSize() {\n            // TODO: Cleanup later when add logic for handling content resize\n            this._measureViewportSize();\n            this._scrollStrategy.onDataLengthChanged();\n        }\n        /** Measure the viewport size. */\n        _measureViewportSize() {\n            const viewportEl = this.elementRef.nativeElement;\n            this._viewportSize = this.orientation === 'horizontal' ?\n                viewportEl.clientWidth : viewportEl.clientHeight;\n        }\n        /** Queue up change detection to run. */\n        _markChangeDetectionNeeded(runAfter) {\n            if (runAfter) {\n                this._runAfterChangeDetection.push(runAfter);\n            }\n            // Use a Promise to batch together calls to `_doChangeDetection`. This way if we set a bunch of\n            // properties sequentially we only have to run `_doChangeDetection` once at the end.\n            if (!this._isChangeDetectionPending) {\n                this._isChangeDetectionPending = true;\n                this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {\n                    this._doChangeDetection();\n                }));\n            }\n        }\n        /** Run change detection. */\n        _doChangeDetection() {\n            this._isChangeDetectionPending = false;\n            // Apply the content transform. The transform can't be set via an Angular binding because\n            // bypassSecurityTrustStyle is banned in Google. However the value is safe, it's composed of\n            // string literals, a variable that can only be 'X' or 'Y', and user input that is run through\n            // the `Number` function first to coerce it to a numeric value.\n            this._contentWrapper.nativeElement.style.transform = this._renderedContentTransform;\n            // Apply changes to Angular bindings. Note: We must call `markForCheck` to run change detection\n            // from the root, since the repeated items are content projected in. Calling `detectChanges`\n            // instead does not properly check the projected content.\n            this.ngZone.run(() => this._changeDetectorRef.markForCheck());\n            const runAfterChangeDetection = this._runAfterChangeDetection;\n            this._runAfterChangeDetection = [];\n            for (const fn of runAfterChangeDetection) {\n                fn();\n            }\n        }\n        /** Calculates the `style.width` and `style.height` for the spacer element. */\n        _calculateSpacerSize() {\n            this._totalContentHeight =\n                this.orientation === 'horizontal' ? '' : `${this._totalContentSize}px`;\n            this._totalContentWidth =\n                this.orientation === 'horizontal' ? `${this._totalContentSize}px` : '';\n        }\n    }\n    CdkVirtualScrollViewport.ɵfac = function CdkVirtualScrollViewport_Factory(t) { return new (t || CdkVirtualScrollViewport)(core[\"Tb\" /* ɵɵdirectiveInject */](core[\"m\" /* ElementRef */]), core[\"Tb\" /* ɵɵdirectiveInject */](core[\"i\" /* ChangeDetectorRef */]), core[\"Tb\" /* ɵɵdirectiveInject */](core[\"F\" /* NgZone */]), core[\"Tb\" /* ɵɵdirectiveInject */](VIRTUAL_SCROLL_STRATEGY, 8), core[\"Tb\" /* ɵɵdirectiveInject */](bidi[\"b\" /* Directionality */], 8), core[\"Tb\" /* ɵɵdirectiveInject */](scrolling_ScrollDispatcher), core[\"Tb\" /* ɵɵdirectiveInject */](scrolling_ViewportRuler)); };\n    CdkVirtualScrollViewport.ɵcmp = /*@__PURE__*/ core[\"Nb\" /* ɵɵdefineComponent */]({ type: CdkVirtualScrollViewport, selectors: [[\"cdk-virtual-scroll-viewport\"]], viewQuery: function CdkVirtualScrollViewport_Query(rf, ctx) {\n            if (rf & 1) {\n                core[\"Nc\" /* ɵɵstaticViewQuery */](_c0, true);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"Fc\" /* ɵɵqueryRefresh */](_t = core[\"kc\" /* ɵɵloadQuery */]()) && (ctx._contentWrapper = _t.first);\n            }\n        }, hostAttrs: [1, \"cdk-virtual-scroll-viewport\"], hostVars: 4, hostBindings: function CdkVirtualScrollViewport_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Lb\" /* ɵɵclassProp */](\"cdk-virtual-scroll-orientation-horizontal\", ctx.orientation === \"horizontal\")(\"cdk-virtual-scroll-orientation-vertical\", ctx.orientation !== \"horizontal\");\n            }\n        }, inputs: { orientation: \"orientation\" }, outputs: { scrolledIndexChange: \"scrolledIndexChange\" }, features: [/*@__PURE__*/ core[\"Fb\" /* ɵɵProvidersFeature */]([{\n                    provide: scrolling_CdkScrollable,\n                    useExisting: CdkVirtualScrollViewport\n                }]), core[\"Db\" /* ɵɵInheritDefinitionFeature */]], ngContentSelectors: _c1, decls: 4, vars: 4, consts: [[1, \"cdk-virtual-scroll-content-wrapper\"], [\"contentWrapper\", \"\"], [1, \"cdk-virtual-scroll-spacer\"]], template: function CdkVirtualScrollViewport_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"sc\" /* ɵɵprojectionDef */]();\n                core[\"Zb\" /* ɵɵelementStart */](0, \"div\", 0, 1);\n                core[\"rc\" /* ɵɵprojection */](2);\n                core[\"Yb\" /* ɵɵelementEnd */]();\n                core[\"Ub\" /* ɵɵelement */](3, \"div\", 2);\n            }\n            if (rf & 2) {\n                core[\"Gb\" /* ɵɵadvance */](3);\n                core[\"Pc\" /* ɵɵstyleProp */](\"width\", ctx._totalContentWidth)(\"height\", ctx._totalContentHeight);\n            }\n        }, styles: [\"cdk-virtual-scroll-viewport{display:block;position:relative;overflow:auto;contain:strict;transform:translateZ(0);will-change:scroll-position;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{position:absolute;top:0;left:0;height:1px;width:1px;transform-origin:0 0}[dir=rtl] .cdk-virtual-scroll-spacer{right:0;left:auto;transform-origin:100% 0}\\n\"], encapsulation: 2, changeDetection: 0 });\n    return CdkVirtualScrollViewport;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Helper to extract the offset of a DOM Node in a certain direction. */\nfunction getOffset(orientation, direction, node) {\n    const el = node;\n    if (!el.getBoundingClientRect) {\n        return 0;\n    }\n    const rect = el.getBoundingClientRect();\n    if (orientation === 'horizontal') {\n        return direction === 'start' ? rect.left : rect.right;\n    }\n    return direction === 'start' ? rect.top : rect.bottom;\n}\nlet scrolling_CdkVirtualForOf = /*@__PURE__*/ (() => {\n    class CdkVirtualForOf {\n        constructor(\n        /** The view container to add items to. */\n        _viewContainerRef, \n        /** The template to use when stamping out new items. */\n        _template, \n        /** The set of available differs. */\n        _differs, \n        /** The strategy used to render items in the virtual scroll viewport. */\n        _viewRepeater, \n        /** The virtual scrolling viewport that these items are being rendered in. */\n        _viewport, ngZone) {\n            this._viewContainerRef = _viewContainerRef;\n            this._template = _template;\n            this._differs = _differs;\n            this._viewRepeater = _viewRepeater;\n            this._viewport = _viewport;\n            /** Emits when the rendered view of the data changes. */\n            this.viewChange = new Subject[\"a\" /* Subject */]();\n            /** Subject that emits when a new DataSource instance is given. */\n            this._dataSourceChanges = new Subject[\"a\" /* Subject */]();\n            /** Emits whenever the data in the current DataSource changes. */\n            this.dataStream = this._dataSourceChanges\n                .pipe(\n            // Start off with null `DataSource`.\n            Object(startWith[\"a\" /* startWith */])(null), \n            // Bundle up the previous and current data sources so we can work with both.\n            pairwise(), \n            // Use `_changeDataSource` to disconnect from the previous data source and connect to the\n            // new one, passing back a stream of data changes which we run through `switchMap` to give\n            // us a data stream that emits the latest data from whatever the current `DataSource` is.\n            Object(switchMap[\"a\" /* switchMap */])(([prev, cur]) => this._changeDataSource(prev, cur)), \n            // Replay the last emitted data when someone subscribes.\n            Object(shareReplay[\"a\" /* shareReplay */])(1));\n            /** The differ used to calculate changes to the data. */\n            this._differ = null;\n            /** Whether the rendered data should be updated during the next ngDoCheck cycle. */\n            this._needsUpdate = false;\n            this._destroyed = new Subject[\"a\" /* Subject */]();\n            this.dataStream.subscribe(data => {\n                this._data = data;\n                this._onRenderedDataChange();\n            });\n            this._viewport.renderedRangeStream.pipe(Object(takeUntil[\"a\" /* takeUntil */])(this._destroyed)).subscribe(range => {\n                this._renderedRange = range;\n                ngZone.run(() => this.viewChange.next(this._renderedRange));\n                this._onRenderedDataChange();\n            });\n            this._viewport.attach(this);\n        }\n        /** The DataSource to display. */\n        get cdkVirtualForOf() {\n            return this._cdkVirtualForOf;\n        }\n        set cdkVirtualForOf(value) {\n            this._cdkVirtualForOf = value;\n            if (Object(collections[\"h\" /* isDataSource */])(value)) {\n                this._dataSourceChanges.next(value);\n            }\n            else {\n                // If value is an an NgIterable, convert it to an array.\n                this._dataSourceChanges.next(new collections[\"a\" /* ArrayDataSource */](Object(isObservable[\"a\" /* isObservable */])(value) ? value : Array.from(value || [])));\n            }\n        }\n        /**\n         * The `TrackByFunction` to use for tracking changes. The `TrackByFunction` takes the index and\n         * the item and produces a value to be used as the item's identity when tracking changes.\n         */\n        get cdkVirtualForTrackBy() {\n            return this._cdkVirtualForTrackBy;\n        }\n        set cdkVirtualForTrackBy(fn) {\n            this._needsUpdate = true;\n            this._cdkVirtualForTrackBy = fn ?\n                (index, item) => fn(index + (this._renderedRange ? this._renderedRange.start : 0), item) :\n                undefined;\n        }\n        /** The template used to stamp out new elements. */\n        set cdkVirtualForTemplate(value) {\n            if (value) {\n                this._needsUpdate = true;\n                this._template = value;\n            }\n        }\n        /**\n         * The size of the cache used to store templates that are not being used for re-use later.\n         * Setting the cache size to `0` will disable caching. Defaults to 20 templates.\n         */\n        get cdkVirtualForTemplateCacheSize() {\n            return this._viewRepeater.viewCacheSize;\n        }\n        set cdkVirtualForTemplateCacheSize(size) {\n            this._viewRepeater.viewCacheSize = Object(coercion[\"f\" /* coerceNumberProperty */])(size);\n        }\n        /**\n         * Measures the combined size (width for horizontal orientation, height for vertical) of all items\n         * in the specified range. Throws an error if the range includes items that are not currently\n         * rendered.\n         */\n        measureRangeSize(range, orientation) {\n            if (range.start >= range.end) {\n                return 0;\n            }\n            if ((range.start < this._renderedRange.start || range.end > this._renderedRange.end) &&\n                (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw Error(`Error: attempted to measure an item that isn't rendered.`);\n            }\n            // The index into the list of rendered views for the first item in the range.\n            const renderedStartIndex = range.start - this._renderedRange.start;\n            // The length of the range we're measuring.\n            const rangeLen = range.end - range.start;\n            // Loop over all the views, find the first and land node and compute the size by subtracting\n            // the top of the first node from the bottom of the last one.\n            let firstNode;\n            let lastNode;\n            // Find the first node by starting from the beginning and going forwards.\n            for (let i = 0; i < rangeLen; i++) {\n                const view = this._viewContainerRef.get(i + renderedStartIndex);\n                if (view && view.rootNodes.length) {\n                    firstNode = lastNode = view.rootNodes[0];\n                    break;\n                }\n            }\n            // Find the last node by starting from the end and going backwards.\n            for (let i = rangeLen - 1; i > -1; i--) {\n                const view = this._viewContainerRef.get(i + renderedStartIndex);\n                if (view && view.rootNodes.length) {\n                    lastNode = view.rootNodes[view.rootNodes.length - 1];\n                    break;\n                }\n            }\n            return firstNode && lastNode ?\n                getOffset(orientation, 'end', lastNode) - getOffset(orientation, 'start', firstNode) : 0;\n        }\n        ngDoCheck() {\n            if (this._differ && this._needsUpdate) {\n                // TODO(mmalerba): We should differentiate needs update due to scrolling and a new portion of\n                // this list being rendered (can use simpler algorithm) vs needs update due to data actually\n                // changing (need to do this diff).\n                const changes = this._differ.diff(this._renderedItems);\n                if (!changes) {\n                    this._updateContext();\n                }\n                else {\n                    this._applyChanges(changes);\n                }\n                this._needsUpdate = false;\n            }\n        }\n        ngOnDestroy() {\n            this._viewport.detach();\n            this._dataSourceChanges.next(undefined);\n            this._dataSourceChanges.complete();\n            this.viewChange.complete();\n            this._destroyed.next();\n            this._destroyed.complete();\n            this._viewRepeater.detach();\n        }\n        /** React to scroll state changes in the viewport. */\n        _onRenderedDataChange() {\n            if (!this._renderedRange) {\n                return;\n            }\n            this._renderedItems = this._data.slice(this._renderedRange.start, this._renderedRange.end);\n            if (!this._differ) {\n                // Use a wrapper function for the `trackBy` so any new values are\n                // picked up automatically without having to recreate the differ.\n                this._differ = this._differs.find(this._renderedItems).create((index, item) => {\n                    return this.cdkVirtualForTrackBy ? this.cdkVirtualForTrackBy(index, item) : item;\n                });\n            }\n            this._needsUpdate = true;\n        }\n        /** Swap out one `DataSource` for another. */\n        _changeDataSource(oldDs, newDs) {\n            if (oldDs) {\n                oldDs.disconnect(this);\n            }\n            this._needsUpdate = true;\n            return newDs ? newDs.connect(this) : Object(of[\"a\" /* of */])();\n        }\n        /** Update the `CdkVirtualForOfContext` for all views. */\n        _updateContext() {\n            const count = this._data.length;\n            let i = this._viewContainerRef.length;\n            while (i--) {\n                const view = this._viewContainerRef.get(i);\n                view.context.index = this._renderedRange.start + i;\n                view.context.count = count;\n                this._updateComputedContextProperties(view.context);\n                view.detectChanges();\n            }\n        }\n        /** Apply changes to the DOM. */\n        _applyChanges(changes) {\n            this._viewRepeater.applyChanges(changes, this._viewContainerRef, (record, _adjustedPreviousIndex, currentIndex) => this._getEmbeddedViewArgs(record, currentIndex), (record) => record.item);\n            // Update $implicit for any items that had an identity change.\n            changes.forEachIdentityChange((record) => {\n                const view = this._viewContainerRef.get(record.currentIndex);\n                view.context.$implicit = record.item;\n            });\n            // Update the context variables on all items.\n            const count = this._data.length;\n            let i = this._viewContainerRef.length;\n            while (i--) {\n                const view = this._viewContainerRef.get(i);\n                view.context.index = this._renderedRange.start + i;\n                view.context.count = count;\n                this._updateComputedContextProperties(view.context);\n            }\n        }\n        /** Update the computed properties on the `CdkVirtualForOfContext`. */\n        _updateComputedContextProperties(context) {\n            context.first = context.index === 0;\n            context.last = context.index === context.count - 1;\n            context.even = context.index % 2 === 0;\n            context.odd = !context.even;\n        }\n        _getEmbeddedViewArgs(record, index) {\n            // Note that it's important that we insert the item directly at the proper index,\n            // rather than inserting it and the moving it in place, because if there's a directive\n            // on the same node that injects the `ViewContainerRef`, Angular will insert another\n            // comment node which can throw off the move when it's being repeated for all items.\n            return {\n                templateRef: this._template,\n                context: {\n                    $implicit: record.item,\n                    // It's guaranteed that the iterable is not \"undefined\" or \"null\" because we only\n                    // generate views for elements if the \"cdkVirtualForOf\" iterable has elements.\n                    cdkVirtualForOf: this._cdkVirtualForOf,\n                    index: -1,\n                    count: -1,\n                    first: false,\n                    last: false,\n                    odd: false,\n                    even: false\n                },\n                index,\n            };\n        }\n    }\n    CdkVirtualForOf.ɵfac = function CdkVirtualForOf_Factory(t) { return new (t || CdkVirtualForOf)(core[\"Tb\" /* ɵɵdirectiveInject */](core[\"V\" /* ViewContainerRef */]), core[\"Tb\" /* ɵɵdirectiveInject */](core[\"R\" /* TemplateRef */]), core[\"Tb\" /* ɵɵdirectiveInject */](core[\"x\" /* IterableDiffers */]), core[\"Tb\" /* ɵɵdirectiveInject */](collections[\"g\" /* _VIEW_REPEATER_STRATEGY */]), core[\"Tb\" /* ɵɵdirectiveInject */](scrolling_CdkVirtualScrollViewport, 4), core[\"Tb\" /* ɵɵdirectiveInject */](core[\"F\" /* NgZone */])); };\n    CdkVirtualForOf.ɵdir = /*@__PURE__*/ core[\"Ob\" /* ɵɵdefineDirective */]({ type: CdkVirtualForOf, selectors: [[\"\", \"cdkVirtualFor\", \"\", \"cdkVirtualForOf\", \"\"]], inputs: { cdkVirtualForOf: \"cdkVirtualForOf\", cdkVirtualForTrackBy: \"cdkVirtualForTrackBy\", cdkVirtualForTemplate: \"cdkVirtualForTemplate\", cdkVirtualForTemplateCacheSize: \"cdkVirtualForTemplateCacheSize\" }, features: [/*@__PURE__*/ core[\"Fb\" /* ɵɵProvidersFeature */]([\n                { provide: collections[\"g\" /* _VIEW_REPEATER_STRATEGY */], useClass: collections[\"f\" /* _RecycleViewRepeaterStrategy */] },\n            ])] });\n    return CdkVirtualForOf;\n})();\nlet scrolling_CdkScrollableModule = /*@__PURE__*/ (() => {\n    class CdkScrollableModule {\n    }\n    CdkScrollableModule.ɵmod = /*@__PURE__*/ core[\"Rb\" /* ɵɵdefineNgModule */]({ type: CdkScrollableModule });\n    CdkScrollableModule.ɵinj = /*@__PURE__*/ core[\"Qb\" /* ɵɵdefineInjector */]({ factory: function CdkScrollableModule_Factory(t) { return new (t || CdkScrollableModule)(); } });\n    return CdkScrollableModule;\n})();\n/*@__PURE__*/ (function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Lc\" /* ɵɵsetNgModuleScope */](scrolling_CdkScrollableModule, { declarations: [scrolling_CdkScrollable], exports: [scrolling_CdkScrollable] }); })();\nlet scrolling_ScrollingModule = /*@__PURE__*/ (() => {\n    class ScrollingModule {\n    }\n    ScrollingModule.ɵmod = /*@__PURE__*/ core[\"Rb\" /* ɵɵdefineNgModule */]({ type: ScrollingModule });\n    ScrollingModule.ɵinj = /*@__PURE__*/ core[\"Qb\" /* ɵɵdefineInjector */]({ factory: function ScrollingModule_Factory(t) { return new (t || ScrollingModule)(); }, imports: [[\n                bidi[\"a\" /* BidiModule */],\n                platform[\"b\" /* PlatformModule */],\n                scrolling_CdkScrollableModule\n            ], bidi[\"a\" /* BidiModule */], scrolling_CdkScrollableModule] });\n    return ScrollingModule;\n})();\n/*@__PURE__*/ (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Lc\" /* ɵɵsetNgModuleScope */](scrolling_ScrollingModule, { declarations: function () { return [scrolling_CdkFixedSizeVirtualScroll, scrolling_CdkVirtualForOf, scrolling_CdkVirtualScrollViewport]; }, imports: function () {\n            return [bidi[\"a\" /* BidiModule */],\n                platform[\"b\" /* PlatformModule */], scrolling_CdkScrollableModule];\n        }, exports: function () { return [bidi[\"a\" /* BidiModule */], scrolling_CdkScrollableModule, scrolling_CdkFixedSizeVirtualScroll, scrolling_CdkVirtualForOf, scrolling_CdkVirtualScrollViewport]; } });\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=scrolling.js.map\n\n\n/***/ }),\n\n/***/ \"wZkO\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export MAT_TABS_CONFIG */\n/* unused harmony export MAT_TAB_GROUP */\n/* unused harmony export MatInkBar */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return MatTab; });\n/* unused harmony export MatTabBody */\n/* unused harmony export MatTabBodyPortal */\n/* unused harmony export MatTabChangeEvent */\n/* unused harmony export MatTabContent */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return MatTabGroup; });\n/* unused harmony export MatTabHeader */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return MatTabLabel; });\n/* unused harmony export MatTabLabelWrapper */\n/* unused harmony export MatTabLink */\n/* unused harmony export MatTabNav */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return MatTabsModule; });\n/* unused harmony export _MAT_INK_BAR_POSITIONER */\n/* unused harmony export _MatTabBodyBase */\n/* unused harmony export _MatTabGroupBase */\n/* unused harmony export _MatTabHeaderBase */\n/* unused harmony export _MatTabLinkBase */\n/* unused harmony export _MatTabNavBase */\n/* unused harmony export matTabsAnimations */\n/* unused harmony export ɵangular_material_src_material_tabs_tabs_a */\n/* unused harmony export ɵangular_material_src_material_tabs_tabs_b */\n/* unused harmony export ɵangular_material_src_material_tabs_tabs_c */\n/* unused harmony export ɵangular_material_src_material_tabs_tabs_d */\n/* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"u47x\");\n/* harmony import */ var _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"GU7r\");\n/* harmony import */ var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"+rOU\");\n/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"ofXK\");\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"fXoL\");\n/* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"FKr1\");\n/* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(\"R1ws\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(\"XNiG\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(\"quSY\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(\"VRyK\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(\"xgIS\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(\"LRne\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(\"PqYM\");\n/* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(\"R0Ic\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(\"JX91\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(\"/uUt\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(\"1G5W\");\n/* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(\"8LU1\");\n/* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(\"nLfN\");\n/* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(\"FtGj\");\n/* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(\"cH1L\");\n/* harmony import */ var _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(\"vxfF\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Injection token for the MatInkBar's Positioner. */\n\n\n\n\n\n\n\n\n\nfunction MatTab_ng_template_0_Template(rf, ctx) {\n    if (rf & 1) {\n        _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵprojection */ \"rc\"](0);\n    }\n}\nconst _c0 = [\"*\"];\nfunction MatTabBody_ng_template_2_Template(rf, ctx) { }\nconst _c1 = function (a0) { return { animationDuration: a0 }; };\nconst _c2 = function (a0, a1) { return { value: a0, params: a1 }; };\nconst _c3 = [\"tabBodyWrapper\"];\nconst _c4 = [\"tabHeader\"];\nfunction MatTabGroup_div_2_ng_template_2_ng_template_0_Template(rf, ctx) { }\nfunction MatTabGroup_div_2_ng_template_2_Template(rf, ctx) {\n    if (rf & 1) {\n        _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵtemplate */ \"Sc\"](0, MatTabGroup_div_2_ng_template_2_ng_template_0_Template, 0, 0, \"ng-template\", 9);\n    }\n    if (rf & 2) {\n        const tab_r4 = _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵnextContext */ \"nc\"]().$implicit;\n        _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵproperty */ \"tc\"](\"cdkPortalOutlet\", tab_r4.templateLabel);\n    }\n}\nfunction MatTabGroup_div_2_ng_template_3_Template(rf, ctx) {\n    if (rf & 1) {\n        _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵtext */ \"Uc\"](0);\n    }\n    if (rf & 2) {\n        const tab_r4 = _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵnextContext */ \"nc\"]().$implicit;\n        _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵtextInterpolate */ \"Vc\"](tab_r4.textLabel);\n    }\n}\nfunction MatTabGroup_div_2_Template(rf, ctx) {\n    if (rf & 1) {\n        const _r12 = _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵgetCurrentView */ \"ac\"]();\n        _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelementStart */ \"Zb\"](0, \"div\", 6);\n        _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵlistener */ \"jc\"](\"click\", function MatTabGroup_div_2_Template_div_click_0_listener() { _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵrestoreView */ \"Ic\"](_r12); const tab_r4 = ctx.$implicit; const i_r5 = ctx.index; const ctx_r11 = _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵnextContext */ \"nc\"](); const _r0 = _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵreference */ \"Gc\"](1); return ctx_r11._handleClick(tab_r4, _r0, i_r5); })(\"cdkFocusChange\", function MatTabGroup_div_2_Template_div_cdkFocusChange_0_listener($event) { _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵrestoreView */ \"Ic\"](_r12); const i_r5 = ctx.index; const ctx_r13 = _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵnextContext */ \"nc\"](); return ctx_r13._tabFocusChanged($event, i_r5); });\n        _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelementStart */ \"Zb\"](1, \"div\", 7);\n        _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵtemplate */ \"Sc\"](2, MatTabGroup_div_2_ng_template_2_Template, 1, 1, \"ng-template\", 8);\n        _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵtemplate */ \"Sc\"](3, MatTabGroup_div_2_ng_template_3_Template, 1, 1, \"ng-template\", 8);\n        _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelementEnd */ \"Yb\"]();\n        _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelementEnd */ \"Yb\"]();\n    }\n    if (rf & 2) {\n        const tab_r4 = ctx.$implicit;\n        const i_r5 = ctx.index;\n        const ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵnextContext */ \"nc\"]();\n        _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵclassProp */ \"Lb\"](\"mat-tab-label-active\", ctx_r1.selectedIndex == i_r5);\n        _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵproperty */ \"tc\"](\"id\", ctx_r1._getTabLabelId(i_r5))(\"disabled\", tab_r4.disabled)(\"matRippleDisabled\", tab_r4.disabled || ctx_r1.disableRipple);\n        _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵattribute */ \"Hb\"](\"tabIndex\", ctx_r1._getTabIndex(tab_r4, i_r5))(\"aria-posinset\", i_r5 + 1)(\"aria-setsize\", ctx_r1._tabs.length)(\"aria-controls\", ctx_r1._getTabContentId(i_r5))(\"aria-selected\", ctx_r1.selectedIndex == i_r5)(\"aria-label\", tab_r4.ariaLabel || null)(\"aria-labelledby\", !tab_r4.ariaLabel && tab_r4.ariaLabelledby ? tab_r4.ariaLabelledby : null);\n        _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵadvance */ \"Gb\"](2);\n        _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵproperty */ \"tc\"](\"ngIf\", tab_r4.templateLabel);\n        _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵadvance */ \"Gb\"](1);\n        _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵproperty */ \"tc\"](\"ngIf\", !tab_r4.templateLabel);\n    }\n}\nfunction MatTabGroup_mat_tab_body_5_Template(rf, ctx) {\n    if (rf & 1) {\n        const _r17 = _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵgetCurrentView */ \"ac\"]();\n        _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelementStart */ \"Zb\"](0, \"mat-tab-body\", 10);\n        _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵlistener */ \"jc\"](\"_onCentered\", function MatTabGroup_mat_tab_body_5_Template_mat_tab_body__onCentered_0_listener() { _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵrestoreView */ \"Ic\"](_r17); const ctx_r16 = _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵnextContext */ \"nc\"](); return ctx_r16._removeTabBodyWrapperHeight(); })(\"_onCentering\", function MatTabGroup_mat_tab_body_5_Template_mat_tab_body__onCentering_0_listener($event) { _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵrestoreView */ \"Ic\"](_r17); const ctx_r18 = _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵnextContext */ \"nc\"](); return ctx_r18._setTabBodyWrapperHeight($event); });\n        _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelementEnd */ \"Yb\"]();\n    }\n    if (rf & 2) {\n        const tab_r14 = ctx.$implicit;\n        const i_r15 = ctx.index;\n        const ctx_r3 = _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵnextContext */ \"nc\"]();\n        _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵclassProp */ \"Lb\"](\"mat-tab-body-active\", ctx_r3.selectedIndex == i_r15);\n        _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵproperty */ \"tc\"](\"id\", ctx_r3._getTabContentId(i_r15))(\"content\", tab_r14.content)(\"position\", tab_r14.position)(\"origin\", tab_r14.origin)(\"animationDuration\", ctx_r3.animationDuration);\n        _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵattribute */ \"Hb\"](\"aria-labelledby\", ctx_r3._getTabLabelId(i_r15));\n    }\n}\nconst _c5 = [\"tabListContainer\"];\nconst _c6 = [\"tabList\"];\nconst _c7 = [\"nextPaginator\"];\nconst _c8 = [\"previousPaginator\"];\nconst _c9 = [\"mat-tab-nav-bar\", \"\"];\nconst _MAT_INK_BAR_POSITIONER = /*@__PURE__*/ new _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* InjectionToken */ \"u\"]('MatInkBarPositioner', {\n    providedIn: 'root',\n    factory: _MAT_INK_BAR_POSITIONER_FACTORY\n});\n/**\n * The default positioner function for the MatInkBar.\n * @docs-private\n */\nfunction _MAT_INK_BAR_POSITIONER_FACTORY() {\n    const method = (element) => ({\n        left: element ? (element.offsetLeft || 0) + 'px' : '0',\n        width: element ? (element.offsetWidth || 0) + 'px' : '0',\n    });\n    return method;\n}\nlet MatInkBar = /*@__PURE__*/ (() => {\n    class MatInkBar {\n        constructor(_elementRef, _ngZone, _inkBarPositioner, _animationMode) {\n            this._elementRef = _elementRef;\n            this._ngZone = _ngZone;\n            this._inkBarPositioner = _inkBarPositioner;\n            this._animationMode = _animationMode;\n        }\n        /**\n         * Calculates the styles from the provided element in order to align the ink-bar to that element.\n         * Shows the ink bar if previously set as hidden.\n         * @param element\n         */\n        alignToElement(element) {\n            this.show();\n            if (typeof requestAnimationFrame !== 'undefined') {\n                this._ngZone.runOutsideAngular(() => {\n                    requestAnimationFrame(() => this._setStyles(element));\n                });\n            }\n            else {\n                this._setStyles(element);\n            }\n        }\n        /** Shows the ink bar. */\n        show() {\n            this._elementRef.nativeElement.style.visibility = 'visible';\n        }\n        /** Hides the ink bar. */\n        hide() {\n            this._elementRef.nativeElement.style.visibility = 'hidden';\n        }\n        /**\n         * Sets the proper styles to the ink bar element.\n         * @param element\n         */\n        _setStyles(element) {\n            const positions = this._inkBarPositioner(element);\n            const inkBar = this._elementRef.nativeElement;\n            inkBar.style.left = positions.left;\n            inkBar.style.width = positions.width;\n        }\n    }\n    MatInkBar.ɵfac = function MatInkBar_Factory(t) { return new (t || MatInkBar)(_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ElementRef */ \"m\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* NgZone */ \"F\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_MAT_INK_BAR_POSITIONER), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_6__[/* ANIMATION_MODULE_TYPE */ \"a\"], 8)); };\n    MatInkBar.ɵdir = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdefineDirective */ \"Ob\"]({ type: MatInkBar, selectors: [[\"mat-ink-bar\"]], hostAttrs: [1, \"mat-ink-bar\"], hostVars: 2, hostBindings: function MatInkBar_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵclassProp */ \"Lb\"](\"_mat-animation-noopable\", ctx._animationMode === \"NoopAnimations\");\n            }\n        } });\n    return MatInkBar;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injection token that can be used to reference instances of `MatTabContent`. It serves as\n * alternative token to the actual `MatTabContent` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nconst MAT_TAB_CONTENT = /*@__PURE__*/ new _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* InjectionToken */ \"u\"]('MatTabContent');\nlet MatTabContent = /*@__PURE__*/ (() => {\n    class MatTabContent {\n        constructor(\n        /** Content for the tab. */ template) {\n            this.template = template;\n        }\n    }\n    MatTabContent.ɵfac = function MatTabContent_Factory(t) { return new (t || MatTabContent)(_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* TemplateRef */ \"R\"])); };\n    MatTabContent.ɵdir = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdefineDirective */ \"Ob\"]({ type: MatTabContent, selectors: [[\"\", \"matTabContent\", \"\"]], features: [/*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵProvidersFeature */ \"Fb\"]([{ provide: MAT_TAB_CONTENT, useExisting: MatTabContent }])] });\n    return MatTabContent;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injection token that can be used to reference instances of `MatTabLabel`. It serves as\n * alternative token to the actual `MatTabLabel` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nconst MAT_TAB_LABEL = /*@__PURE__*/ new _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* InjectionToken */ \"u\"]('MatTabLabel');\nlet MatTabLabel = /*@__PURE__*/ (() => {\n    class MatTabLabel extends _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_2__[/* CdkPortal */ \"b\"] {\n    }\n    MatTabLabel.ɵfac = function MatTabLabel_Factory(t) { return ɵMatTabLabel_BaseFactory(t || MatTabLabel); };\n    MatTabLabel.ɵdir = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdefineDirective */ \"Ob\"]({ type: MatTabLabel, selectors: [[\"\", \"mat-tab-label\", \"\"], [\"\", \"matTabLabel\", \"\"]], features: [/*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵProvidersFeature */ \"Fb\"]([{ provide: MAT_TAB_LABEL, useExisting: MatTabLabel }]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵInheritDefinitionFeature */ \"Db\"]] });\n    return MatTabLabel;\n})();\nconst ɵMatTabLabel_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵgetInheritedFactory */ \"bc\"](MatTabLabel);\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Boilerplate for applying mixins to MatTab.\n/** @docs-private */\nclass MatTabBase {\n}\nconst _MatTabMixinBase = /*@__PURE__*/ Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_5__[/* mixinDisabled */ \"A\"])(MatTabBase);\n/**\n * Used to provide a tab group to a tab without causing a circular dependency.\n * @docs-private\n */\nconst MAT_TAB_GROUP = /*@__PURE__*/ new _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* InjectionToken */ \"u\"]('MAT_TAB_GROUP');\nlet MatTab = /*@__PURE__*/ (() => {\n    class MatTab extends _MatTabMixinBase {\n        constructor(_viewContainerRef, _closestTabGroup) {\n            super();\n            this._viewContainerRef = _viewContainerRef;\n            this._closestTabGroup = _closestTabGroup;\n            /** Plain text label for the tab, used when there is no template label. */\n            this.textLabel = '';\n            /** Portal that will be the hosted content of the tab */\n            this._contentPortal = null;\n            /** Emits whenever the internal state of the tab changes. */\n            this._stateChanges = new rxjs__WEBPACK_IMPORTED_MODULE_7__[/* Subject */ \"a\"]();\n            /**\n             * The relatively indexed position where 0 represents the center, negative is left, and positive\n             * represents the right.\n             */\n            this.position = null;\n            /**\n             * The initial relatively index origin of the tab if it was created and selected after there\n             * was already a selected tab. Provides context of what position the tab should originate from.\n             */\n            this.origin = null;\n            /**\n             * Whether the tab is currently active.\n             */\n            this.isActive = false;\n        }\n        /** Content for the tab label given by `<ng-template mat-tab-label>`. */\n        get templateLabel() { return this._templateLabel; }\n        set templateLabel(value) { this._setTemplateLabelInput(value); }\n        /** @docs-private */\n        get content() {\n            return this._contentPortal;\n        }\n        ngOnChanges(changes) {\n            if (changes.hasOwnProperty('textLabel') || changes.hasOwnProperty('disabled')) {\n                this._stateChanges.next();\n            }\n        }\n        ngOnDestroy() {\n            this._stateChanges.complete();\n        }\n        ngOnInit() {\n            this._contentPortal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_2__[/* TemplatePortal */ \"g\"](this._explicitContent || this._implicitContent, this._viewContainerRef);\n        }\n        /**\n         * This has been extracted to a util because of TS 4 and VE.\n         * View Engine doesn't support property rename inheritance.\n         * TS 4.0 doesn't allow properties to override accessors or vice-versa.\n         * @docs-private\n         */\n        _setTemplateLabelInput(value) {\n            // Only update the templateLabel via query if there is actually\n            // a MatTabLabel found. This works around an issue where a user may have\n            // manually set `templateLabel` during creation mode, which would then get clobbered\n            // by `undefined` when this query resolves.\n            if (value) {\n                this._templateLabel = value;\n            }\n        }\n    }\n    MatTab.ɵfac = function MatTab_Factory(t) { return new (t || MatTab)(_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ViewContainerRef */ \"V\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](MAT_TAB_GROUP)); };\n    MatTab.ɵcmp = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdefineComponent */ \"Nb\"]({ type: MatTab, selectors: [[\"mat-tab\"]], contentQueries: function MatTab_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵcontentQuery */ \"Mb\"](dirIndex, MAT_TAB_LABEL, true);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵstaticContentQuery */ \"Mc\"](dirIndex, MAT_TAB_CONTENT, true, _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* TemplateRef */ \"R\"]);\n            }\n            if (rf & 2) {\n                let _t;\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵqueryRefresh */ \"Fc\"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵloadQuery */ \"kc\"]()) && (ctx.templateLabel = _t.first);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵqueryRefresh */ \"Fc\"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵloadQuery */ \"kc\"]()) && (ctx._explicitContent = _t.first);\n            }\n        }, viewQuery: function MatTab_Query(rf, ctx) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵstaticViewQuery */ \"Nc\"](_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* TemplateRef */ \"R\"], true);\n            }\n            if (rf & 2) {\n                let _t;\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵqueryRefresh */ \"Fc\"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵloadQuery */ \"kc\"]()) && (ctx._implicitContent = _t.first);\n            }\n        }, inputs: { disabled: \"disabled\", textLabel: [\"label\", \"textLabel\"], ariaLabel: [\"aria-label\", \"ariaLabel\"], ariaLabelledby: [\"aria-labelledby\", \"ariaLabelledby\"] }, exportAs: [\"matTab\"], features: [_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵInheritDefinitionFeature */ \"Db\"], _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵNgOnChangesFeature */ \"Eb\"]], ngContentSelectors: _c0, decls: 1, vars: 0, template: function MatTab_Template(rf, ctx) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵprojectionDef */ \"sc\"]();\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵtemplate */ \"Sc\"](0, MatTab_ng_template_0_Template, 1, 0, \"ng-template\");\n            }\n        }, encapsulation: 2 });\n    return MatTab;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Animations used by the Material tabs.\n * @docs-private\n */\nconst matTabsAnimations = {\n    /** Animation translates a tab along the X axis. */\n    translateTab: /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_13__[/* trigger */ \"n\"])('translateTab', [\n        // Note: transitions to `none` instead of 0, because some browsers might blur the content.\n        /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_13__[/* state */ \"k\"])('center, void, left-origin-center, right-origin-center', /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_13__[/* style */ \"l\"])({ transform: 'none' })),\n        // If the tab is either on the left or right, we additionally add a `min-height` of 1px\n        // in order to ensure that the element has a height before its state changes. This is\n        // necessary because Chrome does seem to skip the transition in RTL mode if the element does\n        // not have a static height and is not rendered. See related issue: #9465\n        /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_13__[/* state */ \"k\"])('left', /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_13__[/* style */ \"l\"])({ transform: 'translate3d(-100%, 0, 0)', minHeight: '1px' })),\n        /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_13__[/* state */ \"k\"])('right', /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_13__[/* style */ \"l\"])({ transform: 'translate3d(100%, 0, 0)', minHeight: '1px' })),\n        /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_13__[/* transition */ \"m\"])('* => left, * => right, left => center, right => center', /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_13__[/* animate */ \"e\"])('{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)')),\n        /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_13__[/* transition */ \"m\"])('void => left-origin-center', [\n            /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_13__[/* style */ \"l\"])({ transform: 'translate3d(-100%, 0, 0)' }),\n            /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_13__[/* animate */ \"e\"])('{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)')\n        ]),\n        /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_13__[/* transition */ \"m\"])('void => right-origin-center', [\n            /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_13__[/* style */ \"l\"])({ transform: 'translate3d(100%, 0, 0)' }),\n            /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_13__[/* animate */ \"e\"])('{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)')\n        ])\n    ])\n};\nlet MatTabBodyPortal = /*@__PURE__*/ (() => {\n    class MatTabBodyPortal extends _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_2__[/* CdkPortalOutlet */ \"c\"] {\n        constructor(componentFactoryResolver, viewContainerRef, _host, _document) {\n            super(componentFactoryResolver, viewContainerRef, _document);\n            this._host = _host;\n            /** Subscription to events for when the tab body begins centering. */\n            this._centeringSub = rxjs__WEBPACK_IMPORTED_MODULE_8__[/* Subscription */ \"a\"].EMPTY;\n            /** Subscription to events for when the tab body finishes leaving from center position. */\n            this._leavingSub = rxjs__WEBPACK_IMPORTED_MODULE_8__[/* Subscription */ \"a\"].EMPTY;\n        }\n        /** Set initial visibility or set up subscription for changing visibility. */\n        ngOnInit() {\n            super.ngOnInit();\n            this._centeringSub = this._host._beforeCentering\n                .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__[/* startWith */ \"a\"])(this._host._isCenterPosition(this._host._position)))\n                .subscribe((isCentering) => {\n                if (isCentering && !this.hasAttached()) {\n                    this.attach(this._host._content);\n                }\n            });\n            this._leavingSub = this._host._afterLeavingCenter.subscribe(() => {\n                this.detach();\n            });\n        }\n        /** Clean up centering subscription. */\n        ngOnDestroy() {\n            super.ngOnDestroy();\n            this._centeringSub.unsubscribe();\n            this._leavingSub.unsubscribe();\n        }\n    }\n    MatTabBodyPortal.ɵfac = function MatTabBodyPortal_Factory(t) { return new (t || MatTabBodyPortal)(_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ComponentFactoryResolver */ \"k\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ViewContainerRef */ \"V\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](Object(_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* forwardRef */ \"Z\"])(() => MatTabBody)), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_common__WEBPACK_IMPORTED_MODULE_3__[/* DOCUMENT */ \"d\"])); };\n    MatTabBodyPortal.ɵdir = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdefineDirective */ \"Ob\"]({ type: MatTabBodyPortal, selectors: [[\"\", \"matTabBodyHost\", \"\"]], features: [_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵInheritDefinitionFeature */ \"Db\"]] });\n    return MatTabBodyPortal;\n})();\nlet _MatTabBodyBase = /*@__PURE__*/ (() => {\n    class _MatTabBodyBase {\n        constructor(_elementRef, _dir, changeDetectorRef) {\n            this._elementRef = _elementRef;\n            this._dir = _dir;\n            /** Subscription to the directionality change observable. */\n            this._dirChangeSubscription = rxjs__WEBPACK_IMPORTED_MODULE_8__[/* Subscription */ \"a\"].EMPTY;\n            /** Emits when an animation on the tab is complete. */\n            this._translateTabComplete = new rxjs__WEBPACK_IMPORTED_MODULE_7__[/* Subject */ \"a\"]();\n            /** Event emitted when the tab begins to animate towards the center as the active tab. */\n            this._onCentering = new _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* EventEmitter */ \"p\"]();\n            /** Event emitted before the centering of the tab begins. */\n            this._beforeCentering = new _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* EventEmitter */ \"p\"]();\n            /** Event emitted before the centering of the tab begins. */\n            this._afterLeavingCenter = new _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* EventEmitter */ \"p\"]();\n            /** Event emitted when the tab completes its animation towards the center. */\n            this._onCentered = new _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* EventEmitter */ \"p\"](true);\n            // Note that the default value will always be overwritten by `MatTabBody`, but we need one\n            // anyway to prevent the animations module from throwing an error if the body is used on its own.\n            /** Duration for the tab's animation. */\n            this.animationDuration = '500ms';\n            if (_dir) {\n                this._dirChangeSubscription = _dir.change.subscribe((dir) => {\n                    this._computePositionAnimationState(dir);\n                    changeDetectorRef.markForCheck();\n                });\n            }\n            // Ensure that we get unique animation events, because the `.done` callback can get\n            // invoked twice in some browsers. See https://github.com/angular/angular/issues/24084.\n            this._translateTabComplete.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_15__[/* distinctUntilChanged */ \"a\"])((x, y) => {\n                return x.fromState === y.fromState && x.toState === y.toState;\n            })).subscribe(event => {\n                // If the transition to the center is complete, emit an event.\n                if (this._isCenterPosition(event.toState) && this._isCenterPosition(this._position)) {\n                    this._onCentered.emit();\n                }\n                if (this._isCenterPosition(event.fromState) && !this._isCenterPosition(this._position)) {\n                    this._afterLeavingCenter.emit();\n                }\n            });\n        }\n        /** The shifted index position of the tab body, where zero represents the active center tab. */\n        set position(position) {\n            this._positionIndex = position;\n            this._computePositionAnimationState();\n        }\n        /**\n         * After initialized, check if the content is centered and has an origin. If so, set the\n         * special position states that transition the tab from the left or right before centering.\n         */\n        ngOnInit() {\n            if (this._position == 'center' && this.origin != null) {\n                this._position = this._computePositionFromOrigin(this.origin);\n            }\n        }\n        ngOnDestroy() {\n            this._dirChangeSubscription.unsubscribe();\n            this._translateTabComplete.complete();\n        }\n        _onTranslateTabStarted(event) {\n            const isCentering = this._isCenterPosition(event.toState);\n            this._beforeCentering.emit(isCentering);\n            if (isCentering) {\n                this._onCentering.emit(this._elementRef.nativeElement.clientHeight);\n            }\n        }\n        /** The text direction of the containing app. */\n        _getLayoutDirection() {\n            return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n        }\n        /** Whether the provided position state is considered center, regardless of origin. */\n        _isCenterPosition(position) {\n            return position == 'center' ||\n                position == 'left-origin-center' ||\n                position == 'right-origin-center';\n        }\n        /** Computes the position state that will be used for the tab-body animation trigger. */\n        _computePositionAnimationState(dir = this._getLayoutDirection()) {\n            if (this._positionIndex < 0) {\n                this._position = dir == 'ltr' ? 'left' : 'right';\n            }\n            else if (this._positionIndex > 0) {\n                this._position = dir == 'ltr' ? 'right' : 'left';\n            }\n            else {\n                this._position = 'center';\n            }\n        }\n        /**\n         * Computes the position state based on the specified origin position. This is used if the\n         * tab is becoming visible immediately after creation.\n         */\n        _computePositionFromOrigin(origin) {\n            const dir = this._getLayoutDirection();\n            if ((dir == 'ltr' && origin <= 0) || (dir == 'rtl' && origin > 0)) {\n                return 'left-origin-center';\n            }\n            return 'right-origin-center';\n        }\n    }\n    _MatTabBodyBase.ɵfac = function _MatTabBodyBase_Factory(t) { return new (t || _MatTabBodyBase)(_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ElementRef */ \"m\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_20__[/* Directionality */ \"b\"], 8), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ChangeDetectorRef */ \"i\"])); };\n    _MatTabBodyBase.ɵdir = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdefineDirective */ \"Ob\"]({ type: _MatTabBodyBase, inputs: { animationDuration: \"animationDuration\", position: \"position\", _content: [\"content\", \"_content\"], origin: \"origin\" }, outputs: { _onCentering: \"_onCentering\", _beforeCentering: \"_beforeCentering\", _afterLeavingCenter: \"_afterLeavingCenter\", _onCentered: \"_onCentered\" } });\n    return _MatTabBodyBase;\n})();\nlet MatTabBody = /*@__PURE__*/ (() => {\n    class MatTabBody extends _MatTabBodyBase {\n        constructor(elementRef, dir, changeDetectorRef) {\n            super(elementRef, dir, changeDetectorRef);\n        }\n    }\n    MatTabBody.ɵfac = function MatTabBody_Factory(t) { return new (t || MatTabBody)(_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ElementRef */ \"m\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_20__[/* Directionality */ \"b\"], 8), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ChangeDetectorRef */ \"i\"])); };\n    MatTabBody.ɵcmp = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdefineComponent */ \"Nb\"]({ type: MatTabBody, selectors: [[\"mat-tab-body\"]], viewQuery: function MatTabBody_Query(rf, ctx) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵviewQuery */ \"Zc\"](_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_2__[/* CdkPortalOutlet */ \"c\"], true);\n            }\n            if (rf & 2) {\n                let _t;\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵqueryRefresh */ \"Fc\"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵloadQuery */ \"kc\"]()) && (ctx._portalHost = _t.first);\n            }\n        }, hostAttrs: [1, \"mat-tab-body\"], features: [_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵInheritDefinitionFeature */ \"Db\"]], decls: 3, vars: 6, consts: [[\"cdkScrollable\", \"\", 1, \"mat-tab-body-content\"], [\"content\", \"\"], [\"matTabBodyHost\", \"\"]], template: function MatTabBody_Template(rf, ctx) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelementStart */ \"Zb\"](0, \"div\", 0, 1);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵlistener */ \"jc\"](\"@translateTab.start\", function MatTabBody_Template_div_animation_translateTab_start_0_listener($event) { return ctx._onTranslateTabStarted($event); })(\"@translateTab.done\", function MatTabBody_Template_div_animation_translateTab_done_0_listener($event) { return ctx._translateTabComplete.next($event); });\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵtemplate */ \"Sc\"](2, MatTabBody_ng_template_2_Template, 0, 0, \"ng-template\", 2);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelementEnd */ \"Yb\"]();\n            }\n            if (rf & 2) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵproperty */ \"tc\"](\"@translateTab\", _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵpureFunction2 */ \"yc\"](3, _c2, ctx._position, _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵpureFunction1 */ \"xc\"](1, _c1, ctx.animationDuration)));\n            }\n        }, directives: [MatTabBodyPortal], styles: [\".mat-tab-body-content{height:100%;overflow:auto}.mat-tab-group-dynamic-height .mat-tab-body-content{overflow:hidden}\\n\"], encapsulation: 2, data: { animation: [matTabsAnimations.translateTab] } });\n    return MatTabBody;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Injection token that can be used to provide the default options the tabs module. */\nconst MAT_TABS_CONFIG = /*@__PURE__*/ new _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* InjectionToken */ \"u\"]('MAT_TABS_CONFIG');\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Used to generate unique ID's for each tab component */\nlet nextId = 0;\n/** A simple change event emitted on focus or selection changes. */\nclass MatTabChangeEvent {\n}\n// Boilerplate for applying mixins to MatTabGroup.\n/** @docs-private */\nclass MatTabGroupMixinBase {\n    constructor(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n}\nconst _MatTabGroupMixinBase = /*@__PURE__*/ Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_5__[/* mixinColor */ \"y\"])(/*@__PURE__*/ Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_5__[/* mixinDisableRipple */ \"z\"])(MatTabGroupMixinBase), 'primary');\nlet _MatTabGroupBase = /*@__PURE__*/ (() => {\n    class _MatTabGroupBase extends _MatTabGroupMixinBase {\n        constructor(elementRef, _changeDetectorRef, defaultConfig, _animationMode) {\n            super(elementRef);\n            this._changeDetectorRef = _changeDetectorRef;\n            this._animationMode = _animationMode;\n            /** All of the tabs that belong to the group. */\n            this._tabs = new _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* QueryList */ \"J\"]();\n            /** The tab index that should be selected after the content has been checked. */\n            this._indexToSelect = 0;\n            /** Snapshot of the height of the tab body wrapper before another tab is activated. */\n            this._tabBodyWrapperHeight = 0;\n            /** Subscription to tabs being added/removed. */\n            this._tabsSubscription = rxjs__WEBPACK_IMPORTED_MODULE_8__[/* Subscription */ \"a\"].EMPTY;\n            /** Subscription to changes in the tab labels. */\n            this._tabLabelSubscription = rxjs__WEBPACK_IMPORTED_MODULE_8__[/* Subscription */ \"a\"].EMPTY;\n            this._selectedIndex = null;\n            /** Position of the tab header. */\n            this.headerPosition = 'above';\n            /** Output to enable support for two-way binding on `[(selectedIndex)]` */\n            this.selectedIndexChange = new _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* EventEmitter */ \"p\"]();\n            /** Event emitted when focus has changed within a tab group. */\n            this.focusChange = new _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* EventEmitter */ \"p\"]();\n            /** Event emitted when the body animation has completed */\n            this.animationDone = new _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* EventEmitter */ \"p\"]();\n            /** Event emitted when the tab selection has changed. */\n            this.selectedTabChange = new _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* EventEmitter */ \"p\"](true);\n            this._groupId = nextId++;\n            this.animationDuration = defaultConfig && defaultConfig.animationDuration ?\n                defaultConfig.animationDuration : '500ms';\n            this.disablePagination = defaultConfig && defaultConfig.disablePagination != null ?\n                defaultConfig.disablePagination : false;\n            this.dynamicHeight = defaultConfig && defaultConfig.dynamicHeight != null ?\n                defaultConfig.dynamicHeight : false;\n        }\n        /** Whether the tab group should grow to the size of the active tab. */\n        get dynamicHeight() { return this._dynamicHeight; }\n        set dynamicHeight(value) { this._dynamicHeight = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_17__[/* coerceBooleanProperty */ \"c\"])(value); }\n        /** The index of the active tab. */\n        get selectedIndex() { return this._selectedIndex; }\n        set selectedIndex(value) {\n            this._indexToSelect = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_17__[/* coerceNumberProperty */ \"f\"])(value, null);\n        }\n        /** Duration for the tab animation. Will be normalized to milliseconds if no units are set. */\n        get animationDuration() { return this._animationDuration; }\n        set animationDuration(value) {\n            this._animationDuration = /^\\d+$/.test(value) ? value + 'ms' : value;\n        }\n        /** Background color of the tab group. */\n        get backgroundColor() { return this._backgroundColor; }\n        set backgroundColor(value) {\n            const nativeElement = this._elementRef.nativeElement;\n            nativeElement.classList.remove(`mat-background-${this.backgroundColor}`);\n            if (value) {\n                nativeElement.classList.add(`mat-background-${value}`);\n            }\n            this._backgroundColor = value;\n        }\n        /**\n         * After the content is checked, this component knows what tabs have been defined\n         * and what the selected index should be. This is where we can know exactly what position\n         * each tab should be in according to the new selected index, and additionally we know how\n         * a new selected tab should transition in (from the left or right).\n         */\n        ngAfterContentChecked() {\n            // Don't clamp the `indexToSelect` immediately in the setter because it can happen that\n            // the amount of tabs changes before the actual change detection runs.\n            const indexToSelect = this._indexToSelect = this._clampTabIndex(this._indexToSelect);\n            // If there is a change in selected index, emit a change event. Should not trigger if\n            // the selected index has not yet been initialized.\n            if (this._selectedIndex != indexToSelect) {\n                const isFirstRun = this._selectedIndex == null;\n                if (!isFirstRun) {\n                    this.selectedTabChange.emit(this._createChangeEvent(indexToSelect));\n                    // Preserve the height so page doesn't scroll up during tab change.\n                    // Fixes https://stackblitz.com/edit/mat-tabs-scroll-page-top-on-tab-change\n                    const wrapper = this._tabBodyWrapper.nativeElement;\n                    wrapper.style.minHeight = wrapper.clientHeight + 'px';\n                }\n                // Changing these values after change detection has run\n                // since the checked content may contain references to them.\n                Promise.resolve().then(() => {\n                    this._tabs.forEach((tab, index) => tab.isActive = index === indexToSelect);\n                    if (!isFirstRun) {\n                        this.selectedIndexChange.emit(indexToSelect);\n                        // Clear the min-height, this was needed during tab change to avoid\n                        // unnecessary scrolling.\n                        this._tabBodyWrapper.nativeElement.style.minHeight = '';\n                    }\n                });\n            }\n            // Setup the position for each tab and optionally setup an origin on the next selected tab.\n            this._tabs.forEach((tab, index) => {\n                tab.position = index - indexToSelect;\n                // If there is already a selected tab, then set up an origin for the next selected tab\n                // if it doesn't have one already.\n                if (this._selectedIndex != null && tab.position == 0 && !tab.origin) {\n                    tab.origin = indexToSelect - this._selectedIndex;\n                }\n            });\n            if (this._selectedIndex !== indexToSelect) {\n                this._selectedIndex = indexToSelect;\n                this._changeDetectorRef.markForCheck();\n            }\n        }\n        ngAfterContentInit() {\n            this._subscribeToAllTabChanges();\n            this._subscribeToTabLabels();\n            // Subscribe to changes in the amount of tabs, in order to be\n            // able to re-render the content as new tabs are added or removed.\n            this._tabsSubscription = this._tabs.changes.subscribe(() => {\n                const indexToSelect = this._clampTabIndex(this._indexToSelect);\n                // Maintain the previously-selected tab if a new tab is added or removed and there is no\n                // explicit change that selects a different tab.\n                if (indexToSelect === this._selectedIndex) {\n                    const tabs = this._tabs.toArray();\n                    for (let i = 0; i < tabs.length; i++) {\n                        if (tabs[i].isActive) {\n                            // Assign both to the `_indexToSelect` and `_selectedIndex` so we don't fire a changed\n                            // event, otherwise the consumer may end up in an infinite loop in some edge cases like\n                            // adding a tab within the `selectedIndexChange` event.\n                            this._indexToSelect = this._selectedIndex = i;\n                            break;\n                        }\n                    }\n                }\n                this._changeDetectorRef.markForCheck();\n            });\n        }\n        /** Listens to changes in all of the tabs. */\n        _subscribeToAllTabChanges() {\n            // Since we use a query with `descendants: true` to pick up the tabs, we may end up catching\n            // some that are inside of nested tab groups. We filter them out manually by checking that\n            // the closest group to the tab is the current one.\n            this._allTabs.changes\n                .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__[/* startWith */ \"a\"])(this._allTabs))\n                .subscribe((tabs) => {\n                this._tabs.reset(tabs.filter(tab => tab._closestTabGroup === this));\n                this._tabs.notifyOnChanges();\n            });\n        }\n        ngOnDestroy() {\n            this._tabs.destroy();\n            this._tabsSubscription.unsubscribe();\n            this._tabLabelSubscription.unsubscribe();\n        }\n        /** Re-aligns the ink bar to the selected tab element. */\n        realignInkBar() {\n            if (this._tabHeader) {\n                this._tabHeader._alignInkBarToSelectedTab();\n            }\n        }\n        _focusChanged(index) {\n            this.focusChange.emit(this._createChangeEvent(index));\n        }\n        _createChangeEvent(index) {\n            const event = new MatTabChangeEvent;\n            event.index = index;\n            if (this._tabs && this._tabs.length) {\n                event.tab = this._tabs.toArray()[index];\n            }\n            return event;\n        }\n        /**\n         * Subscribes to changes in the tab labels. This is needed, because the @Input for the label is\n         * on the MatTab component, whereas the data binding is inside the MatTabGroup. In order for the\n         * binding to be updated, we need to subscribe to changes in it and trigger change detection\n         * manually.\n         */\n        _subscribeToTabLabels() {\n            if (this._tabLabelSubscription) {\n                this._tabLabelSubscription.unsubscribe();\n            }\n            this._tabLabelSubscription = Object(rxjs__WEBPACK_IMPORTED_MODULE_9__[/* merge */ \"a\"])(...this._tabs.map(tab => tab._stateChanges))\n                .subscribe(() => this._changeDetectorRef.markForCheck());\n        }\n        /** Clamps the given index to the bounds of 0 and the tabs length. */\n        _clampTabIndex(index) {\n            // Note the `|| 0`, which ensures that values like NaN can't get through\n            // and which would otherwise throw the component into an infinite loop\n            // (since Math.max(NaN, 0) === NaN).\n            return Math.min(this._tabs.length - 1, Math.max(index || 0, 0));\n        }\n        /** Returns a unique id for each tab label element */\n        _getTabLabelId(i) {\n            return `mat-tab-label-${this._groupId}-${i}`;\n        }\n        /** Returns a unique id for each tab content element */\n        _getTabContentId(i) {\n            return `mat-tab-content-${this._groupId}-${i}`;\n        }\n        /**\n         * Sets the height of the body wrapper to the height of the activating tab if dynamic\n         * height property is true.\n         */\n        _setTabBodyWrapperHeight(tabHeight) {\n            if (!this._dynamicHeight || !this._tabBodyWrapperHeight) {\n                return;\n            }\n            const wrapper = this._tabBodyWrapper.nativeElement;\n            wrapper.style.height = this._tabBodyWrapperHeight + 'px';\n            // This conditional forces the browser to paint the height so that\n            // the animation to the new height can have an origin.\n            if (this._tabBodyWrapper.nativeElement.offsetHeight) {\n                wrapper.style.height = tabHeight + 'px';\n            }\n        }\n        /** Removes the height of the tab body wrapper. */\n        _removeTabBodyWrapperHeight() {\n            const wrapper = this._tabBodyWrapper.nativeElement;\n            this._tabBodyWrapperHeight = wrapper.clientHeight;\n            wrapper.style.height = '';\n            this.animationDone.emit();\n        }\n        /** Handle click events, setting new selected index if appropriate. */\n        _handleClick(tab, tabHeader, index) {\n            if (!tab.disabled) {\n                this.selectedIndex = tabHeader.focusIndex = index;\n            }\n        }\n        /** Retrieves the tabindex for the tab. */\n        _getTabIndex(tab, idx) {\n            if (tab.disabled) {\n                return null;\n            }\n            return this.selectedIndex === idx ? 0 : -1;\n        }\n        /** Callback for when the focused state of a tab has changed. */\n        _tabFocusChanged(focusOrigin, index) {\n            if (focusOrigin) {\n                this._tabHeader.focusIndex = index;\n            }\n        }\n    }\n    _MatTabGroupBase.ɵfac = function _MatTabGroupBase_Factory(t) { return new (t || _MatTabGroupBase)(_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ElementRef */ \"m\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ChangeDetectorRef */ \"i\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](MAT_TABS_CONFIG, 8), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_6__[/* ANIMATION_MODULE_TYPE */ \"a\"], 8)); };\n    _MatTabGroupBase.ɵdir = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdefineDirective */ \"Ob\"]({ type: _MatTabGroupBase, inputs: { headerPosition: \"headerPosition\", animationDuration: \"animationDuration\", disablePagination: \"disablePagination\", dynamicHeight: \"dynamicHeight\", selectedIndex: \"selectedIndex\", backgroundColor: \"backgroundColor\" }, outputs: { selectedIndexChange: \"selectedIndexChange\", focusChange: \"focusChange\", animationDone: \"animationDone\", selectedTabChange: \"selectedTabChange\" }, features: [_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵInheritDefinitionFeature */ \"Db\"]] });\n    return _MatTabGroupBase;\n})();\nlet MatTabGroup = /*@__PURE__*/ (() => {\n    class MatTabGroup extends _MatTabGroupBase {\n        constructor(elementRef, changeDetectorRef, defaultConfig, animationMode) {\n            super(elementRef, changeDetectorRef, defaultConfig, animationMode);\n        }\n    }\n    MatTabGroup.ɵfac = function MatTabGroup_Factory(t) { return new (t || MatTabGroup)(_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ElementRef */ \"m\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ChangeDetectorRef */ \"i\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](MAT_TABS_CONFIG, 8), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_6__[/* ANIMATION_MODULE_TYPE */ \"a\"], 8)); };\n    MatTabGroup.ɵcmp = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdefineComponent */ \"Nb\"]({ type: MatTabGroup, selectors: [[\"mat-tab-group\"]], contentQueries: function MatTabGroup_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵcontentQuery */ \"Mb\"](dirIndex, MatTab, true);\n            }\n            if (rf & 2) {\n                let _t;\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵqueryRefresh */ \"Fc\"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵloadQuery */ \"kc\"]()) && (ctx._allTabs = _t);\n            }\n        }, viewQuery: function MatTabGroup_Query(rf, ctx) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵviewQuery */ \"Zc\"](_c3, true);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵviewQuery */ \"Zc\"](_c4, true);\n            }\n            if (rf & 2) {\n                let _t;\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵqueryRefresh */ \"Fc\"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵloadQuery */ \"kc\"]()) && (ctx._tabBodyWrapper = _t.first);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵqueryRefresh */ \"Fc\"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵloadQuery */ \"kc\"]()) && (ctx._tabHeader = _t.first);\n            }\n        }, hostAttrs: [1, \"mat-tab-group\"], hostVars: 4, hostBindings: function MatTabGroup_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵclassProp */ \"Lb\"](\"mat-tab-group-dynamic-height\", ctx.dynamicHeight)(\"mat-tab-group-inverted-header\", ctx.headerPosition === \"below\");\n            }\n        }, inputs: { color: \"color\", disableRipple: \"disableRipple\" }, exportAs: [\"matTabGroup\"], features: [/*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵProvidersFeature */ \"Fb\"]([{\n                    provide: MAT_TAB_GROUP,\n                    useExisting: MatTabGroup\n                }]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵInheritDefinitionFeature */ \"Db\"]], decls: 6, vars: 7, consts: [[3, \"selectedIndex\", \"disableRipple\", \"disablePagination\", \"indexFocused\", \"selectFocusedIndex\"], [\"tabHeader\", \"\"], [\"class\", \"mat-tab-label mat-focus-indicator\", \"role\", \"tab\", \"matTabLabelWrapper\", \"\", \"mat-ripple\", \"\", \"cdkMonitorElementFocus\", \"\", 3, \"id\", \"mat-tab-label-active\", \"disabled\", \"matRippleDisabled\", \"click\", \"cdkFocusChange\", 4, \"ngFor\", \"ngForOf\"], [1, \"mat-tab-body-wrapper\"], [\"tabBodyWrapper\", \"\"], [\"role\", \"tabpanel\", 3, \"id\", \"mat-tab-body-active\", \"content\", \"position\", \"origin\", \"animationDuration\", \"_onCentered\", \"_onCentering\", 4, \"ngFor\", \"ngForOf\"], [\"role\", \"tab\", \"matTabLabelWrapper\", \"\", \"mat-ripple\", \"\", \"cdkMonitorElementFocus\", \"\", 1, \"mat-tab-label\", \"mat-focus-indicator\", 3, \"id\", \"disabled\", \"matRippleDisabled\", \"click\", \"cdkFocusChange\"], [1, \"mat-tab-label-content\"], [3, \"ngIf\"], [3, \"cdkPortalOutlet\"], [\"role\", \"tabpanel\", 3, \"id\", \"content\", \"position\", \"origin\", \"animationDuration\", \"_onCentered\", \"_onCentering\"]], template: function MatTabGroup_Template(rf, ctx) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelementStart */ \"Zb\"](0, \"mat-tab-header\", 0, 1);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵlistener */ \"jc\"](\"indexFocused\", function MatTabGroup_Template_mat_tab_header_indexFocused_0_listener($event) { return ctx._focusChanged($event); })(\"selectFocusedIndex\", function MatTabGroup_Template_mat_tab_header_selectFocusedIndex_0_listener($event) { return ctx.selectedIndex = $event; });\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵtemplate */ \"Sc\"](2, MatTabGroup_div_2_Template, 4, 14, \"div\", 2);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelementEnd */ \"Yb\"]();\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelementStart */ \"Zb\"](3, \"div\", 3, 4);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵtemplate */ \"Sc\"](5, MatTabGroup_mat_tab_body_5_Template, 1, 8, \"mat-tab-body\", 5);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelementEnd */ \"Yb\"]();\n            }\n            if (rf & 2) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵproperty */ \"tc\"](\"selectedIndex\", ctx.selectedIndex || 0)(\"disableRipple\", ctx.disableRipple)(\"disablePagination\", ctx.disablePagination);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵadvance */ \"Gb\"](2);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵproperty */ \"tc\"](\"ngForOf\", ctx._tabs);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵadvance */ \"Gb\"](1);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵclassProp */ \"Lb\"](\"_mat-animation-noopable\", ctx._animationMode === \"NoopAnimations\");\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵadvance */ \"Gb\"](2);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵproperty */ \"tc\"](\"ngForOf\", ctx._tabs);\n            }\n        }, directives: function () { return [MatTabHeader, _angular_common__WEBPACK_IMPORTED_MODULE_3__[/* NgForOf */ \"m\"], MatTabLabelWrapper, _angular_material_core__WEBPACK_IMPORTED_MODULE_5__[/* MatRipple */ \"t\"], _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__[/* CdkMonitorFocus */ \"e\"], _angular_common__WEBPACK_IMPORTED_MODULE_3__[/* NgIf */ \"n\"], _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_2__[/* CdkPortalOutlet */ \"c\"], MatTabBody]; }, styles: [\".mat-tab-group{display:flex;flex-direction:column}.mat-tab-group.mat-tab-group-inverted-header{flex-direction:column-reverse}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:none}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}.cdk-high-contrast-active .mat-tab-label:focus{outline:dotted 2px;outline-offset:-2px}.mat-tab-label.mat-tab-disabled{cursor:default}.cdk-high-contrast-active .mat-tab-label.mat-tab-disabled{opacity:.5}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.cdk-high-contrast-active .mat-tab-label{opacity:1}@media(max-width: 599px){.mat-tab-label{padding:0 12px}}@media(max-width: 959px){.mat-tab-label{padding:0 12px}}.mat-tab-group[mat-stretch-tabs]>.mat-tab-header .mat-tab-label{flex-basis:0;flex-grow:1}.mat-tab-body-wrapper{position:relative;overflow:hidden;display:flex;transition:height 500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-tab-body-wrapper{transition:none;animation:none}.mat-tab-body{top:0;left:0;right:0;bottom:0;position:absolute;display:block;overflow:hidden;flex-basis:100%}.mat-tab-body.mat-tab-body-active{position:relative;overflow-x:hidden;overflow-y:auto;z-index:1;flex-grow:1}.mat-tab-group.mat-tab-group-dynamic-height .mat-tab-body.mat-tab-body-active{overflow-y:hidden}\\n\"], encapsulation: 2 });\n    return MatTabGroup;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Boilerplate for applying mixins to MatTabLabelWrapper.\n/** @docs-private */\nclass MatTabLabelWrapperBase {\n}\nconst _MatTabLabelWrapperMixinBase = /*@__PURE__*/ Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_5__[/* mixinDisabled */ \"A\"])(MatTabLabelWrapperBase);\nlet MatTabLabelWrapper = /*@__PURE__*/ (() => {\n    class MatTabLabelWrapper extends _MatTabLabelWrapperMixinBase {\n        constructor(elementRef) {\n            super();\n            this.elementRef = elementRef;\n        }\n        /** Sets focus on the wrapper element */\n        focus() {\n            this.elementRef.nativeElement.focus();\n        }\n        getOffsetLeft() {\n            return this.elementRef.nativeElement.offsetLeft;\n        }\n        getOffsetWidth() {\n            return this.elementRef.nativeElement.offsetWidth;\n        }\n    }\n    MatTabLabelWrapper.ɵfac = function MatTabLabelWrapper_Factory(t) { return new (t || MatTabLabelWrapper)(_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ElementRef */ \"m\"])); };\n    MatTabLabelWrapper.ɵdir = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdefineDirective */ \"Ob\"]({ type: MatTabLabelWrapper, selectors: [[\"\", \"matTabLabelWrapper\", \"\"]], hostVars: 3, hostBindings: function MatTabLabelWrapper_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵattribute */ \"Hb\"](\"aria-disabled\", !!ctx.disabled);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵclassProp */ \"Lb\"](\"mat-tab-disabled\", ctx.disabled);\n            }\n        }, inputs: { disabled: \"disabled\" }, features: [_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵInheritDefinitionFeature */ \"Db\"]] });\n    return MatTabLabelWrapper;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Config used to bind passive event listeners */\nconst passiveEventListenerOptions = /*@__PURE__*/ Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_18__[/* normalizePassiveListenerOptions */ \"f\"])({ passive: true });\n/**\n * The distance in pixels that will be overshot when scrolling a tab label into view. This helps\n * provide a small affordance to the label next to it.\n */\nconst EXAGGERATED_OVERSCROLL = 60;\n/**\n * Amount of milliseconds to wait before starting to scroll the header automatically.\n * Set a little conservatively in order to handle fake events dispatched on touch devices.\n */\nconst HEADER_SCROLL_DELAY = 650;\n/**\n * Interval in milliseconds at which to scroll the header\n * while the user is holding their pointer.\n */\nconst HEADER_SCROLL_INTERVAL = 100;\nlet MatPaginatedTabHeader = /*@__PURE__*/ (() => {\n    class MatPaginatedTabHeader {\n        constructor(_elementRef, _changeDetectorRef, _viewportRuler, _dir, _ngZone, _platform, _animationMode) {\n            this._elementRef = _elementRef;\n            this._changeDetectorRef = _changeDetectorRef;\n            this._viewportRuler = _viewportRuler;\n            this._dir = _dir;\n            this._ngZone = _ngZone;\n            this._platform = _platform;\n            this._animationMode = _animationMode;\n            /** The distance in pixels that the tab labels should be translated to the left. */\n            this._scrollDistance = 0;\n            /** Whether the header should scroll to the selected index after the view has been checked. */\n            this._selectedIndexChanged = false;\n            /** Emits when the component is destroyed. */\n            this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_7__[/* Subject */ \"a\"]();\n            /** Whether the controls for pagination should be displayed */\n            this._showPaginationControls = false;\n            /** Whether the tab list can be scrolled more towards the end of the tab label list. */\n            this._disableScrollAfter = true;\n            /** Whether the tab list can be scrolled more towards the beginning of the tab label list. */\n            this._disableScrollBefore = true;\n            /** Stream that will stop the automated scrolling. */\n            this._stopScrolling = new rxjs__WEBPACK_IMPORTED_MODULE_7__[/* Subject */ \"a\"]();\n            /**\n             * Whether pagination should be disabled. This can be used to avoid unnecessary\n             * layout recalculations if it's known that pagination won't be required.\n             */\n            this.disablePagination = false;\n            this._selectedIndex = 0;\n            /** Event emitted when the option is selected. */\n            this.selectFocusedIndex = new _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* EventEmitter */ \"p\"]();\n            /** Event emitted when a label is focused. */\n            this.indexFocused = new _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* EventEmitter */ \"p\"]();\n            // Bind the `mouseleave` event on the outside since it doesn't change anything in the view.\n            _ngZone.runOutsideAngular(() => {\n                Object(rxjs__WEBPACK_IMPORTED_MODULE_10__[/* fromEvent */ \"a\"])(_elementRef.nativeElement, 'mouseleave')\n                    .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_16__[/* takeUntil */ \"a\"])(this._destroyed))\n                    .subscribe(() => {\n                    this._stopInterval();\n                });\n            });\n        }\n        /** The index of the active tab. */\n        get selectedIndex() { return this._selectedIndex; }\n        set selectedIndex(value) {\n            value = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_17__[/* coerceNumberProperty */ \"f\"])(value);\n            if (this._selectedIndex != value) {\n                this._selectedIndexChanged = true;\n                this._selectedIndex = value;\n                if (this._keyManager) {\n                    this._keyManager.updateActiveItem(value);\n                }\n            }\n        }\n        ngAfterViewInit() {\n            // We need to handle these events manually, because we want to bind passive event listeners.\n            Object(rxjs__WEBPACK_IMPORTED_MODULE_10__[/* fromEvent */ \"a\"])(this._previousPaginator.nativeElement, 'touchstart', passiveEventListenerOptions)\n                .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_16__[/* takeUntil */ \"a\"])(this._destroyed))\n                .subscribe(() => {\n                this._handlePaginatorPress('before');\n            });\n            Object(rxjs__WEBPACK_IMPORTED_MODULE_10__[/* fromEvent */ \"a\"])(this._nextPaginator.nativeElement, 'touchstart', passiveEventListenerOptions)\n                .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_16__[/* takeUntil */ \"a\"])(this._destroyed))\n                .subscribe(() => {\n                this._handlePaginatorPress('after');\n            });\n        }\n        ngAfterContentInit() {\n            const dirChange = this._dir ? this._dir.change : Object(rxjs__WEBPACK_IMPORTED_MODULE_11__[/* of */ \"a\"])(null);\n            const resize = this._viewportRuler.change(150);\n            const realign = () => {\n                this.updatePagination();\n                this._alignInkBarToSelectedTab();\n            };\n            this._keyManager = new _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__[/* FocusKeyManager */ \"g\"](this._items)\n                .withHorizontalOrientation(this._getLayoutDirection())\n                .withHomeAndEnd()\n                .withWrap();\n            this._keyManager.updateActiveItem(this._selectedIndex);\n            // Defer the first call in order to allow for slower browsers to lay out the elements.\n            // This helps in cases where the user lands directly on a page with paginated tabs.\n            typeof requestAnimationFrame !== 'undefined' ? requestAnimationFrame(realign) : realign();\n            // On dir change or window resize, realign the ink bar and update the orientation of\n            // the key manager if the direction has changed.\n            Object(rxjs__WEBPACK_IMPORTED_MODULE_9__[/* merge */ \"a\"])(dirChange, resize, this._items.changes).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_16__[/* takeUntil */ \"a\"])(this._destroyed)).subscribe(() => {\n                // We need to defer this to give the browser some time to recalculate\n                // the element dimensions. The call has to be wrapped in `NgZone.run`,\n                // because the viewport change handler runs outside of Angular.\n                this._ngZone.run(() => Promise.resolve().then(realign));\n                this._keyManager.withHorizontalOrientation(this._getLayoutDirection());\n            });\n            // If there is a change in the focus key manager we need to emit the `indexFocused`\n            // event in order to provide a public event that notifies about focus changes. Also we realign\n            // the tabs container by scrolling the new focused tab into the visible section.\n            this._keyManager.change.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_16__[/* takeUntil */ \"a\"])(this._destroyed)).subscribe(newFocusIndex => {\n                this.indexFocused.emit(newFocusIndex);\n                this._setTabFocus(newFocusIndex);\n            });\n        }\n        ngAfterContentChecked() {\n            // If the number of tab labels have changed, check if scrolling should be enabled\n            if (this._tabLabelCount != this._items.length) {\n                this.updatePagination();\n                this._tabLabelCount = this._items.length;\n                this._changeDetectorRef.markForCheck();\n            }\n            // If the selected index has changed, scroll to the label and check if the scrolling controls\n            // should be disabled.\n            if (this._selectedIndexChanged) {\n                this._scrollToLabel(this._selectedIndex);\n                this._checkScrollingControls();\n                this._alignInkBarToSelectedTab();\n                this._selectedIndexChanged = false;\n                this._changeDetectorRef.markForCheck();\n            }\n            // If the scroll distance has been changed (tab selected, focused, scroll controls activated),\n            // then translate the header to reflect this.\n            if (this._scrollDistanceChanged) {\n                this._updateTabScrollPosition();\n                this._scrollDistanceChanged = false;\n                this._changeDetectorRef.markForCheck();\n            }\n        }\n        ngOnDestroy() {\n            this._destroyed.next();\n            this._destroyed.complete();\n            this._stopScrolling.complete();\n        }\n        /** Handles keyboard events on the header. */\n        _handleKeydown(event) {\n            // We don't handle any key bindings with a modifier key.\n            if (Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_19__[/* hasModifierKey */ \"t\"])(event)) {\n                return;\n            }\n            switch (event.keyCode) {\n                case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_19__[/* ENTER */ \"g\"]:\n                case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_19__[/* SPACE */ \"o\"]:\n                    if (this.focusIndex !== this.selectedIndex) {\n                        this.selectFocusedIndex.emit(this.focusIndex);\n                        this._itemSelected(event);\n                    }\n                    break;\n                default:\n                    this._keyManager.onKeydown(event);\n            }\n        }\n        /**\n         * Callback for when the MutationObserver detects that the content has changed.\n         */\n        _onContentChanges() {\n            const textContent = this._elementRef.nativeElement.textContent;\n            // We need to diff the text content of the header, because the MutationObserver callback\n            // will fire even if the text content didn't change which is inefficient and is prone\n            // to infinite loops if a poorly constructed expression is passed in (see #14249).\n            if (textContent !== this._currentTextContent) {\n                this._currentTextContent = textContent || '';\n                // The content observer runs outside the `NgZone` by default, which\n                // means that we need to bring the callback back in ourselves.\n                this._ngZone.run(() => {\n                    this.updatePagination();\n                    this._alignInkBarToSelectedTab();\n                    this._changeDetectorRef.markForCheck();\n                });\n            }\n        }\n        /**\n         * Updates the view whether pagination should be enabled or not.\n         *\n         * WARNING: Calling this method can be very costly in terms of performance. It should be called\n         * as infrequently as possible from outside of the Tabs component as it causes a reflow of the\n         * page.\n         */\n        updatePagination() {\n            this._checkPaginationEnabled();\n            this._checkScrollingControls();\n            this._updateTabScrollPosition();\n        }\n        /** Tracks which element has focus; used for keyboard navigation */\n        get focusIndex() {\n            return this._keyManager ? this._keyManager.activeItemIndex : 0;\n        }\n        /** When the focus index is set, we must manually send focus to the correct label */\n        set focusIndex(value) {\n            if (!this._isValidIndex(value) || this.focusIndex === value || !this._keyManager) {\n                return;\n            }\n            this._keyManager.setActiveItem(value);\n        }\n        /**\n         * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is\n         * providing a valid index and return true.\n         */\n        _isValidIndex(index) {\n            if (!this._items) {\n                return true;\n            }\n            const tab = this._items ? this._items.toArray()[index] : null;\n            return !!tab && !tab.disabled;\n        }\n        /**\n         * Sets focus on the HTML element for the label wrapper and scrolls it into the view if\n         * scrolling is enabled.\n         */\n        _setTabFocus(tabIndex) {\n            if (this._showPaginationControls) {\n                this._scrollToLabel(tabIndex);\n            }\n            if (this._items && this._items.length) {\n                this._items.toArray()[tabIndex].focus();\n                // Do not let the browser manage scrolling to focus the element, this will be handled\n                // by using translation. In LTR, the scroll left should be 0. In RTL, the scroll width\n                // should be the full width minus the offset width.\n                const containerEl = this._tabListContainer.nativeElement;\n                const dir = this._getLayoutDirection();\n                if (dir == 'ltr') {\n                    containerEl.scrollLeft = 0;\n                }\n                else {\n                    containerEl.scrollLeft = containerEl.scrollWidth - containerEl.offsetWidth;\n                }\n            }\n        }\n        /** The layout direction of the containing app. */\n        _getLayoutDirection() {\n            return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n        }\n        /** Performs the CSS transformation on the tab list that will cause the list to scroll. */\n        _updateTabScrollPosition() {\n            if (this.disablePagination) {\n                return;\n            }\n            const scrollDistance = this.scrollDistance;\n            const translateX = this._getLayoutDirection() === 'ltr' ? -scrollDistance : scrollDistance;\n            // Don't use `translate3d` here because we don't want to create a new layer. A new layer\n            // seems to cause flickering and overflow in Internet Explorer. For example, the ink bar\n            // and ripples will exceed the boundaries of the visible tab bar.\n            // See: https://github.com/angular/components/issues/10276\n            // We round the `transform` here, because transforms with sub-pixel precision cause some\n            // browsers to blur the content of the element.\n            this._tabList.nativeElement.style.transform = `translateX(${Math.round(translateX)}px)`;\n            // Setting the `transform` on IE will change the scroll offset of the parent, causing the\n            // position to be thrown off in some cases. We have to reset it ourselves to ensure that\n            // it doesn't get thrown off. Note that we scope it only to IE and Edge, because messing\n            // with the scroll position throws off Chrome 71+ in RTL mode (see #14689).\n            if (this._platform.TRIDENT || this._platform.EDGE) {\n                this._tabListContainer.nativeElement.scrollLeft = 0;\n            }\n        }\n        /** Sets the distance in pixels that the tab header should be transformed in the X-axis. */\n        get scrollDistance() { return this._scrollDistance; }\n        set scrollDistance(value) {\n            this._scrollTo(value);\n        }\n        /**\n         * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or\n         * the end of the list, respectively). The distance to scroll is computed to be a third of the\n         * length of the tab list view window.\n         *\n         * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n         * should be called sparingly.\n         */\n        _scrollHeader(direction) {\n            const viewLength = this._tabListContainer.nativeElement.offsetWidth;\n            // Move the scroll distance one-third the length of the tab list's viewport.\n            const scrollAmount = (direction == 'before' ? -1 : 1) * viewLength / 3;\n            return this._scrollTo(this._scrollDistance + scrollAmount);\n        }\n        /** Handles click events on the pagination arrows. */\n        _handlePaginatorClick(direction) {\n            this._stopInterval();\n            this._scrollHeader(direction);\n        }\n        /**\n         * Moves the tab list such that the desired tab label (marked by index) is moved into view.\n         *\n         * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n         * should be called sparingly.\n         */\n        _scrollToLabel(labelIndex) {\n            if (this.disablePagination) {\n                return;\n            }\n            const selectedLabel = this._items ? this._items.toArray()[labelIndex] : null;\n            if (!selectedLabel) {\n                return;\n            }\n            // The view length is the visible width of the tab labels.\n            const viewLength = this._tabListContainer.nativeElement.offsetWidth;\n            const { offsetLeft, offsetWidth } = selectedLabel.elementRef.nativeElement;\n            let labelBeforePos, labelAfterPos;\n            if (this._getLayoutDirection() == 'ltr') {\n                labelBeforePos = offsetLeft;\n                labelAfterPos = labelBeforePos + offsetWidth;\n            }\n            else {\n                labelAfterPos = this._tabList.nativeElement.offsetWidth - offsetLeft;\n                labelBeforePos = labelAfterPos - offsetWidth;\n            }\n            const beforeVisiblePos = this.scrollDistance;\n            const afterVisiblePos = this.scrollDistance + viewLength;\n            if (labelBeforePos < beforeVisiblePos) {\n                // Scroll header to move label to the before direction\n                this.scrollDistance -= beforeVisiblePos - labelBeforePos + EXAGGERATED_OVERSCROLL;\n            }\n            else if (labelAfterPos > afterVisiblePos) {\n                // Scroll header to move label to the after direction\n                this.scrollDistance += labelAfterPos - afterVisiblePos + EXAGGERATED_OVERSCROLL;\n            }\n        }\n        /**\n         * Evaluate whether the pagination controls should be displayed. If the scroll width of the\n         * tab list is wider than the size of the header container, then the pagination controls should\n         * be shown.\n         *\n         * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n         * should be called sparingly.\n         */\n        _checkPaginationEnabled() {\n            if (this.disablePagination) {\n                this._showPaginationControls = false;\n            }\n            else {\n                const isEnabled = this._tabList.nativeElement.scrollWidth > this._elementRef.nativeElement.offsetWidth;\n                if (!isEnabled) {\n                    this.scrollDistance = 0;\n                }\n                if (isEnabled !== this._showPaginationControls) {\n                    this._changeDetectorRef.markForCheck();\n                }\n                this._showPaginationControls = isEnabled;\n            }\n        }\n        /**\n         * Evaluate whether the before and after controls should be enabled or disabled.\n         * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the\n         * before button. If the header is at the end of the list (scroll distance is equal to the\n         * maximum distance we can scroll), then disable the after button.\n         *\n         * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n         * should be called sparingly.\n         */\n        _checkScrollingControls() {\n            if (this.disablePagination) {\n                this._disableScrollAfter = this._disableScrollBefore = true;\n            }\n            else {\n                // Check if the pagination arrows should be activated.\n                this._disableScrollBefore = this.scrollDistance == 0;\n                this._disableScrollAfter = this.scrollDistance == this._getMaxScrollDistance();\n                this._changeDetectorRef.markForCheck();\n            }\n        }\n        /**\n         * Determines what is the maximum length in pixels that can be set for the scroll distance. This\n         * is equal to the difference in width between the tab list container and tab header container.\n         *\n         * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n         * should be called sparingly.\n         */\n        _getMaxScrollDistance() {\n            const lengthOfTabList = this._tabList.nativeElement.scrollWidth;\n            const viewLength = this._tabListContainer.nativeElement.offsetWidth;\n            return (lengthOfTabList - viewLength) || 0;\n        }\n        /** Tells the ink-bar to align itself to the current label wrapper */\n        _alignInkBarToSelectedTab() {\n            const selectedItem = this._items && this._items.length ?\n                this._items.toArray()[this.selectedIndex] : null;\n            const selectedLabelWrapper = selectedItem ? selectedItem.elementRef.nativeElement : null;\n            if (selectedLabelWrapper) {\n                this._inkBar.alignToElement(selectedLabelWrapper);\n            }\n            else {\n                this._inkBar.hide();\n            }\n        }\n        /** Stops the currently-running paginator interval.  */\n        _stopInterval() {\n            this._stopScrolling.next();\n        }\n        /**\n         * Handles the user pressing down on one of the paginators.\n         * Starts scrolling the header after a certain amount of time.\n         * @param direction In which direction the paginator should be scrolled.\n         */\n        _handlePaginatorPress(direction, mouseEvent) {\n            // Don't start auto scrolling for right mouse button clicks. Note that we shouldn't have to\n            // null check the `button`, but we do it so we don't break tests that use fake events.\n            if (mouseEvent && mouseEvent.button != null && mouseEvent.button !== 0) {\n                return;\n            }\n            // Avoid overlapping timers.\n            this._stopInterval();\n            // Start a timer after the delay and keep firing based on the interval.\n            Object(rxjs__WEBPACK_IMPORTED_MODULE_12__[/* timer */ \"a\"])(HEADER_SCROLL_DELAY, HEADER_SCROLL_INTERVAL)\n                // Keep the timer going until something tells it to stop or the component is destroyed.\n                .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_16__[/* takeUntil */ \"a\"])(Object(rxjs__WEBPACK_IMPORTED_MODULE_9__[/* merge */ \"a\"])(this._stopScrolling, this._destroyed)))\n                .subscribe(() => {\n                const { maxScrollDistance, distance } = this._scrollHeader(direction);\n                // Stop the timer if we've reached the start or the end.\n                if (distance === 0 || distance >= maxScrollDistance) {\n                    this._stopInterval();\n                }\n            });\n        }\n        /**\n         * Scrolls the header to a given position.\n         * @param position Position to which to scroll.\n         * @returns Information on the current scroll distance and the maximum.\n         */\n        _scrollTo(position) {\n            if (this.disablePagination) {\n                return { maxScrollDistance: 0, distance: 0 };\n            }\n            const maxScrollDistance = this._getMaxScrollDistance();\n            this._scrollDistance = Math.max(0, Math.min(maxScrollDistance, position));\n            // Mark that the scroll distance has changed so that after the view is checked, the CSS\n            // transformation can move the header.\n            this._scrollDistanceChanged = true;\n            this._checkScrollingControls();\n            return { maxScrollDistance, distance: this._scrollDistance };\n        }\n    }\n    MatPaginatedTabHeader.ɵfac = function MatPaginatedTabHeader_Factory(t) { return new (t || MatPaginatedTabHeader)(_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ElementRef */ \"m\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ChangeDetectorRef */ \"i\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_21__[/* ViewportRuler */ \"e\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_20__[/* Directionality */ \"b\"], 8), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* NgZone */ \"F\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_18__[/* Platform */ \"a\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_6__[/* ANIMATION_MODULE_TYPE */ \"a\"], 8)); };\n    MatPaginatedTabHeader.ɵdir = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdefineDirective */ \"Ob\"]({ type: MatPaginatedTabHeader, inputs: { disablePagination: \"disablePagination\" } });\n    return MatPaginatedTabHeader;\n})();\nlet _MatTabHeaderBase = /*@__PURE__*/ (() => {\n    class _MatTabHeaderBase extends MatPaginatedTabHeader {\n        constructor(elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, animationMode) {\n            super(elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, animationMode);\n            this._disableRipple = false;\n        }\n        /** Whether the ripple effect is disabled or not. */\n        get disableRipple() { return this._disableRipple; }\n        set disableRipple(value) { this._disableRipple = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_17__[/* coerceBooleanProperty */ \"c\"])(value); }\n        _itemSelected(event) {\n            event.preventDefault();\n        }\n    }\n    _MatTabHeaderBase.ɵfac = function _MatTabHeaderBase_Factory(t) { return new (t || _MatTabHeaderBase)(_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ElementRef */ \"m\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ChangeDetectorRef */ \"i\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_21__[/* ViewportRuler */ \"e\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_20__[/* Directionality */ \"b\"], 8), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* NgZone */ \"F\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_18__[/* Platform */ \"a\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_6__[/* ANIMATION_MODULE_TYPE */ \"a\"], 8)); };\n    _MatTabHeaderBase.ɵdir = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdefineDirective */ \"Ob\"]({ type: _MatTabHeaderBase, inputs: { disableRipple: \"disableRipple\" }, features: [_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵInheritDefinitionFeature */ \"Db\"]] });\n    return _MatTabHeaderBase;\n})();\nlet MatTabHeader = /*@__PURE__*/ (() => {\n    class MatTabHeader extends _MatTabHeaderBase {\n        constructor(elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, animationMode) {\n            super(elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, animationMode);\n        }\n    }\n    MatTabHeader.ɵfac = function MatTabHeader_Factory(t) { return new (t || MatTabHeader)(_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ElementRef */ \"m\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ChangeDetectorRef */ \"i\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_21__[/* ViewportRuler */ \"e\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_20__[/* Directionality */ \"b\"], 8), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* NgZone */ \"F\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_18__[/* Platform */ \"a\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_6__[/* ANIMATION_MODULE_TYPE */ \"a\"], 8)); };\n    MatTabHeader.ɵcmp = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdefineComponent */ \"Nb\"]({ type: MatTabHeader, selectors: [[\"mat-tab-header\"]], contentQueries: function MatTabHeader_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵcontentQuery */ \"Mb\"](dirIndex, MatTabLabelWrapper, false);\n            }\n            if (rf & 2) {\n                let _t;\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵqueryRefresh */ \"Fc\"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵloadQuery */ \"kc\"]()) && (ctx._items = _t);\n            }\n        }, viewQuery: function MatTabHeader_Query(rf, ctx) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵstaticViewQuery */ \"Nc\"](MatInkBar, true);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵstaticViewQuery */ \"Nc\"](_c5, true);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵstaticViewQuery */ \"Nc\"](_c6, true);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵviewQuery */ \"Zc\"](_c7, true);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵviewQuery */ \"Zc\"](_c8, true);\n            }\n            if (rf & 2) {\n                let _t;\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵqueryRefresh */ \"Fc\"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵloadQuery */ \"kc\"]()) && (ctx._inkBar = _t.first);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵqueryRefresh */ \"Fc\"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵloadQuery */ \"kc\"]()) && (ctx._tabListContainer = _t.first);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵqueryRefresh */ \"Fc\"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵloadQuery */ \"kc\"]()) && (ctx._tabList = _t.first);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵqueryRefresh */ \"Fc\"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵloadQuery */ \"kc\"]()) && (ctx._nextPaginator = _t.first);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵqueryRefresh */ \"Fc\"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵloadQuery */ \"kc\"]()) && (ctx._previousPaginator = _t.first);\n            }\n        }, hostAttrs: [1, \"mat-tab-header\"], hostVars: 4, hostBindings: function MatTabHeader_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵclassProp */ \"Lb\"](\"mat-tab-header-pagination-controls-enabled\", ctx._showPaginationControls)(\"mat-tab-header-rtl\", ctx._getLayoutDirection() == \"rtl\");\n            }\n        }, inputs: { selectedIndex: \"selectedIndex\" }, outputs: { selectFocusedIndex: \"selectFocusedIndex\", indexFocused: \"indexFocused\" }, features: [_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵInheritDefinitionFeature */ \"Db\"]], ngContentSelectors: _c0, decls: 13, vars: 8, consts: [[\"aria-hidden\", \"true\", \"mat-ripple\", \"\", 1, \"mat-tab-header-pagination\", \"mat-tab-header-pagination-before\", \"mat-elevation-z4\", 3, \"matRippleDisabled\", \"click\", \"mousedown\", \"touchend\"], [\"previousPaginator\", \"\"], [1, \"mat-tab-header-pagination-chevron\"], [1, \"mat-tab-label-container\", 3, \"keydown\"], [\"tabListContainer\", \"\"], [\"role\", \"tablist\", 1, \"mat-tab-list\", 3, \"cdkObserveContent\"], [\"tabList\", \"\"], [1, \"mat-tab-labels\"], [\"aria-hidden\", \"true\", \"mat-ripple\", \"\", 1, \"mat-tab-header-pagination\", \"mat-tab-header-pagination-after\", \"mat-elevation-z4\", 3, \"matRippleDisabled\", \"mousedown\", \"click\", \"touchend\"], [\"nextPaginator\", \"\"]], template: function MatTabHeader_Template(rf, ctx) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵprojectionDef */ \"sc\"]();\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelementStart */ \"Zb\"](0, \"div\", 0, 1);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵlistener */ \"jc\"](\"click\", function MatTabHeader_Template_div_click_0_listener() { return ctx._handlePaginatorClick(\"before\"); })(\"mousedown\", function MatTabHeader_Template_div_mousedown_0_listener($event) { return ctx._handlePaginatorPress(\"before\", $event); })(\"touchend\", function MatTabHeader_Template_div_touchend_0_listener() { return ctx._stopInterval(); });\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelement */ \"Ub\"](2, \"div\", 2);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelementEnd */ \"Yb\"]();\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelementStart */ \"Zb\"](3, \"div\", 3, 4);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵlistener */ \"jc\"](\"keydown\", function MatTabHeader_Template_div_keydown_3_listener($event) { return ctx._handleKeydown($event); });\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelementStart */ \"Zb\"](5, \"div\", 5, 6);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵlistener */ \"jc\"](\"cdkObserveContent\", function MatTabHeader_Template_div_cdkObserveContent_5_listener() { return ctx._onContentChanges(); });\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelementStart */ \"Zb\"](7, \"div\", 7);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵprojection */ \"rc\"](8);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelementEnd */ \"Yb\"]();\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelement */ \"Ub\"](9, \"mat-ink-bar\");\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelementEnd */ \"Yb\"]();\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelementEnd */ \"Yb\"]();\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelementStart */ \"Zb\"](10, \"div\", 8, 9);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵlistener */ \"jc\"](\"mousedown\", function MatTabHeader_Template_div_mousedown_10_listener($event) { return ctx._handlePaginatorPress(\"after\", $event); })(\"click\", function MatTabHeader_Template_div_click_10_listener() { return ctx._handlePaginatorClick(\"after\"); })(\"touchend\", function MatTabHeader_Template_div_touchend_10_listener() { return ctx._stopInterval(); });\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelement */ \"Ub\"](12, \"div\", 2);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelementEnd */ \"Yb\"]();\n            }\n            if (rf & 2) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵclassProp */ \"Lb\"](\"mat-tab-header-pagination-disabled\", ctx._disableScrollBefore);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵproperty */ \"tc\"](\"matRippleDisabled\", ctx._disableScrollBefore || ctx.disableRipple);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵadvance */ \"Gb\"](5);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵclassProp */ \"Lb\"](\"_mat-animation-noopable\", ctx._animationMode === \"NoopAnimations\");\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵadvance */ \"Gb\"](5);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵclassProp */ \"Lb\"](\"mat-tab-header-pagination-disabled\", ctx._disableScrollAfter);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵproperty */ \"tc\"](\"matRippleDisabled\", ctx._disableScrollAfter || ctx.disableRipple);\n            }\n        }, directives: [_angular_material_core__WEBPACK_IMPORTED_MODULE_5__[/* MatRipple */ \"t\"], _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_1__[/* CdkObserveContent */ \"a\"], MatInkBar], styles: [\".mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-header-pagination{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:transparent;touch-action:none}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-rtl .mat-tab-header-pagination-before,.mat-tab-header-pagination-after{padding-right:4px}.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:\\\"\\\";height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-list{flex-grow:1;position:relative;transition:transform 500ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-ink-bar{transition:none;animation:none}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}.cdk-high-contrast-active .mat-ink-bar{outline:solid 2px;height:0}.mat-tab-labels{display:flex}[mat-align-tabs=center]>.mat-tab-header .mat-tab-labels{justify-content:center}[mat-align-tabs=end]>.mat-tab-header .mat-tab-labels{justify-content:flex-end}.mat-tab-label-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}._mat-animation-noopable.mat-tab-list{transition:none;animation:none}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:none}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}.cdk-high-contrast-active .mat-tab-label:focus{outline:dotted 2px;outline-offset:-2px}.mat-tab-label.mat-tab-disabled{cursor:default}.cdk-high-contrast-active .mat-tab-label.mat-tab-disabled{opacity:.5}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.cdk-high-contrast-active .mat-tab-label{opacity:1}@media(max-width: 599px){.mat-tab-label{min-width:72px}}\\n\"], encapsulation: 2 });\n    return MatTabHeader;\n})();\nlet _MatTabNavBase = /*@__PURE__*/ (() => {\n    class _MatTabNavBase extends MatPaginatedTabHeader {\n        constructor(elementRef, dir, ngZone, changeDetectorRef, viewportRuler, platform, animationMode) {\n            super(elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, animationMode);\n            this._disableRipple = false;\n            /** Theme color of the nav bar. */\n            this.color = 'primary';\n        }\n        /** Background color of the tab nav. */\n        get backgroundColor() { return this._backgroundColor; }\n        set backgroundColor(value) {\n            const classList = this._elementRef.nativeElement.classList;\n            classList.remove(`mat-background-${this.backgroundColor}`);\n            if (value) {\n                classList.add(`mat-background-${value}`);\n            }\n            this._backgroundColor = value;\n        }\n        /** Whether the ripple effect is disabled or not. */\n        get disableRipple() { return this._disableRipple; }\n        set disableRipple(value) { this._disableRipple = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_17__[/* coerceBooleanProperty */ \"c\"])(value); }\n        _itemSelected() {\n            // noop\n        }\n        ngAfterContentInit() {\n            // We need this to run before the `changes` subscription in parent to ensure that the\n            // selectedIndex is up-to-date by the time the super class starts looking for it.\n            this._items.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__[/* startWith */ \"a\"])(null), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_16__[/* takeUntil */ \"a\"])(this._destroyed)).subscribe(() => {\n                this.updateActiveLink();\n            });\n            super.ngAfterContentInit();\n        }\n        /** Notifies the component that the active link has been changed. */\n        updateActiveLink() {\n            if (!this._items) {\n                return;\n            }\n            const items = this._items.toArray();\n            for (let i = 0; i < items.length; i++) {\n                if (items[i].active) {\n                    this.selectedIndex = i;\n                    this._changeDetectorRef.markForCheck();\n                    return;\n                }\n            }\n            // The ink bar should hide itself if no items are active.\n            this.selectedIndex = -1;\n            this._inkBar.hide();\n        }\n    }\n    _MatTabNavBase.ɵfac = function _MatTabNavBase_Factory(t) { return new (t || _MatTabNavBase)(_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ElementRef */ \"m\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_20__[/* Directionality */ \"b\"], 8), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* NgZone */ \"F\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ChangeDetectorRef */ \"i\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_21__[/* ViewportRuler */ \"e\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_18__[/* Platform */ \"a\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_6__[/* ANIMATION_MODULE_TYPE */ \"a\"], 8)); };\n    _MatTabNavBase.ɵdir = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdefineDirective */ \"Ob\"]({ type: _MatTabNavBase, inputs: { color: \"color\", backgroundColor: \"backgroundColor\", disableRipple: \"disableRipple\" }, features: [_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵInheritDefinitionFeature */ \"Db\"]] });\n    return _MatTabNavBase;\n})();\nlet MatTabNav = /*@__PURE__*/ (() => {\n    class MatTabNav extends _MatTabNavBase {\n        constructor(elementRef, dir, ngZone, changeDetectorRef, viewportRuler, platform, animationMode) {\n            super(elementRef, dir, ngZone, changeDetectorRef, viewportRuler, platform, animationMode);\n        }\n    }\n    MatTabNav.ɵfac = function MatTabNav_Factory(t) { return new (t || MatTabNav)(_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ElementRef */ \"m\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_20__[/* Directionality */ \"b\"], 8), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* NgZone */ \"F\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ChangeDetectorRef */ \"i\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_21__[/* ViewportRuler */ \"e\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_18__[/* Platform */ \"a\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_6__[/* ANIMATION_MODULE_TYPE */ \"a\"], 8)); };\n    MatTabNav.ɵcmp = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdefineComponent */ \"Nb\"]({ type: MatTabNav, selectors: [[\"\", \"mat-tab-nav-bar\", \"\"]], contentQueries: function MatTabNav_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵcontentQuery */ \"Mb\"](dirIndex, MatTabLink, true);\n            }\n            if (rf & 2) {\n                let _t;\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵqueryRefresh */ \"Fc\"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵloadQuery */ \"kc\"]()) && (ctx._items = _t);\n            }\n        }, viewQuery: function MatTabNav_Query(rf, ctx) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵstaticViewQuery */ \"Nc\"](MatInkBar, true);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵstaticViewQuery */ \"Nc\"](_c5, true);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵstaticViewQuery */ \"Nc\"](_c6, true);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵviewQuery */ \"Zc\"](_c7, true);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵviewQuery */ \"Zc\"](_c8, true);\n            }\n            if (rf & 2) {\n                let _t;\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵqueryRefresh */ \"Fc\"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵloadQuery */ \"kc\"]()) && (ctx._inkBar = _t.first);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵqueryRefresh */ \"Fc\"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵloadQuery */ \"kc\"]()) && (ctx._tabListContainer = _t.first);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵqueryRefresh */ \"Fc\"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵloadQuery */ \"kc\"]()) && (ctx._tabList = _t.first);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵqueryRefresh */ \"Fc\"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵloadQuery */ \"kc\"]()) && (ctx._nextPaginator = _t.first);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵqueryRefresh */ \"Fc\"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵloadQuery */ \"kc\"]()) && (ctx._previousPaginator = _t.first);\n            }\n        }, hostAttrs: [1, \"mat-tab-nav-bar\", \"mat-tab-header\"], hostVars: 10, hostBindings: function MatTabNav_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵclassProp */ \"Lb\"](\"mat-tab-header-pagination-controls-enabled\", ctx._showPaginationControls)(\"mat-tab-header-rtl\", ctx._getLayoutDirection() == \"rtl\")(\"mat-primary\", ctx.color !== \"warn\" && ctx.color !== \"accent\")(\"mat-accent\", ctx.color === \"accent\")(\"mat-warn\", ctx.color === \"warn\");\n            }\n        }, inputs: { color: \"color\" }, exportAs: [\"matTabNavBar\", \"matTabNav\"], features: [_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵInheritDefinitionFeature */ \"Db\"]], attrs: _c9, ngContentSelectors: _c0, decls: 13, vars: 8, consts: [[\"aria-hidden\", \"true\", \"mat-ripple\", \"\", 1, \"mat-tab-header-pagination\", \"mat-tab-header-pagination-before\", \"mat-elevation-z4\", 3, \"matRippleDisabled\", \"click\", \"mousedown\", \"touchend\"], [\"previousPaginator\", \"\"], [1, \"mat-tab-header-pagination-chevron\"], [1, \"mat-tab-link-container\", 3, \"keydown\"], [\"tabListContainer\", \"\"], [1, \"mat-tab-list\", 3, \"cdkObserveContent\"], [\"tabList\", \"\"], [1, \"mat-tab-links\"], [\"aria-hidden\", \"true\", \"mat-ripple\", \"\", 1, \"mat-tab-header-pagination\", \"mat-tab-header-pagination-after\", \"mat-elevation-z4\", 3, \"matRippleDisabled\", \"mousedown\", \"click\", \"touchend\"], [\"nextPaginator\", \"\"]], template: function MatTabNav_Template(rf, ctx) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵprojectionDef */ \"sc\"]();\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelementStart */ \"Zb\"](0, \"div\", 0, 1);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵlistener */ \"jc\"](\"click\", function MatTabNav_Template_div_click_0_listener() { return ctx._handlePaginatorClick(\"before\"); })(\"mousedown\", function MatTabNav_Template_div_mousedown_0_listener($event) { return ctx._handlePaginatorPress(\"before\", $event); })(\"touchend\", function MatTabNav_Template_div_touchend_0_listener() { return ctx._stopInterval(); });\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelement */ \"Ub\"](2, \"div\", 2);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelementEnd */ \"Yb\"]();\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelementStart */ \"Zb\"](3, \"div\", 3, 4);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵlistener */ \"jc\"](\"keydown\", function MatTabNav_Template_div_keydown_3_listener($event) { return ctx._handleKeydown($event); });\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelementStart */ \"Zb\"](5, \"div\", 5, 6);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵlistener */ \"jc\"](\"cdkObserveContent\", function MatTabNav_Template_div_cdkObserveContent_5_listener() { return ctx._onContentChanges(); });\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelementStart */ \"Zb\"](7, \"div\", 7);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵprojection */ \"rc\"](8);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelementEnd */ \"Yb\"]();\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelement */ \"Ub\"](9, \"mat-ink-bar\");\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelementEnd */ \"Yb\"]();\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelementEnd */ \"Yb\"]();\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelementStart */ \"Zb\"](10, \"div\", 8, 9);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵlistener */ \"jc\"](\"mousedown\", function MatTabNav_Template_div_mousedown_10_listener($event) { return ctx._handlePaginatorPress(\"after\", $event); })(\"click\", function MatTabNav_Template_div_click_10_listener() { return ctx._handlePaginatorClick(\"after\"); })(\"touchend\", function MatTabNav_Template_div_touchend_10_listener() { return ctx._stopInterval(); });\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelement */ \"Ub\"](12, \"div\", 2);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵelementEnd */ \"Yb\"]();\n            }\n            if (rf & 2) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵclassProp */ \"Lb\"](\"mat-tab-header-pagination-disabled\", ctx._disableScrollBefore);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵproperty */ \"tc\"](\"matRippleDisabled\", ctx._disableScrollBefore || ctx.disableRipple);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵadvance */ \"Gb\"](5);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵclassProp */ \"Lb\"](\"_mat-animation-noopable\", ctx._animationMode === \"NoopAnimations\");\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵadvance */ \"Gb\"](5);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵclassProp */ \"Lb\"](\"mat-tab-header-pagination-disabled\", ctx._disableScrollAfter);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵproperty */ \"tc\"](\"matRippleDisabled\", ctx._disableScrollAfter || ctx.disableRipple);\n            }\n        }, directives: [_angular_material_core__WEBPACK_IMPORTED_MODULE_5__[/* MatRipple */ \"t\"], _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_1__[/* CdkObserveContent */ \"a\"], MatInkBar], styles: [\".mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-header-pagination{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:transparent;touch-action:none}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-rtl .mat-tab-header-pagination-before,.mat-tab-header-pagination-after{padding-right:4px}.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:\\\"\\\";height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-list{flex-grow:1;position:relative;transition:transform 500ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-tab-links{display:flex}[mat-align-tabs=center]>.mat-tab-link-container .mat-tab-links{justify-content:center}[mat-align-tabs=end]>.mat-tab-link-container .mat-tab-links{justify-content:flex-end}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-ink-bar{transition:none;animation:none}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}.cdk-high-contrast-active .mat-ink-bar{outline:solid 2px;height:0}.mat-tab-link-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}.mat-tab-link{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;vertical-align:top;text-decoration:none;position:relative;overflow:hidden;-webkit-tap-highlight-color:transparent}.mat-tab-link:focus{outline:none}.mat-tab-link:focus:not(.mat-tab-disabled){opacity:1}.cdk-high-contrast-active .mat-tab-link:focus{outline:dotted 2px;outline-offset:-2px}.mat-tab-link.mat-tab-disabled{cursor:default}.cdk-high-contrast-active .mat-tab-link.mat-tab-disabled{opacity:.5}.mat-tab-link .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.cdk-high-contrast-active .mat-tab-link{opacity:1}[mat-stretch-tabs] .mat-tab-link{flex-basis:0;flex-grow:1}.mat-tab-link.mat-tab-disabled{pointer-events:none}@media(max-width: 599px){.mat-tab-link{min-width:72px}}\\n\"], encapsulation: 2 });\n    return MatTabNav;\n})();\n// Boilerplate for applying mixins to MatTabLink.\nclass MatTabLinkMixinBase {\n}\nconst _MatTabLinkMixinBase = /*@__PURE__*/ Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_5__[/* mixinTabIndex */ \"D\"])(/*@__PURE__*/ Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_5__[/* mixinDisableRipple */ \"z\"])(/*@__PURE__*/ Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_5__[/* mixinDisabled */ \"A\"])(MatTabLinkMixinBase)));\nlet _MatTabLinkBase = /*@__PURE__*/ (() => {\n    class _MatTabLinkBase extends _MatTabLinkMixinBase {\n        constructor(_tabNavBar, \n        /** @docs-private */ elementRef, globalRippleOptions, tabIndex, _focusMonitor, animationMode) {\n            super();\n            this._tabNavBar = _tabNavBar;\n            this.elementRef = elementRef;\n            this._focusMonitor = _focusMonitor;\n            /** Whether the tab link is active or not. */\n            this._isActive = false;\n            this.rippleConfig = globalRippleOptions || {};\n            this.tabIndex = parseInt(tabIndex) || 0;\n            if (animationMode === 'NoopAnimations') {\n                this.rippleConfig.animation = { enterDuration: 0, exitDuration: 0 };\n            }\n        }\n        /** Whether the link is active. */\n        get active() { return this._isActive; }\n        set active(value) {\n            const newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_17__[/* coerceBooleanProperty */ \"c\"])(value);\n            if (newValue !== this._isActive) {\n                this._isActive = value;\n                this._tabNavBar.updateActiveLink();\n            }\n        }\n        /**\n         * Whether ripples are disabled on interaction.\n         * @docs-private\n         */\n        get rippleDisabled() {\n            return this.disabled || this.disableRipple || this._tabNavBar.disableRipple ||\n                !!this.rippleConfig.disabled;\n        }\n        /** Focuses the tab link. */\n        focus() {\n            this.elementRef.nativeElement.focus();\n        }\n        ngAfterViewInit() {\n            this._focusMonitor.monitor(this.elementRef);\n        }\n        ngOnDestroy() {\n            this._focusMonitor.stopMonitoring(this.elementRef);\n        }\n    }\n    _MatTabLinkBase.ɵfac = function _MatTabLinkBase_Factory(t) { return new (t || _MatTabLinkBase)(_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_MatTabNavBase), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ElementRef */ \"m\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_material_core__WEBPACK_IMPORTED_MODULE_5__[/* MAT_RIPPLE_GLOBAL_OPTIONS */ \"i\"], 8), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵinjectAttribute */ \"hc\"]('tabindex'), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__[/* FocusMonitor */ \"h\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_6__[/* ANIMATION_MODULE_TYPE */ \"a\"], 8)); };\n    _MatTabLinkBase.ɵdir = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdefineDirective */ \"Ob\"]({ type: _MatTabLinkBase, inputs: { active: \"active\" }, features: [_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵInheritDefinitionFeature */ \"Db\"]] });\n    return _MatTabLinkBase;\n})();\nlet MatTabLink = /*@__PURE__*/ (() => {\n    class MatTabLink extends _MatTabLinkBase {\n        constructor(tabNavBar, elementRef, ngZone, platform, globalRippleOptions, tabIndex, focusMonitor, animationMode) {\n            super(tabNavBar, elementRef, globalRippleOptions, tabIndex, focusMonitor, animationMode);\n            this._tabLinkRipple = new _angular_material_core__WEBPACK_IMPORTED_MODULE_5__[/* RippleRenderer */ \"v\"](this, ngZone, elementRef, platform);\n            this._tabLinkRipple.setupTriggerEvents(elementRef.nativeElement);\n        }\n        ngOnDestroy() {\n            super.ngOnDestroy();\n            this._tabLinkRipple._removeTriggerEvents();\n        }\n    }\n    MatTabLink.ɵfac = function MatTabLink_Factory(t) { return new (t || MatTabLink)(_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](MatTabNav), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ElementRef */ \"m\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* NgZone */ \"F\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_18__[/* Platform */ \"a\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_material_core__WEBPACK_IMPORTED_MODULE_5__[/* MAT_RIPPLE_GLOBAL_OPTIONS */ \"i\"], 8), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵinjectAttribute */ \"hc\"]('tabindex'), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__[/* FocusMonitor */ \"h\"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_6__[/* ANIMATION_MODULE_TYPE */ \"a\"], 8)); };\n    MatTabLink.ɵdir = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdefineDirective */ \"Ob\"]({ type: MatTabLink, selectors: [[\"\", \"mat-tab-link\", \"\"], [\"\", \"matTabLink\", \"\"]], hostAttrs: [1, \"mat-tab-link\", \"mat-focus-indicator\"], hostVars: 7, hostBindings: function MatTabLink_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵattribute */ \"Hb\"](\"aria-current\", ctx.active ? \"page\" : null)(\"aria-disabled\", ctx.disabled)(\"tabIndex\", ctx.tabIndex);\n                _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵclassProp */ \"Lb\"](\"mat-tab-disabled\", ctx.disabled)(\"mat-tab-label-active\", ctx.active);\n            }\n        }, inputs: { disabled: \"disabled\", disableRipple: \"disableRipple\", tabIndex: \"tabIndex\" }, exportAs: [\"matTabLink\"], features: [_angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵInheritDefinitionFeature */ \"Db\"]] });\n    return MatTabLink;\n})();\nlet MatTabsModule = /*@__PURE__*/ (() => {\n    class MatTabsModule {\n    }\n    MatTabsModule.ɵmod = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdefineNgModule */ \"Rb\"]({ type: MatTabsModule });\n    MatTabsModule.ɵinj = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵdefineInjector */ \"Qb\"]({ factory: function MatTabsModule_Factory(t) { return new (t || MatTabsModule)(); }, imports: [[\n                _angular_common__WEBPACK_IMPORTED_MODULE_3__[/* CommonModule */ \"c\"],\n                _angular_material_core__WEBPACK_IMPORTED_MODULE_5__[/* MatCommonModule */ \"j\"],\n                _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_2__[/* PortalModule */ \"f\"],\n                _angular_material_core__WEBPACK_IMPORTED_MODULE_5__[/* MatRippleModule */ \"u\"],\n                _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_1__[/* ObserversModule */ \"c\"],\n                _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__[/* A11yModule */ \"a\"],\n            ], _angular_material_core__WEBPACK_IMPORTED_MODULE_5__[/* MatCommonModule */ \"j\"]] });\n    return MatTabsModule;\n})();\n/*@__PURE__*/ (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_4__[/* ɵɵsetNgModuleScope */ \"Lc\"](MatTabsModule, { declarations: function () { return [MatTabGroup, MatTabLabel, MatTab, MatInkBar, MatTabLabelWrapper, MatTabNav, MatTabLink, MatTabBody, MatTabBodyPortal, MatTabHeader, MatTabContent]; }, imports: function () {\n            return [_angular_common__WEBPACK_IMPORTED_MODULE_3__[/* CommonModule */ \"c\"],\n                _angular_material_core__WEBPACK_IMPORTED_MODULE_5__[/* MatCommonModule */ \"j\"],\n                _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_2__[/* PortalModule */ \"f\"],\n                _angular_material_core__WEBPACK_IMPORTED_MODULE_5__[/* MatRippleModule */ \"u\"],\n                _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_1__[/* ObserversModule */ \"c\"],\n                _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__[/* A11yModule */ \"a\"]];\n        }, exports: function () { return [_angular_material_core__WEBPACK_IMPORTED_MODULE_5__[/* MatCommonModule */ \"j\"], MatTabGroup, MatTabLabel, MatTab, MatTabNav, MatTabLink, MatTabContent]; } });\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=tabs.js.map\n\n\n/***/ })\n\n}]);","inputSourceMap":null}