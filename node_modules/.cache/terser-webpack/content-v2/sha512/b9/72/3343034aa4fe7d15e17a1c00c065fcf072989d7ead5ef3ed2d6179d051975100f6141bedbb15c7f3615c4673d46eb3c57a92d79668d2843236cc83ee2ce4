{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{XhcP:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return MatDrawer}),__webpack_require__.d(__webpack_exports__,\"b\",function(){return MatDrawerContainer}),__webpack_require__.d(__webpack_exports__,\"c\",function(){return MatDrawerContent}),__webpack_require__.d(__webpack_exports__,\"d\",function(){return MatSidenav}),__webpack_require__.d(__webpack_exports__,\"e\",function(){return MatSidenavContainer}),__webpack_require__.d(__webpack_exports__,\"f\",function(){return MatSidenavContent}),__webpack_require__.d(__webpack_exports__,\"g\",function(){return MatSidenavModule});var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"nLfN\"),_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"vxfF\"),_angular_common__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"ofXK\"),_angular_core__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(\"fXoL\"),_angular_material_core__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(\"FKr1\"),_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__(\"8LU1\"),_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_6__=__webpack_require__(\"FtGj\"),rxjs__WEBPACK_IMPORTED_MODULE_7__=__webpack_require__(\"XNiG\"),rxjs__WEBPACK_IMPORTED_MODULE_8__=__webpack_require__(\"xgIS\"),rxjs__WEBPACK_IMPORTED_MODULE_9__=__webpack_require__(\"VRyK\"),rxjs_operators__WEBPACK_IMPORTED_MODULE_10__=__webpack_require__(\"pLZG\"),rxjs_operators__WEBPACK_IMPORTED_MODULE_11__=__webpack_require__(\"lJxs\"),rxjs_operators__WEBPACK_IMPORTED_MODULE_12__=__webpack_require__(\"CqXF\"),rxjs_operators__WEBPACK_IMPORTED_MODULE_13__=__webpack_require__(\"1G5W\"),rxjs_operators__WEBPACK_IMPORTED_MODULE_14__=__webpack_require__(\"/uUt\"),rxjs_operators__WEBPACK_IMPORTED_MODULE_15__=__webpack_require__(\"IzEk\"),rxjs_operators__WEBPACK_IMPORTED_MODULE_16__=__webpack_require__(\"JX91\"),rxjs_operators__WEBPACK_IMPORTED_MODULE_17__=__webpack_require__(\"Kj3r\"),_angular_animations__WEBPACK_IMPORTED_MODULE_18__=__webpack_require__(\"R0Ic\"),_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_19__=__webpack_require__(\"R1ws\"),_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_20__=__webpack_require__(\"u47x\"),_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_21__=__webpack_require__(\"cH1L\");const _c0=[\"*\"];function MatDrawerContainer_div_0_Template(rf,ctx){if(1&rf){const _r3=_angular_core__WEBPACK_IMPORTED_MODULE_3__.ac();_angular_core__WEBPACK_IMPORTED_MODULE_3__.Zb(0,\"div\",2),_angular_core__WEBPACK_IMPORTED_MODULE_3__.jc(\"click\",function(){return _angular_core__WEBPACK_IMPORTED_MODULE_3__.Ic(_r3),_angular_core__WEBPACK_IMPORTED_MODULE_3__.nc()._onBackdropClicked()}),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Yb()}if(2&rf){const ctx_r0=_angular_core__WEBPACK_IMPORTED_MODULE_3__.nc();_angular_core__WEBPACK_IMPORTED_MODULE_3__.Lb(\"mat-drawer-shown\",ctx_r0._isShowingBackdrop())}}function MatDrawerContainer_mat_drawer_content_3_Template(rf,ctx){1&rf&&(_angular_core__WEBPACK_IMPORTED_MODULE_3__.Zb(0,\"mat-drawer-content\"),_angular_core__WEBPACK_IMPORTED_MODULE_3__.rc(1,2),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Yb())}const _c1=[[[\"mat-drawer\"]],[[\"mat-drawer-content\"]],\"*\"],_c2=[\"mat-drawer\",\"mat-drawer-content\",\"*\"];function MatSidenavContainer_div_0_Template(rf,ctx){if(1&rf){const _r3=_angular_core__WEBPACK_IMPORTED_MODULE_3__.ac();_angular_core__WEBPACK_IMPORTED_MODULE_3__.Zb(0,\"div\",2),_angular_core__WEBPACK_IMPORTED_MODULE_3__.jc(\"click\",function(){return _angular_core__WEBPACK_IMPORTED_MODULE_3__.Ic(_r3),_angular_core__WEBPACK_IMPORTED_MODULE_3__.nc()._onBackdropClicked()}),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Yb()}if(2&rf){const ctx_r0=_angular_core__WEBPACK_IMPORTED_MODULE_3__.nc();_angular_core__WEBPACK_IMPORTED_MODULE_3__.Lb(\"mat-drawer-shown\",ctx_r0._isShowingBackdrop())}}function MatSidenavContainer_mat_sidenav_content_3_Template(rf,ctx){1&rf&&(_angular_core__WEBPACK_IMPORTED_MODULE_3__.Zb(0,\"mat-sidenav-content\",3),_angular_core__WEBPACK_IMPORTED_MODULE_3__.rc(1,2),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Yb())}const _c3=[[[\"mat-sidenav\"]],[[\"mat-sidenav-content\"]],\"*\"],_c4=[\"mat-sidenav\",\"mat-sidenav-content\",\"*\"],_c5=\".mat-drawer-container{position:relative;z-index:1;box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}.cdk-high-contrast-active .mat-drawer-backdrop{opacity:.5}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}.cdk-high-contrast-active .mat-drawer,.cdk-high-contrast-active [dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}.cdk-high-contrast-active [dir=rtl] .mat-drawer,.cdk-high-contrast-active .mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer{transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch}.mat-sidenav-fixed{position:fixed}\\n\",matDrawerAnimations={transformDrawer:Object(_angular_animations__WEBPACK_IMPORTED_MODULE_18__.n)(\"transform\",[Object(_angular_animations__WEBPACK_IMPORTED_MODULE_18__.k)(\"open, open-instant\",Object(_angular_animations__WEBPACK_IMPORTED_MODULE_18__.l)({transform:\"none\",visibility:\"visible\"})),Object(_angular_animations__WEBPACK_IMPORTED_MODULE_18__.k)(\"void\",Object(_angular_animations__WEBPACK_IMPORTED_MODULE_18__.l)({\"box-shadow\":\"none\",visibility:\"hidden\"})),Object(_angular_animations__WEBPACK_IMPORTED_MODULE_18__.m)(\"void => open-instant\",Object(_angular_animations__WEBPACK_IMPORTED_MODULE_18__.e)(\"0ms\")),Object(_angular_animations__WEBPACK_IMPORTED_MODULE_18__.m)(\"void <=> open, open-instant => void\",Object(_angular_animations__WEBPACK_IMPORTED_MODULE_18__.e)(\"400ms cubic-bezier(0.25, 0.8, 0.25, 1)\"))])},MAT_DRAWER_DEFAULT_AUTOSIZE=new _angular_core__WEBPACK_IMPORTED_MODULE_3__.u(\"MAT_DRAWER_DEFAULT_AUTOSIZE\",{providedIn:\"root\",factory:function(){return!1}}),MAT_DRAWER_CONTAINER=new _angular_core__WEBPACK_IMPORTED_MODULE_3__.u(\"MAT_DRAWER_CONTAINER\");let MatDrawerContent=(()=>{class MatDrawerContent extends _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__.a{constructor(_changeDetectorRef,_container,elementRef,scrollDispatcher,ngZone){super(elementRef,scrollDispatcher,ngZone),this._changeDetectorRef=_changeDetectorRef,this._container=_container}ngAfterContentInit(){this._container._contentMarginChanges.subscribe(()=>{this._changeDetectorRef.markForCheck()})}}return MatDrawerContent.ɵfac=function(t){return new(t||MatDrawerContent)(_angular_core__WEBPACK_IMPORTED_MODULE_3__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_3__.i),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Tb(Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__.Z)(()=>MatDrawerContainer)),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_3__.m),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Tb(_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__.c),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_3__.F))},MatDrawerContent.ɵcmp=_angular_core__WEBPACK_IMPORTED_MODULE_3__.Nb({type:MatDrawerContent,selectors:[[\"mat-drawer-content\"]],hostAttrs:[1,\"mat-drawer-content\"],hostVars:4,hostBindings:function(rf,ctx){2&rf&&_angular_core__WEBPACK_IMPORTED_MODULE_3__.Pc(\"margin-left\",ctx._container._contentMargins.left,\"px\")(\"margin-right\",ctx._container._contentMargins.right,\"px\")},features:[_angular_core__WEBPACK_IMPORTED_MODULE_3__.Db],ngContentSelectors:_c0,decls:1,vars:0,template:function(rf,ctx){1&rf&&(_angular_core__WEBPACK_IMPORTED_MODULE_3__.sc(),_angular_core__WEBPACK_IMPORTED_MODULE_3__.rc(0))},encapsulation:2,changeDetection:0}),MatDrawerContent})(),MatDrawer=(()=>{class MatDrawer{constructor(_elementRef,_focusTrapFactory,_focusMonitor,_platform,_ngZone,_doc,_container){this._elementRef=_elementRef,this._focusTrapFactory=_focusTrapFactory,this._focusMonitor=_focusMonitor,this._platform=_platform,this._ngZone=_ngZone,this._doc=_doc,this._container=_container,this._elementFocusedBeforeDrawerWasOpened=null,this._enableAnimations=!1,this._position=\"start\",this._mode=\"over\",this._disableClose=!1,this._opened=!1,this._animationStarted=new rxjs__WEBPACK_IMPORTED_MODULE_7__.a,this._animationEnd=new rxjs__WEBPACK_IMPORTED_MODULE_7__.a,this._animationState=\"void\",this.openedChange=new _angular_core__WEBPACK_IMPORTED_MODULE_3__.p(!0),this._openedStream=this.openedChange.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.a)(o=>o),Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_11__.a)(()=>{})),this.openedStart=this._animationStarted.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.a)(e=>e.fromState!==e.toState&&0===e.toState.indexOf(\"open\")),Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_12__.a)(void 0)),this._closedStream=this.openedChange.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.a)(o=>!o),Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_11__.a)(()=>{})),this.closedStart=this._animationStarted.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.a)(e=>e.fromState!==e.toState&&\"void\"===e.toState),Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_12__.a)(void 0)),this._destroyed=new rxjs__WEBPACK_IMPORTED_MODULE_7__.a,this.onPositionChanged=new _angular_core__WEBPACK_IMPORTED_MODULE_3__.p,this._modeChanged=new rxjs__WEBPACK_IMPORTED_MODULE_7__.a,this.openedChange.subscribe(opened=>{opened?(this._doc&&(this._elementFocusedBeforeDrawerWasOpened=this._doc.activeElement),this._takeFocus()):this._isFocusWithinDrawer()&&this._restoreFocus()}),this._ngZone.runOutsideAngular(()=>{Object(rxjs__WEBPACK_IMPORTED_MODULE_8__.a)(this._elementRef.nativeElement,\"keydown\").pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.a)(event=>event.keyCode===_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_6__.h&&!this.disableClose&&!Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_6__.t)(event)),Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__.a)(this._destroyed)).subscribe(event=>this._ngZone.run(()=>{this.close(),event.stopPropagation(),event.preventDefault()}))}),this._animationEnd.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__.a)((x,y)=>x.fromState===y.fromState&&x.toState===y.toState)).subscribe(event=>{const{fromState:fromState,toState:toState}=event;(0===toState.indexOf(\"open\")&&\"void\"===fromState||\"void\"===toState&&0===fromState.indexOf(\"open\"))&&this.openedChange.emit(this._opened)})}get position(){return this._position}set position(value){(value=\"end\"===value?\"end\":\"start\")!=this._position&&(this._position=value,this.onPositionChanged.emit())}get mode(){return this._mode}set mode(value){this._mode=value,this._updateFocusTrapState(),this._modeChanged.next()}get disableClose(){return this._disableClose}set disableClose(value){this._disableClose=Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__.c)(value)}get autoFocus(){const value=this._autoFocus;return null==value?\"side\"!==this.mode:value}set autoFocus(value){this._autoFocus=Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__.c)(value)}get opened(){return this._opened}set opened(value){this.toggle(Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__.c)(value))}_takeFocus(){this.autoFocus&&this._focusTrap&&this._focusTrap.focusInitialElementWhenReady().then(hasMovedFocus=>{hasMovedFocus||\"function\"!=typeof this._elementRef.nativeElement.focus||this._elementRef.nativeElement.focus()})}_restoreFocus(){this.autoFocus&&(this._elementFocusedBeforeDrawerWasOpened?this._focusMonitor.focusVia(this._elementFocusedBeforeDrawerWasOpened,this._openedVia):this._elementRef.nativeElement.blur(),this._elementFocusedBeforeDrawerWasOpened=null,this._openedVia=null)}_isFocusWithinDrawer(){var _a;const activeEl=null===(_a=this._doc)||void 0===_a?void 0:_a.activeElement;return!!activeEl&&this._elementRef.nativeElement.contains(activeEl)}ngAfterContentInit(){this._focusTrap=this._focusTrapFactory.create(this._elementRef.nativeElement),this._updateFocusTrapState()}ngAfterContentChecked(){this._platform.isBrowser&&(this._enableAnimations=!0)}ngOnDestroy(){this._focusTrap&&this._focusTrap.destroy(),this._animationStarted.complete(),this._animationEnd.complete(),this._modeChanged.complete(),this._destroyed.next(),this._destroyed.complete()}open(openedVia){return this.toggle(!0,openedVia)}close(){return this.toggle(!1)}_closeViaBackdropClick(){return this._setOpen(!1,!0)}toggle(isOpen=!this.opened,openedVia){return this._setOpen(isOpen,!isOpen&&this._isFocusWithinDrawer(),openedVia)}_setOpen(isOpen,restoreFocus,openedVia=\"program\"){return this._opened=isOpen,isOpen?(this._animationState=this._enableAnimations?\"open\":\"open-instant\",this._openedVia=openedVia):(this._animationState=\"void\",restoreFocus&&this._restoreFocus()),this._updateFocusTrapState(),new Promise(resolve=>{this.openedChange.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_15__.a)(1)).subscribe(open=>resolve(open?\"open\":\"close\"))})}_getWidth(){return this._elementRef.nativeElement&&this._elementRef.nativeElement.offsetWidth||0}_updateFocusTrapState(){this._focusTrap&&(this._focusTrap.enabled=this.opened&&\"side\"!==this.mode)}_animationStartListener(event){this._animationStarted.next(event)}_animationDoneListener(event){this._animationEnd.next(event)}}return MatDrawer.ɵfac=function(t){return new(t||MatDrawer)(_angular_core__WEBPACK_IMPORTED_MODULE_3__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_3__.m),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Tb(_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_20__.i),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Tb(_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_20__.h),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Tb(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_0__.a),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_3__.F),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Tb(_angular_common__WEBPACK_IMPORTED_MODULE_2__.d,8),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Tb(MAT_DRAWER_CONTAINER,8))},MatDrawer.ɵcmp=_angular_core__WEBPACK_IMPORTED_MODULE_3__.Nb({type:MatDrawer,selectors:[[\"mat-drawer\"]],hostAttrs:[\"tabIndex\",\"-1\",1,\"mat-drawer\"],hostVars:12,hostBindings:function(rf,ctx){1&rf&&_angular_core__WEBPACK_IMPORTED_MODULE_3__.Qc(\"@transform.start\",function($event){return ctx._animationStartListener($event)})(\"@transform.done\",function($event){return ctx._animationDoneListener($event)}),2&rf&&(_angular_core__WEBPACK_IMPORTED_MODULE_3__.Hb(\"align\",null),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Rc(\"@transform\",ctx._animationState),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Lb(\"mat-drawer-end\",\"end\"===ctx.position)(\"mat-drawer-over\",\"over\"===ctx.mode)(\"mat-drawer-push\",\"push\"===ctx.mode)(\"mat-drawer-side\",\"side\"===ctx.mode)(\"mat-drawer-opened\",ctx.opened))},inputs:{position:\"position\",mode:\"mode\",disableClose:\"disableClose\",autoFocus:\"autoFocus\",opened:\"opened\"},outputs:{openedChange:\"openedChange\",_openedStream:\"opened\",openedStart:\"openedStart\",_closedStream:\"closed\",closedStart:\"closedStart\",onPositionChanged:\"positionChanged\"},exportAs:[\"matDrawer\"],ngContentSelectors:_c0,decls:2,vars:0,consts:[[\"cdkScrollable\",\"\",1,\"mat-drawer-inner-container\"]],template:function(rf,ctx){1&rf&&(_angular_core__WEBPACK_IMPORTED_MODULE_3__.sc(),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Zb(0,\"div\",0),_angular_core__WEBPACK_IMPORTED_MODULE_3__.rc(1),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Yb())},directives:[_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__.a],encapsulation:2,data:{animation:[matDrawerAnimations.transformDrawer]},changeDetection:0}),MatDrawer})(),MatDrawerContainer=(()=>{class MatDrawerContainer{constructor(_dir,_element,_ngZone,_changeDetectorRef,viewportRuler,defaultAutosize=!1,_animationMode){this._dir=_dir,this._element=_element,this._ngZone=_ngZone,this._changeDetectorRef=_changeDetectorRef,this._animationMode=_animationMode,this._drawers=new _angular_core__WEBPACK_IMPORTED_MODULE_3__.J,this.backdropClick=new _angular_core__WEBPACK_IMPORTED_MODULE_3__.p,this._destroyed=new rxjs__WEBPACK_IMPORTED_MODULE_7__.a,this._doCheckSubject=new rxjs__WEBPACK_IMPORTED_MODULE_7__.a,this._contentMargins={left:null,right:null},this._contentMarginChanges=new rxjs__WEBPACK_IMPORTED_MODULE_7__.a,_dir&&_dir.change.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__.a)(this._destroyed)).subscribe(()=>{this._validateDrawers(),this.updateContentMargins()}),viewportRuler.change().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__.a)(this._destroyed)).subscribe(()=>this.updateContentMargins()),this._autosize=defaultAutosize}get start(){return this._start}get end(){return this._end}get autosize(){return this._autosize}set autosize(value){this._autosize=Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__.c)(value)}get hasBackdrop(){return null==this._backdropOverride?!this._start||\"side\"!==this._start.mode||!this._end||\"side\"!==this._end.mode:this._backdropOverride}set hasBackdrop(value){this._backdropOverride=null==value?null:Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__.c)(value)}get scrollable(){return this._userContent||this._content}ngAfterContentInit(){this._allDrawers.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_16__.a)(this._allDrawers),Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__.a)(this._destroyed)).subscribe(drawer=>{this._drawers.reset(drawer.filter(item=>!item._container||item._container===this)),this._drawers.notifyOnChanges()}),this._drawers.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_16__.a)(null)).subscribe(()=>{this._validateDrawers(),this._drawers.forEach(drawer=>{this._watchDrawerToggle(drawer),this._watchDrawerPosition(drawer),this._watchDrawerMode(drawer)}),(!this._drawers.length||this._isDrawerOpen(this._start)||this._isDrawerOpen(this._end))&&this.updateContentMargins(),this._changeDetectorRef.markForCheck()}),this._ngZone.runOutsideAngular(()=>{this._doCheckSubject.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_17__.a)(10),Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__.a)(this._destroyed)).subscribe(()=>this.updateContentMargins())})}ngOnDestroy(){this._contentMarginChanges.complete(),this._doCheckSubject.complete(),this._drawers.destroy(),this._destroyed.next(),this._destroyed.complete()}open(){this._drawers.forEach(drawer=>drawer.open())}close(){this._drawers.forEach(drawer=>drawer.close())}updateContentMargins(){let left=0,right=0;if(this._left&&this._left.opened)if(\"side\"==this._left.mode)left+=this._left._getWidth();else if(\"push\"==this._left.mode){const width=this._left._getWidth();left+=width,right-=width}if(this._right&&this._right.opened)if(\"side\"==this._right.mode)right+=this._right._getWidth();else if(\"push\"==this._right.mode){const width=this._right._getWidth();right+=width,left-=width}left=left||null,right=right||null,left===this._contentMargins.left&&right===this._contentMargins.right||(this._contentMargins={left:left,right:right},this._ngZone.run(()=>this._contentMarginChanges.next(this._contentMargins)))}ngDoCheck(){this._autosize&&this._isPushed()&&this._ngZone.runOutsideAngular(()=>this._doCheckSubject.next())}_watchDrawerToggle(drawer){drawer._animationStarted.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.a)(event=>event.fromState!==event.toState),Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__.a)(this._drawers.changes)).subscribe(event=>{\"open-instant\"!==event.toState&&\"NoopAnimations\"!==this._animationMode&&this._element.nativeElement.classList.add(\"mat-drawer-transition\"),this.updateContentMargins(),this._changeDetectorRef.markForCheck()}),\"side\"!==drawer.mode&&drawer.openedChange.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__.a)(this._drawers.changes)).subscribe(()=>this._setContainerClass(drawer.opened))}_watchDrawerPosition(drawer){drawer&&drawer.onPositionChanged.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__.a)(this._drawers.changes)).subscribe(()=>{this._ngZone.onMicrotaskEmpty.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_15__.a)(1)).subscribe(()=>{this._validateDrawers()})})}_watchDrawerMode(drawer){drawer&&drawer._modeChanged.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__.a)(Object(rxjs__WEBPACK_IMPORTED_MODULE_9__.a)(this._drawers.changes,this._destroyed))).subscribe(()=>{this.updateContentMargins(),this._changeDetectorRef.markForCheck()})}_setContainerClass(isAdd){const classList=this._element.nativeElement.classList,className=\"mat-drawer-container-has-open\";isAdd?classList.add(className):classList.remove(className)}_validateDrawers(){this._start=this._end=null,this._drawers.forEach(drawer=>{\"end\"==drawer.position?this._end=drawer:this._start=drawer}),this._right=this._left=null,this._dir&&\"rtl\"===this._dir.value?(this._left=this._end,this._right=this._start):(this._left=this._start,this._right=this._end)}_isPushed(){return this._isDrawerOpen(this._start)&&\"over\"!=this._start.mode||this._isDrawerOpen(this._end)&&\"over\"!=this._end.mode}_onBackdropClicked(){this.backdropClick.emit(),this._closeModalDrawersViaBackdrop()}_closeModalDrawersViaBackdrop(){[this._start,this._end].filter(drawer=>drawer&&!drawer.disableClose&&this._canHaveBackdrop(drawer)).forEach(drawer=>drawer._closeViaBackdropClick())}_isShowingBackdrop(){return this._isDrawerOpen(this._start)&&this._canHaveBackdrop(this._start)||this._isDrawerOpen(this._end)&&this._canHaveBackdrop(this._end)}_canHaveBackdrop(drawer){return\"side\"!==drawer.mode||!!this._backdropOverride}_isDrawerOpen(drawer){return null!=drawer&&drawer.opened}}return MatDrawerContainer.ɵfac=function(t){return new(t||MatDrawerContainer)(_angular_core__WEBPACK_IMPORTED_MODULE_3__.Tb(_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_21__.b,8),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_3__.m),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_3__.F),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_3__.i),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Tb(_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__.e),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Tb(MAT_DRAWER_DEFAULT_AUTOSIZE),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Tb(_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_19__.a,8))},MatDrawerContainer.ɵcmp=_angular_core__WEBPACK_IMPORTED_MODULE_3__.Nb({type:MatDrawerContainer,selectors:[[\"mat-drawer-container\"]],contentQueries:function(rf,ctx,dirIndex){if(1&rf&&(_angular_core__WEBPACK_IMPORTED_MODULE_3__.Mb(dirIndex,MatDrawerContent,!0),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Mb(dirIndex,MatDrawer,!0)),2&rf){let _t;_angular_core__WEBPACK_IMPORTED_MODULE_3__.Fc(_t=_angular_core__WEBPACK_IMPORTED_MODULE_3__.kc())&&(ctx._content=_t.first),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Fc(_t=_angular_core__WEBPACK_IMPORTED_MODULE_3__.kc())&&(ctx._allDrawers=_t)}},viewQuery:function(rf,ctx){if(1&rf&&_angular_core__WEBPACK_IMPORTED_MODULE_3__.Zc(MatDrawerContent,!0),2&rf){let _t;_angular_core__WEBPACK_IMPORTED_MODULE_3__.Fc(_t=_angular_core__WEBPACK_IMPORTED_MODULE_3__.kc())&&(ctx._userContent=_t.first)}},hostAttrs:[1,\"mat-drawer-container\"],hostVars:2,hostBindings:function(rf,ctx){2&rf&&_angular_core__WEBPACK_IMPORTED_MODULE_3__.Lb(\"mat-drawer-container-explicit-backdrop\",ctx._backdropOverride)},inputs:{autosize:\"autosize\",hasBackdrop:\"hasBackdrop\"},outputs:{backdropClick:\"backdropClick\"},exportAs:[\"matDrawerContainer\"],features:[_angular_core__WEBPACK_IMPORTED_MODULE_3__.Fb([{provide:MAT_DRAWER_CONTAINER,useExisting:MatDrawerContainer}])],ngContentSelectors:_c2,decls:4,vars:2,consts:[[\"class\",\"mat-drawer-backdrop\",3,\"mat-drawer-shown\",\"click\",4,\"ngIf\"],[4,\"ngIf\"],[1,\"mat-drawer-backdrop\",3,\"click\"]],template:function(rf,ctx){1&rf&&(_angular_core__WEBPACK_IMPORTED_MODULE_3__.sc(_c1),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Sc(0,MatDrawerContainer_div_0_Template,1,2,\"div\",0),_angular_core__WEBPACK_IMPORTED_MODULE_3__.rc(1),_angular_core__WEBPACK_IMPORTED_MODULE_3__.rc(2,1),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Sc(3,MatDrawerContainer_mat_drawer_content_3_Template,2,0,\"mat-drawer-content\",1)),2&rf&&(_angular_core__WEBPACK_IMPORTED_MODULE_3__.tc(\"ngIf\",ctx.hasBackdrop),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Gb(3),_angular_core__WEBPACK_IMPORTED_MODULE_3__.tc(\"ngIf\",!ctx._content))},directives:[_angular_common__WEBPACK_IMPORTED_MODULE_2__.n,MatDrawerContent],styles:[_c5],encapsulation:2,changeDetection:0}),MatDrawerContainer})(),MatSidenavContent=(()=>{class MatSidenavContent extends MatDrawerContent{constructor(changeDetectorRef,container,elementRef,scrollDispatcher,ngZone){super(changeDetectorRef,container,elementRef,scrollDispatcher,ngZone)}}return MatSidenavContent.ɵfac=function(t){return new(t||MatSidenavContent)(_angular_core__WEBPACK_IMPORTED_MODULE_3__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_3__.i),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Tb(Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__.Z)(()=>MatSidenavContainer)),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_3__.m),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Tb(_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__.c),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Tb(_angular_core__WEBPACK_IMPORTED_MODULE_3__.F))},MatSidenavContent.ɵcmp=_angular_core__WEBPACK_IMPORTED_MODULE_3__.Nb({type:MatSidenavContent,selectors:[[\"mat-sidenav-content\"]],hostAttrs:[1,\"mat-drawer-content\",\"mat-sidenav-content\"],hostVars:4,hostBindings:function(rf,ctx){2&rf&&_angular_core__WEBPACK_IMPORTED_MODULE_3__.Pc(\"margin-left\",ctx._container._contentMargins.left,\"px\")(\"margin-right\",ctx._container._contentMargins.right,\"px\")},features:[_angular_core__WEBPACK_IMPORTED_MODULE_3__.Db],ngContentSelectors:_c0,decls:1,vars:0,template:function(rf,ctx){1&rf&&(_angular_core__WEBPACK_IMPORTED_MODULE_3__.sc(),_angular_core__WEBPACK_IMPORTED_MODULE_3__.rc(0))},encapsulation:2,changeDetection:0}),MatSidenavContent})(),MatSidenav=(()=>{class MatSidenav extends MatDrawer{constructor(){super(...arguments),this._fixedInViewport=!1,this._fixedTopGap=0,this._fixedBottomGap=0}get fixedInViewport(){return this._fixedInViewport}set fixedInViewport(value){this._fixedInViewport=Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__.c)(value)}get fixedTopGap(){return this._fixedTopGap}set fixedTopGap(value){this._fixedTopGap=Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__.f)(value)}get fixedBottomGap(){return this._fixedBottomGap}set fixedBottomGap(value){this._fixedBottomGap=Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__.f)(value)}}return MatSidenav.ɵfac=function(t){return ɵMatSidenav_BaseFactory(t||MatSidenav)},MatSidenav.ɵcmp=_angular_core__WEBPACK_IMPORTED_MODULE_3__.Nb({type:MatSidenav,selectors:[[\"mat-sidenav\"]],hostAttrs:[\"tabIndex\",\"-1\",1,\"mat-drawer\",\"mat-sidenav\"],hostVars:17,hostBindings:function(rf,ctx){2&rf&&(_angular_core__WEBPACK_IMPORTED_MODULE_3__.Hb(\"align\",null),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Pc(\"top\",ctx.fixedInViewport?ctx.fixedTopGap:null,\"px\")(\"bottom\",ctx.fixedInViewport?ctx.fixedBottomGap:null,\"px\"),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Lb(\"mat-drawer-end\",\"end\"===ctx.position)(\"mat-drawer-over\",\"over\"===ctx.mode)(\"mat-drawer-push\",\"push\"===ctx.mode)(\"mat-drawer-side\",\"side\"===ctx.mode)(\"mat-drawer-opened\",ctx.opened)(\"mat-sidenav-fixed\",ctx.fixedInViewport))},inputs:{fixedInViewport:\"fixedInViewport\",fixedTopGap:\"fixedTopGap\",fixedBottomGap:\"fixedBottomGap\"},exportAs:[\"matSidenav\"],features:[_angular_core__WEBPACK_IMPORTED_MODULE_3__.Db],ngContentSelectors:_c0,decls:2,vars:0,consts:[[\"cdkScrollable\",\"\",1,\"mat-drawer-inner-container\"]],template:function(rf,ctx){1&rf&&(_angular_core__WEBPACK_IMPORTED_MODULE_3__.sc(),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Zb(0,\"div\",0),_angular_core__WEBPACK_IMPORTED_MODULE_3__.rc(1),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Yb())},directives:[_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__.a],encapsulation:2,data:{animation:[matDrawerAnimations.transformDrawer]},changeDetection:0}),MatSidenav})();const ɵMatSidenav_BaseFactory=_angular_core__WEBPACK_IMPORTED_MODULE_3__.bc(MatSidenav);let MatSidenavContainer=(()=>{class MatSidenavContainer extends MatDrawerContainer{}return MatSidenavContainer.ɵfac=function(t){return ɵMatSidenavContainer_BaseFactory(t||MatSidenavContainer)},MatSidenavContainer.ɵcmp=_angular_core__WEBPACK_IMPORTED_MODULE_3__.Nb({type:MatSidenavContainer,selectors:[[\"mat-sidenav-container\"]],contentQueries:function(rf,ctx,dirIndex){if(1&rf&&(_angular_core__WEBPACK_IMPORTED_MODULE_3__.Mb(dirIndex,MatSidenavContent,!0),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Mb(dirIndex,MatSidenav,!0)),2&rf){let _t;_angular_core__WEBPACK_IMPORTED_MODULE_3__.Fc(_t=_angular_core__WEBPACK_IMPORTED_MODULE_3__.kc())&&(ctx._content=_t.first),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Fc(_t=_angular_core__WEBPACK_IMPORTED_MODULE_3__.kc())&&(ctx._allDrawers=_t)}},hostAttrs:[1,\"mat-drawer-container\",\"mat-sidenav-container\"],hostVars:2,hostBindings:function(rf,ctx){2&rf&&_angular_core__WEBPACK_IMPORTED_MODULE_3__.Lb(\"mat-drawer-container-explicit-backdrop\",ctx._backdropOverride)},exportAs:[\"matSidenavContainer\"],features:[_angular_core__WEBPACK_IMPORTED_MODULE_3__.Fb([{provide:MAT_DRAWER_CONTAINER,useExisting:MatSidenavContainer}]),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Db],ngContentSelectors:_c4,decls:4,vars:2,consts:[[\"class\",\"mat-drawer-backdrop\",3,\"mat-drawer-shown\",\"click\",4,\"ngIf\"],[\"cdkScrollable\",\"\",4,\"ngIf\"],[1,\"mat-drawer-backdrop\",3,\"click\"],[\"cdkScrollable\",\"\"]],template:function(rf,ctx){1&rf&&(_angular_core__WEBPACK_IMPORTED_MODULE_3__.sc(_c3),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Sc(0,MatSidenavContainer_div_0_Template,1,2,\"div\",0),_angular_core__WEBPACK_IMPORTED_MODULE_3__.rc(1),_angular_core__WEBPACK_IMPORTED_MODULE_3__.rc(2,1),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Sc(3,MatSidenavContainer_mat_sidenav_content_3_Template,2,0,\"mat-sidenav-content\",1)),2&rf&&(_angular_core__WEBPACK_IMPORTED_MODULE_3__.tc(\"ngIf\",ctx.hasBackdrop),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Gb(3),_angular_core__WEBPACK_IMPORTED_MODULE_3__.tc(\"ngIf\",!ctx._content))},directives:[_angular_common__WEBPACK_IMPORTED_MODULE_2__.n,MatSidenavContent,_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__.a],styles:[_c5],encapsulation:2,changeDetection:0}),MatSidenavContainer})();const ɵMatSidenavContainer_BaseFactory=_angular_core__WEBPACK_IMPORTED_MODULE_3__.bc(MatSidenavContainer);let MatSidenavModule=(()=>{class MatSidenavModule{}return MatSidenavModule.ɵmod=_angular_core__WEBPACK_IMPORTED_MODULE_3__.Rb({type:MatSidenavModule}),MatSidenavModule.ɵinj=_angular_core__WEBPACK_IMPORTED_MODULE_3__.Qb({factory:function(t){return new(t||MatSidenavModule)},imports:[[_angular_common__WEBPACK_IMPORTED_MODULE_2__.c,_angular_material_core__WEBPACK_IMPORTED_MODULE_4__.j,_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_0__.b,_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__.b],_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__.b,_angular_material_core__WEBPACK_IMPORTED_MODULE_4__.j]}),MatSidenavModule})()}}]);","name":"6-es2015.2ca373bd12fac8fc762f.js","input":"(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[6],{\n\n/***/ \"XhcP\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export MAT_DRAWER_DEFAULT_AUTOSIZE */\n/* unused harmony export MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return MatDrawer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return MatDrawerContainer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return MatDrawerContent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return MatSidenav; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return MatSidenavContainer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return MatSidenavContent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return MatSidenavModule; });\n/* unused harmony export matDrawerAnimations */\n/* unused harmony export throwMatDuplicatedDrawerError */\n/* unused harmony export ɵangular_material_src_material_sidenav_sidenav_a */\n/* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"nLfN\");\n/* harmony import */ var _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"vxfF\");\n/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"ofXK\");\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"fXoL\");\n/* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"FKr1\");\n/* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"8LU1\");\n/* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(\"FtGj\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(\"XNiG\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(\"xgIS\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(\"VRyK\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(\"pLZG\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(\"lJxs\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(\"CqXF\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(\"1G5W\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(\"/uUt\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(\"IzEk\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(\"JX91\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(\"Kj3r\");\n/* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(\"R0Ic\");\n/* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(\"R1ws\");\n/* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(\"u47x\");\n/* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(\"cH1L\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Animations used by the Material drawers.\n * @docs-private\n */\n\n\n\n\n\n\nconst _c0 = [\"*\"];\nfunction MatDrawerContainer_div_0_Template(rf, ctx) {\n    if (rf & 1) {\n        const _r3 = _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵgetCurrentView */ \"ac\"]();\n        _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵelementStart */ \"Zb\"](0, \"div\", 2);\n        _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵlistener */ \"jc\"](\"click\", function MatDrawerContainer_div_0_Template_div_click_0_listener() { _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵrestoreView */ \"Ic\"](_r3); const ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵnextContext */ \"nc\"](); return ctx_r2._onBackdropClicked(); });\n        _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵelementEnd */ \"Yb\"]();\n    }\n    if (rf & 2) {\n        const ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵnextContext */ \"nc\"]();\n        _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵclassProp */ \"Lb\"](\"mat-drawer-shown\", ctx_r0._isShowingBackdrop());\n    }\n}\nfunction MatDrawerContainer_mat_drawer_content_3_Template(rf, ctx) {\n    if (rf & 1) {\n        _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵelementStart */ \"Zb\"](0, \"mat-drawer-content\");\n        _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵprojection */ \"rc\"](1, 2);\n        _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵelementEnd */ \"Yb\"]();\n    }\n}\nconst _c1 = [[[\"mat-drawer\"]], [[\"mat-drawer-content\"]], \"*\"];\nconst _c2 = [\"mat-drawer\", \"mat-drawer-content\", \"*\"];\nfunction MatSidenavContainer_div_0_Template(rf, ctx) {\n    if (rf & 1) {\n        const _r3 = _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵgetCurrentView */ \"ac\"]();\n        _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵelementStart */ \"Zb\"](0, \"div\", 2);\n        _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵlistener */ \"jc\"](\"click\", function MatSidenavContainer_div_0_Template_div_click_0_listener() { _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵrestoreView */ \"Ic\"](_r3); const ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵnextContext */ \"nc\"](); return ctx_r2._onBackdropClicked(); });\n        _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵelementEnd */ \"Yb\"]();\n    }\n    if (rf & 2) {\n        const ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵnextContext */ \"nc\"]();\n        _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵclassProp */ \"Lb\"](\"mat-drawer-shown\", ctx_r0._isShowingBackdrop());\n    }\n}\nfunction MatSidenavContainer_mat_sidenav_content_3_Template(rf, ctx) {\n    if (rf & 1) {\n        _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵelementStart */ \"Zb\"](0, \"mat-sidenav-content\", 3);\n        _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵprojection */ \"rc\"](1, 2);\n        _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵelementEnd */ \"Yb\"]();\n    }\n}\nconst _c3 = [[[\"mat-sidenav\"]], [[\"mat-sidenav-content\"]], \"*\"];\nconst _c4 = [\"mat-sidenav\", \"mat-sidenav-content\", \"*\"];\nconst _c5 = \".mat-drawer-container{position:relative;z-index:1;box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}.cdk-high-contrast-active .mat-drawer-backdrop{opacity:.5}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}.cdk-high-contrast-active .mat-drawer,.cdk-high-contrast-active [dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}.cdk-high-contrast-active [dir=rtl] .mat-drawer,.cdk-high-contrast-active .mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer{transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch}.mat-sidenav-fixed{position:fixed}\\n\";\nconst matDrawerAnimations = {\n    /** Animation that slides a drawer in and out. */\n    transformDrawer: /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_18__[/* trigger */ \"n\"])('transform', [\n        // We remove the `transform` here completely, rather than setting it to zero, because:\n        // 1. Having a transform can cause elements with ripples or an animated\n        //    transform to shift around in Chrome with an RTL layout (see #10023).\n        // 2. 3d transforms causes text to appear blurry on IE and Edge.\n        /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_18__[/* state */ \"k\"])('open, open-instant', /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_18__[/* style */ \"l\"])({\n            'transform': 'none',\n            'visibility': 'visible',\n        })),\n        /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_18__[/* state */ \"k\"])('void', /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_18__[/* style */ \"l\"])({\n            // Avoids the shadow showing up when closed in SSR.\n            'box-shadow': 'none',\n            'visibility': 'hidden',\n        })),\n        /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_18__[/* transition */ \"m\"])('void => open-instant', /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_18__[/* animate */ \"e\"])('0ms')),\n        /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_18__[/* transition */ \"m\"])('void <=> open, open-instant => void', /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_18__[/* animate */ \"e\"])('400ms cubic-bezier(0.25, 0.8, 0.25, 1)'))\n    ])\n};\n/**\n * Throws an exception when two MatDrawer are matching the same position.\n * @docs-private\n */\nfunction throwMatDuplicatedDrawerError(position) {\n    throw Error(`A drawer was already declared for 'position=\"${position}\"'`);\n}\n/** Configures whether drawers should use auto sizing by default. */\nconst MAT_DRAWER_DEFAULT_AUTOSIZE = /*@__PURE__*/ new _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* InjectionToken */ \"u\"]('MAT_DRAWER_DEFAULT_AUTOSIZE', {\n    providedIn: 'root',\n    factory: MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY,\n});\n/**\n * Used to provide a drawer container to a drawer while avoiding circular references.\n * @docs-private\n */\nconst MAT_DRAWER_CONTAINER = /*@__PURE__*/ new _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* InjectionToken */ \"u\"]('MAT_DRAWER_CONTAINER');\n/** @docs-private */\nfunction MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY() {\n    return false;\n}\nlet MatDrawerContent = /*@__PURE__*/ (() => {\n    class MatDrawerContent extends _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__[/* CdkScrollable */ \"a\"] {\n        constructor(_changeDetectorRef, _container, elementRef, scrollDispatcher, ngZone) {\n            super(elementRef, scrollDispatcher, ngZone);\n            this._changeDetectorRef = _changeDetectorRef;\n            this._container = _container;\n        }\n        ngAfterContentInit() {\n            this._container._contentMarginChanges.subscribe(() => {\n                this._changeDetectorRef.markForCheck();\n            });\n        }\n    }\n    MatDrawerContent.ɵfac = function MatDrawerContent_Factory(t) { return new (t || MatDrawerContent)(_angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ChangeDetectorRef */ \"i\"]), _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Tb\"](Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__[/* forwardRef */ \"Z\"])(() => MatDrawerContainer)), _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ElementRef */ \"m\"]), _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__[/* ScrollDispatcher */ \"c\"]), _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_3__[/* NgZone */ \"F\"])); };\n    MatDrawerContent.ɵcmp = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdefineComponent */ \"Nb\"]({ type: MatDrawerContent, selectors: [[\"mat-drawer-content\"]], hostAttrs: [1, \"mat-drawer-content\"], hostVars: 4, hostBindings: function MatDrawerContent_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵstyleProp */ \"Pc\"](\"margin-left\", ctx._container._contentMargins.left, \"px\")(\"margin-right\", ctx._container._contentMargins.right, \"px\");\n            }\n        }, features: [_angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵInheritDefinitionFeature */ \"Db\"]], ngContentSelectors: _c0, decls: 1, vars: 0, template: function MatDrawerContent_Template(rf, ctx) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵprojectionDef */ \"sc\"]();\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵprojection */ \"rc\"](0);\n            }\n        }, encapsulation: 2, changeDetection: 0 });\n    return MatDrawerContent;\n})();\nlet MatDrawer = /*@__PURE__*/ (() => {\n    class MatDrawer {\n        constructor(_elementRef, _focusTrapFactory, _focusMonitor, _platform, _ngZone, _doc, _container) {\n            this._elementRef = _elementRef;\n            this._focusTrapFactory = _focusTrapFactory;\n            this._focusMonitor = _focusMonitor;\n            this._platform = _platform;\n            this._ngZone = _ngZone;\n            this._doc = _doc;\n            this._container = _container;\n            this._elementFocusedBeforeDrawerWasOpened = null;\n            /** Whether the drawer is initialized. Used for disabling the initial animation. */\n            this._enableAnimations = false;\n            this._position = 'start';\n            this._mode = 'over';\n            this._disableClose = false;\n            this._opened = false;\n            /** Emits whenever the drawer has started animating. */\n            this._animationStarted = new rxjs__WEBPACK_IMPORTED_MODULE_7__[/* Subject */ \"a\"]();\n            /** Emits whenever the drawer is done animating. */\n            this._animationEnd = new rxjs__WEBPACK_IMPORTED_MODULE_7__[/* Subject */ \"a\"]();\n            /** Current state of the sidenav animation. */\n            // @HostBinding is used in the class as it is expected to be extended.  Since @Component decorator\n            // metadata is not inherited by child classes, instead the host binding data is defined in a way\n            // that can be inherited.\n            // tslint:disable:no-host-decorator-in-concrete\n            this._animationState = 'void';\n            /** Event emitted when the drawer open state is changed. */\n            this.openedChange =\n                // Note this has to be async in order to avoid some issues with two-bindings (see #8872).\n                new _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* EventEmitter */ \"p\"](/* isAsync */ true);\n            /** Event emitted when the drawer has been opened. */\n            this._openedStream = this.openedChange.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__[/* filter */ \"a\"])(o => o), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_11__[/* map */ \"a\"])(() => { }));\n            /** Event emitted when the drawer has started opening. */\n            this.openedStart = this._animationStarted.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__[/* filter */ \"a\"])(e => e.fromState !== e.toState && e.toState.indexOf('open') === 0), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_12__[/* mapTo */ \"a\"])(undefined));\n            /** Event emitted when the drawer has been closed. */\n            this._closedStream = this.openedChange.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__[/* filter */ \"a\"])(o => !o), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_11__[/* map */ \"a\"])(() => { }));\n            /** Event emitted when the drawer has started closing. */\n            this.closedStart = this._animationStarted.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__[/* filter */ \"a\"])(e => e.fromState !== e.toState && e.toState === 'void'), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_12__[/* mapTo */ \"a\"])(undefined));\n            /** Emits when the component is destroyed. */\n            this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_7__[/* Subject */ \"a\"]();\n            /** Event emitted when the drawer's position changes. */\n            // tslint:disable-next-line:no-output-on-prefix\n            this.onPositionChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* EventEmitter */ \"p\"]();\n            /**\n             * An observable that emits when the drawer mode changes. This is used by the drawer container to\n             * to know when to when the mode changes so it can adapt the margins on the content.\n             */\n            this._modeChanged = new rxjs__WEBPACK_IMPORTED_MODULE_7__[/* Subject */ \"a\"]();\n            this.openedChange.subscribe((opened) => {\n                if (opened) {\n                    if (this._doc) {\n                        this._elementFocusedBeforeDrawerWasOpened = this._doc.activeElement;\n                    }\n                    this._takeFocus();\n                }\n                else if (this._isFocusWithinDrawer()) {\n                    this._restoreFocus();\n                }\n            });\n            /**\n             * Listen to `keydown` events outside the zone so that change detection is not run every\n             * time a key is pressed. Instead we re-enter the zone only if the `ESC` key is pressed\n             * and we don't have close disabled.\n             */\n            this._ngZone.runOutsideAngular(() => {\n                Object(rxjs__WEBPACK_IMPORTED_MODULE_8__[/* fromEvent */ \"a\"])(this._elementRef.nativeElement, 'keydown').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__[/* filter */ \"a\"])(event => {\n                    return event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_6__[/* ESCAPE */ \"h\"] && !this.disableClose && !Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_6__[/* hasModifierKey */ \"t\"])(event);\n                }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__[/* takeUntil */ \"a\"])(this._destroyed)).subscribe(event => this._ngZone.run(() => {\n                    this.close();\n                    event.stopPropagation();\n                    event.preventDefault();\n                }));\n            });\n            // We need a Subject with distinctUntilChanged, because the `done` event\n            // fires twice on some browsers. See https://github.com/angular/angular/issues/24084\n            this._animationEnd.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__[/* distinctUntilChanged */ \"a\"])((x, y) => {\n                return x.fromState === y.fromState && x.toState === y.toState;\n            })).subscribe((event) => {\n                const { fromState, toState } = event;\n                if ((toState.indexOf('open') === 0 && fromState === 'void') ||\n                    (toState === 'void' && fromState.indexOf('open') === 0)) {\n                    this.openedChange.emit(this._opened);\n                }\n            });\n        }\n        /** The side that the drawer is attached to. */\n        get position() { return this._position; }\n        set position(value) {\n            // Make sure we have a valid value.\n            value = value === 'end' ? 'end' : 'start';\n            if (value != this._position) {\n                this._position = value;\n                this.onPositionChanged.emit();\n            }\n        }\n        /** Mode of the drawer; one of 'over', 'push' or 'side'. */\n        get mode() { return this._mode; }\n        set mode(value) {\n            this._mode = value;\n            this._updateFocusTrapState();\n            this._modeChanged.next();\n        }\n        /** Whether the drawer can be closed with the escape key or by clicking on the backdrop. */\n        get disableClose() { return this._disableClose; }\n        set disableClose(value) { this._disableClose = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__[/* coerceBooleanProperty */ \"c\"])(value); }\n        /**\n         * Whether the drawer should focus the first focusable element automatically when opened.\n         * Defaults to false in when `mode` is set to `side`, otherwise defaults to `true`. If explicitly\n         * enabled, focus will be moved into the sidenav in `side` mode as well.\n         */\n        get autoFocus() {\n            const value = this._autoFocus;\n            // Note that usually we disable auto focusing in `side` mode, because we don't know how the\n            // sidenav is being used, but in some cases it still makes sense to do it. If the consumer\n            // explicitly enabled `autoFocus`, we take it as them always wanting to enable it.\n            return value == null ? this.mode !== 'side' : value;\n        }\n        set autoFocus(value) { this._autoFocus = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__[/* coerceBooleanProperty */ \"c\"])(value); }\n        /**\n         * Whether the drawer is opened. We overload this because we trigger an event when it\n         * starts or end.\n         */\n        get opened() { return this._opened; }\n        set opened(value) { this.toggle(Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__[/* coerceBooleanProperty */ \"c\"])(value)); }\n        /**\n         * Moves focus into the drawer. Note that this works even if\n         * the focus trap is disabled in `side` mode.\n         */\n        _takeFocus() {\n            if (!this.autoFocus || !this._focusTrap) {\n                return;\n            }\n            this._focusTrap.focusInitialElementWhenReady().then(hasMovedFocus => {\n                // If there were no focusable elements, focus the sidenav itself so the keyboard navigation\n                // still works. We need to check that `focus` is a function due to Universal.\n                if (!hasMovedFocus && typeof this._elementRef.nativeElement.focus === 'function') {\n                    this._elementRef.nativeElement.focus();\n                }\n            });\n        }\n        /**\n         * Restores focus to the element that was originally focused when the drawer opened.\n         * If no element was focused at that time, the focus will be restored to the drawer.\n         */\n        _restoreFocus() {\n            if (!this.autoFocus) {\n                return;\n            }\n            // Note that we don't check via `instanceof HTMLElement` so that we can cover SVGs as well.\n            if (this._elementFocusedBeforeDrawerWasOpened) {\n                this._focusMonitor.focusVia(this._elementFocusedBeforeDrawerWasOpened, this._openedVia);\n            }\n            else {\n                this._elementRef.nativeElement.blur();\n            }\n            this._elementFocusedBeforeDrawerWasOpened = null;\n            this._openedVia = null;\n        }\n        /** Whether focus is currently within the drawer. */\n        _isFocusWithinDrawer() {\n            var _a;\n            const activeEl = (_a = this._doc) === null || _a === void 0 ? void 0 : _a.activeElement;\n            return !!activeEl && this._elementRef.nativeElement.contains(activeEl);\n        }\n        ngAfterContentInit() {\n            this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);\n            this._updateFocusTrapState();\n        }\n        ngAfterContentChecked() {\n            // Enable the animations after the lifecycle hooks have run, in order to avoid animating\n            // drawers that are open by default. When we're on the server, we shouldn't enable the\n            // animations, because we don't want the drawer to animate the first time the user sees\n            // the page.\n            if (this._platform.isBrowser) {\n                this._enableAnimations = true;\n            }\n        }\n        ngOnDestroy() {\n            if (this._focusTrap) {\n                this._focusTrap.destroy();\n            }\n            this._animationStarted.complete();\n            this._animationEnd.complete();\n            this._modeChanged.complete();\n            this._destroyed.next();\n            this._destroyed.complete();\n        }\n        /**\n         * Open the drawer.\n         * @param openedVia Whether the drawer was opened by a key press, mouse click or programmatically.\n         * Used for focus management after the sidenav is closed.\n         */\n        open(openedVia) {\n            return this.toggle(true, openedVia);\n        }\n        /** Close the drawer. */\n        close() {\n            return this.toggle(false);\n        }\n        /** Closes the drawer with context that the backdrop was clicked. */\n        _closeViaBackdropClick() {\n            // If the drawer is closed upon a backdrop click, we always want to restore focus. We\n            // don't need to check whether focus is currently in the drawer, as clicking on the\n            // backdrop causes blurring of the active element.\n            return this._setOpen(/* isOpen */ false, /* restoreFocus */ true);\n        }\n        /**\n         * Toggle this drawer.\n         * @param isOpen Whether the drawer should be open.\n         * @param openedVia Whether the drawer was opened by a key press, mouse click or programmatically.\n         * Used for focus management after the sidenav is closed.\n         */\n        toggle(isOpen = !this.opened, openedVia) {\n            // If the focus is currently inside the drawer content and we are closing the drawer,\n            // restore the focus to the initially focused element (when the drawer opened).\n            return this._setOpen(isOpen, /* restoreFocus */ !isOpen && this._isFocusWithinDrawer(), openedVia);\n        }\n        /**\n         * Toggles the opened state of the drawer.\n         * @param isOpen Whether the drawer should open or close.\n         * @param restoreFocus Whether focus should be restored on close.\n         * @param openedVia Focus origin that can be optionally set when opening a drawer. The\n         *   origin will be used later when focus is restored on drawer close.\n         */\n        _setOpen(isOpen, restoreFocus, openedVia = 'program') {\n            this._opened = isOpen;\n            if (isOpen) {\n                this._animationState = this._enableAnimations ? 'open' : 'open-instant';\n                this._openedVia = openedVia;\n            }\n            else {\n                this._animationState = 'void';\n                if (restoreFocus) {\n                    this._restoreFocus();\n                }\n            }\n            this._updateFocusTrapState();\n            return new Promise(resolve => {\n                this.openedChange.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_15__[/* take */ \"a\"])(1)).subscribe(open => resolve(open ? 'open' : 'close'));\n            });\n        }\n        _getWidth() {\n            return this._elementRef.nativeElement ? (this._elementRef.nativeElement.offsetWidth || 0) : 0;\n        }\n        /** Updates the enabled state of the focus trap. */\n        _updateFocusTrapState() {\n            if (this._focusTrap) {\n                // The focus trap is only enabled when the drawer is open in any mode other than side.\n                this._focusTrap.enabled = this.opened && this.mode !== 'side';\n            }\n        }\n        // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\n        // In Ivy the `host` bindings will be merged when this class is extended, whereas in\n        // ViewEngine they're overwritten.\n        // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\n        // tslint:disable-next-line:no-host-decorator-in-concrete\n        _animationStartListener(event) {\n            this._animationStarted.next(event);\n        }\n        // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\n        // In Ivy the `host` bindings will be merged when this class is extended, whereas in\n        // ViewEngine they're overwritten.\n        // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\n        // tslint:disable-next-line:no-host-decorator-in-concrete\n        _animationDoneListener(event) {\n            this._animationEnd.next(event);\n        }\n    }\n    MatDrawer.ɵfac = function MatDrawer_Factory(t) { return new (t || MatDrawer)(_angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ElementRef */ \"m\"]), _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_20__[/* FocusTrapFactory */ \"i\"]), _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_20__[/* FocusMonitor */ \"h\"]), _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_0__[/* Platform */ \"a\"]), _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_3__[/* NgZone */ \"F\"]), _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_common__WEBPACK_IMPORTED_MODULE_2__[/* DOCUMENT */ \"d\"], 8), _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Tb\"](MAT_DRAWER_CONTAINER, 8)); };\n    MatDrawer.ɵcmp = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdefineComponent */ \"Nb\"]({ type: MatDrawer, selectors: [[\"mat-drawer\"]], hostAttrs: [\"tabIndex\", \"-1\", 1, \"mat-drawer\"], hostVars: 12, hostBindings: function MatDrawer_HostBindings(rf, ctx) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵsyntheticHostListener */ \"Qc\"](\"@transform.start\", function MatDrawer_animation_transform_start_HostBindingHandler($event) { return ctx._animationStartListener($event); })(\"@transform.done\", function MatDrawer_animation_transform_done_HostBindingHandler($event) { return ctx._animationDoneListener($event); });\n            }\n            if (rf & 2) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵattribute */ \"Hb\"](\"align\", null);\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵsyntheticHostProperty */ \"Rc\"](\"@transform\", ctx._animationState);\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵclassProp */ \"Lb\"](\"mat-drawer-end\", ctx.position === \"end\")(\"mat-drawer-over\", ctx.mode === \"over\")(\"mat-drawer-push\", ctx.mode === \"push\")(\"mat-drawer-side\", ctx.mode === \"side\")(\"mat-drawer-opened\", ctx.opened);\n            }\n        }, inputs: { position: \"position\", mode: \"mode\", disableClose: \"disableClose\", autoFocus: \"autoFocus\", opened: \"opened\" }, outputs: { openedChange: \"openedChange\", _openedStream: \"opened\", openedStart: \"openedStart\", _closedStream: \"closed\", closedStart: \"closedStart\", onPositionChanged: \"positionChanged\" }, exportAs: [\"matDrawer\"], ngContentSelectors: _c0, decls: 2, vars: 0, consts: [[\"cdkScrollable\", \"\", 1, \"mat-drawer-inner-container\"]], template: function MatDrawer_Template(rf, ctx) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵprojectionDef */ \"sc\"]();\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵelementStart */ \"Zb\"](0, \"div\", 0);\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵprojection */ \"rc\"](1);\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵelementEnd */ \"Yb\"]();\n            }\n        }, directives: [_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__[/* CdkScrollable */ \"a\"]], encapsulation: 2, data: { animation: [matDrawerAnimations.transformDrawer] }, changeDetection: 0 });\n    return MatDrawer;\n})();\nlet MatDrawerContainer = /*@__PURE__*/ (() => {\n    class MatDrawerContainer {\n        constructor(_dir, _element, _ngZone, _changeDetectorRef, viewportRuler, defaultAutosize = false, _animationMode) {\n            this._dir = _dir;\n            this._element = _element;\n            this._ngZone = _ngZone;\n            this._changeDetectorRef = _changeDetectorRef;\n            this._animationMode = _animationMode;\n            /** Drawers that belong to this container. */\n            this._drawers = new _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* QueryList */ \"J\"]();\n            /** Event emitted when the drawer backdrop is clicked. */\n            this.backdropClick = new _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* EventEmitter */ \"p\"]();\n            /** Emits when the component is destroyed. */\n            this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_7__[/* Subject */ \"a\"]();\n            /** Emits on every ngDoCheck. Used for debouncing reflows. */\n            this._doCheckSubject = new rxjs__WEBPACK_IMPORTED_MODULE_7__[/* Subject */ \"a\"]();\n            /**\n             * Margins to be applied to the content. These are used to push / shrink the drawer content when a\n             * drawer is open. We use margin rather than transform even for push mode because transform breaks\n             * fixed position elements inside of the transformed element.\n             */\n            this._contentMargins = { left: null, right: null };\n            this._contentMarginChanges = new rxjs__WEBPACK_IMPORTED_MODULE_7__[/* Subject */ \"a\"]();\n            // If a `Dir` directive exists up the tree, listen direction changes\n            // and update the left/right properties to point to the proper start/end.\n            if (_dir) {\n                _dir.change.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__[/* takeUntil */ \"a\"])(this._destroyed)).subscribe(() => {\n                    this._validateDrawers();\n                    this.updateContentMargins();\n                });\n            }\n            // Since the minimum width of the sidenav depends on the viewport width,\n            // we need to recompute the margins if the viewport changes.\n            viewportRuler.change()\n                .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__[/* takeUntil */ \"a\"])(this._destroyed))\n                .subscribe(() => this.updateContentMargins());\n            this._autosize = defaultAutosize;\n        }\n        /** The drawer child with the `start` position. */\n        get start() { return this._start; }\n        /** The drawer child with the `end` position. */\n        get end() { return this._end; }\n        /**\n         * Whether to automatically resize the container whenever\n         * the size of any of its drawers changes.\n         *\n         * **Use at your own risk!** Enabling this option can cause layout thrashing by measuring\n         * the drawers on every change detection cycle. Can be configured globally via the\n         * `MAT_DRAWER_DEFAULT_AUTOSIZE` token.\n         */\n        get autosize() { return this._autosize; }\n        set autosize(value) { this._autosize = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__[/* coerceBooleanProperty */ \"c\"])(value); }\n        /**\n         * Whether the drawer container should have a backdrop while one of the sidenavs is open.\n         * If explicitly set to `true`, the backdrop will be enabled for drawers in the `side`\n         * mode as well.\n         */\n        get hasBackdrop() {\n            if (this._backdropOverride == null) {\n                return !this._start || this._start.mode !== 'side' || !this._end || this._end.mode !== 'side';\n            }\n            return this._backdropOverride;\n        }\n        set hasBackdrop(value) {\n            this._backdropOverride = value == null ? null : Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__[/* coerceBooleanProperty */ \"c\"])(value);\n        }\n        /** Reference to the CdkScrollable instance that wraps the scrollable content. */\n        get scrollable() {\n            return this._userContent || this._content;\n        }\n        ngAfterContentInit() {\n            this._allDrawers.changes\n                .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_16__[/* startWith */ \"a\"])(this._allDrawers), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__[/* takeUntil */ \"a\"])(this._destroyed))\n                .subscribe((drawer) => {\n                this._drawers.reset(drawer.filter(item => !item._container || item._container === this));\n                this._drawers.notifyOnChanges();\n            });\n            this._drawers.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_16__[/* startWith */ \"a\"])(null)).subscribe(() => {\n                this._validateDrawers();\n                this._drawers.forEach((drawer) => {\n                    this._watchDrawerToggle(drawer);\n                    this._watchDrawerPosition(drawer);\n                    this._watchDrawerMode(drawer);\n                });\n                if (!this._drawers.length ||\n                    this._isDrawerOpen(this._start) ||\n                    this._isDrawerOpen(this._end)) {\n                    this.updateContentMargins();\n                }\n                this._changeDetectorRef.markForCheck();\n            });\n            // Avoid hitting the NgZone through the debounce timeout.\n            this._ngZone.runOutsideAngular(() => {\n                this._doCheckSubject.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_17__[/* debounceTime */ \"a\"])(10), // Arbitrary debounce time, less than a frame at 60fps\n                Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__[/* takeUntil */ \"a\"])(this._destroyed)).subscribe(() => this.updateContentMargins());\n            });\n        }\n        ngOnDestroy() {\n            this._contentMarginChanges.complete();\n            this._doCheckSubject.complete();\n            this._drawers.destroy();\n            this._destroyed.next();\n            this._destroyed.complete();\n        }\n        /** Calls `open` of both start and end drawers */\n        open() {\n            this._drawers.forEach(drawer => drawer.open());\n        }\n        /** Calls `close` of both start and end drawers */\n        close() {\n            this._drawers.forEach(drawer => drawer.close());\n        }\n        /**\n         * Recalculates and updates the inline styles for the content. Note that this should be used\n         * sparingly, because it causes a reflow.\n         */\n        updateContentMargins() {\n            // 1. For drawers in `over` mode, they don't affect the content.\n            // 2. For drawers in `side` mode they should shrink the content. We do this by adding to the\n            //    left margin (for left drawer) or right margin (for right the drawer).\n            // 3. For drawers in `push` mode the should shift the content without resizing it. We do this by\n            //    adding to the left or right margin and simultaneously subtracting the same amount of\n            //    margin from the other side.\n            let left = 0;\n            let right = 0;\n            if (this._left && this._left.opened) {\n                if (this._left.mode == 'side') {\n                    left += this._left._getWidth();\n                }\n                else if (this._left.mode == 'push') {\n                    const width = this._left._getWidth();\n                    left += width;\n                    right -= width;\n                }\n            }\n            if (this._right && this._right.opened) {\n                if (this._right.mode == 'side') {\n                    right += this._right._getWidth();\n                }\n                else if (this._right.mode == 'push') {\n                    const width = this._right._getWidth();\n                    right += width;\n                    left -= width;\n                }\n            }\n            // If either `right` or `left` is zero, don't set a style to the element. This\n            // allows users to specify a custom size via CSS class in SSR scenarios where the\n            // measured widths will always be zero. Note that we reset to `null` here, rather\n            // than below, in order to ensure that the types in the `if` below are consistent.\n            left = left || null;\n            right = right || null;\n            if (left !== this._contentMargins.left || right !== this._contentMargins.right) {\n                this._contentMargins = { left, right };\n                // Pull back into the NgZone since in some cases we could be outside. We need to be careful\n                // to do it only when something changed, otherwise we can end up hitting the zone too often.\n                this._ngZone.run(() => this._contentMarginChanges.next(this._contentMargins));\n            }\n        }\n        ngDoCheck() {\n            // If users opted into autosizing, do a check every change detection cycle.\n            if (this._autosize && this._isPushed()) {\n                // Run outside the NgZone, otherwise the debouncer will throw us into an infinite loop.\n                this._ngZone.runOutsideAngular(() => this._doCheckSubject.next());\n            }\n        }\n        /**\n         * Subscribes to drawer events in order to set a class on the main container element when the\n         * drawer is open and the backdrop is visible. This ensures any overflow on the container element\n         * is properly hidden.\n         */\n        _watchDrawerToggle(drawer) {\n            drawer._animationStarted.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__[/* filter */ \"a\"])((event) => event.fromState !== event.toState), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__[/* takeUntil */ \"a\"])(this._drawers.changes))\n                .subscribe((event) => {\n                // Set the transition class on the container so that the animations occur. This should not\n                // be set initially because animations should only be triggered via a change in state.\n                if (event.toState !== 'open-instant' && this._animationMode !== 'NoopAnimations') {\n                    this._element.nativeElement.classList.add('mat-drawer-transition');\n                }\n                this.updateContentMargins();\n                this._changeDetectorRef.markForCheck();\n            });\n            if (drawer.mode !== 'side') {\n                drawer.openedChange.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__[/* takeUntil */ \"a\"])(this._drawers.changes)).subscribe(() => this._setContainerClass(drawer.opened));\n            }\n        }\n        /**\n         * Subscribes to drawer onPositionChanged event in order to\n         * re-validate drawers when the position changes.\n         */\n        _watchDrawerPosition(drawer) {\n            if (!drawer) {\n                return;\n            }\n            // NOTE: We need to wait for the microtask queue to be empty before validating,\n            // since both drawers may be swapping positions at the same time.\n            drawer.onPositionChanged.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__[/* takeUntil */ \"a\"])(this._drawers.changes)).subscribe(() => {\n                this._ngZone.onMicrotaskEmpty.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_15__[/* take */ \"a\"])(1)).subscribe(() => {\n                    this._validateDrawers();\n                });\n            });\n        }\n        /** Subscribes to changes in drawer mode so we can run change detection. */\n        _watchDrawerMode(drawer) {\n            if (drawer) {\n                drawer._modeChanged.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__[/* takeUntil */ \"a\"])(Object(rxjs__WEBPACK_IMPORTED_MODULE_9__[/* merge */ \"a\"])(this._drawers.changes, this._destroyed)))\n                    .subscribe(() => {\n                    this.updateContentMargins();\n                    this._changeDetectorRef.markForCheck();\n                });\n            }\n        }\n        /** Toggles the 'mat-drawer-opened' class on the main 'mat-drawer-container' element. */\n        _setContainerClass(isAdd) {\n            const classList = this._element.nativeElement.classList;\n            const className = 'mat-drawer-container-has-open';\n            if (isAdd) {\n                classList.add(className);\n            }\n            else {\n                classList.remove(className);\n            }\n        }\n        /** Validate the state of the drawer children components. */\n        _validateDrawers() {\n            this._start = this._end = null;\n            // Ensure that we have at most one start and one end drawer.\n            this._drawers.forEach(drawer => {\n                if (drawer.position == 'end') {\n                    if (this._end != null && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                        throwMatDuplicatedDrawerError('end');\n                    }\n                    this._end = drawer;\n                }\n                else {\n                    if (this._start != null && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                        throwMatDuplicatedDrawerError('start');\n                    }\n                    this._start = drawer;\n                }\n            });\n            this._right = this._left = null;\n            // Detect if we're LTR or RTL.\n            if (this._dir && this._dir.value === 'rtl') {\n                this._left = this._end;\n                this._right = this._start;\n            }\n            else {\n                this._left = this._start;\n                this._right = this._end;\n            }\n        }\n        /** Whether the container is being pushed to the side by one of the drawers. */\n        _isPushed() {\n            return (this._isDrawerOpen(this._start) && this._start.mode != 'over') ||\n                (this._isDrawerOpen(this._end) && this._end.mode != 'over');\n        }\n        _onBackdropClicked() {\n            this.backdropClick.emit();\n            this._closeModalDrawersViaBackdrop();\n        }\n        _closeModalDrawersViaBackdrop() {\n            // Close all open drawers where closing is not disabled and the mode is not `side`.\n            [this._start, this._end]\n                .filter(drawer => drawer && !drawer.disableClose && this._canHaveBackdrop(drawer))\n                .forEach(drawer => drawer._closeViaBackdropClick());\n        }\n        _isShowingBackdrop() {\n            return (this._isDrawerOpen(this._start) && this._canHaveBackdrop(this._start)) ||\n                (this._isDrawerOpen(this._end) && this._canHaveBackdrop(this._end));\n        }\n        _canHaveBackdrop(drawer) {\n            return drawer.mode !== 'side' || !!this._backdropOverride;\n        }\n        _isDrawerOpen(drawer) {\n            return drawer != null && drawer.opened;\n        }\n    }\n    MatDrawerContainer.ɵfac = function MatDrawerContainer_Factory(t) { return new (t || MatDrawerContainer)(_angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_21__[/* Directionality */ \"b\"], 8), _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ElementRef */ \"m\"]), _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_3__[/* NgZone */ \"F\"]), _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ChangeDetectorRef */ \"i\"]), _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__[/* ViewportRuler */ \"e\"]), _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Tb\"](MAT_DRAWER_DEFAULT_AUTOSIZE), _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_19__[/* ANIMATION_MODULE_TYPE */ \"a\"], 8)); };\n    MatDrawerContainer.ɵcmp = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdefineComponent */ \"Nb\"]({ type: MatDrawerContainer, selectors: [[\"mat-drawer-container\"]], contentQueries: function MatDrawerContainer_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵcontentQuery */ \"Mb\"](dirIndex, MatDrawerContent, true);\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵcontentQuery */ \"Mb\"](dirIndex, MatDrawer, true);\n            }\n            if (rf & 2) {\n                let _t;\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵqueryRefresh */ \"Fc\"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵloadQuery */ \"kc\"]()) && (ctx._content = _t.first);\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵqueryRefresh */ \"Fc\"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵloadQuery */ \"kc\"]()) && (ctx._allDrawers = _t);\n            }\n        }, viewQuery: function MatDrawerContainer_Query(rf, ctx) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵviewQuery */ \"Zc\"](MatDrawerContent, true);\n            }\n            if (rf & 2) {\n                let _t;\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵqueryRefresh */ \"Fc\"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵloadQuery */ \"kc\"]()) && (ctx._userContent = _t.first);\n            }\n        }, hostAttrs: [1, \"mat-drawer-container\"], hostVars: 2, hostBindings: function MatDrawerContainer_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵclassProp */ \"Lb\"](\"mat-drawer-container-explicit-backdrop\", ctx._backdropOverride);\n            }\n        }, inputs: { autosize: \"autosize\", hasBackdrop: \"hasBackdrop\" }, outputs: { backdropClick: \"backdropClick\" }, exportAs: [\"matDrawerContainer\"], features: [/*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵProvidersFeature */ \"Fb\"]([{\n                    provide: MAT_DRAWER_CONTAINER,\n                    useExisting: MatDrawerContainer\n                }])], ngContentSelectors: _c2, decls: 4, vars: 2, consts: [[\"class\", \"mat-drawer-backdrop\", 3, \"mat-drawer-shown\", \"click\", 4, \"ngIf\"], [4, \"ngIf\"], [1, \"mat-drawer-backdrop\", 3, \"click\"]], template: function MatDrawerContainer_Template(rf, ctx) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵprojectionDef */ \"sc\"](_c1);\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵtemplate */ \"Sc\"](0, MatDrawerContainer_div_0_Template, 1, 2, \"div\", 0);\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵprojection */ \"rc\"](1);\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵprojection */ \"rc\"](2, 1);\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵtemplate */ \"Sc\"](3, MatDrawerContainer_mat_drawer_content_3_Template, 2, 0, \"mat-drawer-content\", 1);\n            }\n            if (rf & 2) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵproperty */ \"tc\"](\"ngIf\", ctx.hasBackdrop);\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵadvance */ \"Gb\"](3);\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵproperty */ \"tc\"](\"ngIf\", !ctx._content);\n            }\n        }, directives: [_angular_common__WEBPACK_IMPORTED_MODULE_2__[/* NgIf */ \"n\"], MatDrawerContent], styles: [_c5], encapsulation: 2, changeDetection: 0 });\n    return MatDrawerContainer;\n})();\nlet MatSidenavContent = /*@__PURE__*/ (() => {\n    class MatSidenavContent extends MatDrawerContent {\n        constructor(changeDetectorRef, container, elementRef, scrollDispatcher, ngZone) {\n            super(changeDetectorRef, container, elementRef, scrollDispatcher, ngZone);\n        }\n    }\n    MatSidenavContent.ɵfac = function MatSidenavContent_Factory(t) { return new (t || MatSidenavContent)(_angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ChangeDetectorRef */ \"i\"]), _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Tb\"](Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__[/* forwardRef */ \"Z\"])(() => MatSidenavContainer)), _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ElementRef */ \"m\"]), _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__[/* ScrollDispatcher */ \"c\"]), _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Tb\"](_angular_core__WEBPACK_IMPORTED_MODULE_3__[/* NgZone */ \"F\"])); };\n    MatSidenavContent.ɵcmp = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdefineComponent */ \"Nb\"]({ type: MatSidenavContent, selectors: [[\"mat-sidenav-content\"]], hostAttrs: [1, \"mat-drawer-content\", \"mat-sidenav-content\"], hostVars: 4, hostBindings: function MatSidenavContent_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵstyleProp */ \"Pc\"](\"margin-left\", ctx._container._contentMargins.left, \"px\")(\"margin-right\", ctx._container._contentMargins.right, \"px\");\n            }\n        }, features: [_angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵInheritDefinitionFeature */ \"Db\"]], ngContentSelectors: _c0, decls: 1, vars: 0, template: function MatSidenavContent_Template(rf, ctx) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵprojectionDef */ \"sc\"]();\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵprojection */ \"rc\"](0);\n            }\n        }, encapsulation: 2, changeDetection: 0 });\n    return MatSidenavContent;\n})();\nlet MatSidenav = /*@__PURE__*/ (() => {\n    class MatSidenav extends MatDrawer {\n        constructor() {\n            super(...arguments);\n            this._fixedInViewport = false;\n            this._fixedTopGap = 0;\n            this._fixedBottomGap = 0;\n        }\n        /** Whether the sidenav is fixed in the viewport. */\n        get fixedInViewport() { return this._fixedInViewport; }\n        set fixedInViewport(value) { this._fixedInViewport = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__[/* coerceBooleanProperty */ \"c\"])(value); }\n        /**\n         * The gap between the top of the sidenav and the top of the viewport when the sidenav is in fixed\n         * mode.\n         */\n        get fixedTopGap() { return this._fixedTopGap; }\n        set fixedTopGap(value) { this._fixedTopGap = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__[/* coerceNumberProperty */ \"f\"])(value); }\n        /**\n         * The gap between the bottom of the sidenav and the bottom of the viewport when the sidenav is in\n         * fixed mode.\n         */\n        get fixedBottomGap() { return this._fixedBottomGap; }\n        set fixedBottomGap(value) { this._fixedBottomGap = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__[/* coerceNumberProperty */ \"f\"])(value); }\n    }\n    MatSidenav.ɵfac = function MatSidenav_Factory(t) { return ɵMatSidenav_BaseFactory(t || MatSidenav); };\n    MatSidenav.ɵcmp = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdefineComponent */ \"Nb\"]({ type: MatSidenav, selectors: [[\"mat-sidenav\"]], hostAttrs: [\"tabIndex\", \"-1\", 1, \"mat-drawer\", \"mat-sidenav\"], hostVars: 17, hostBindings: function MatSidenav_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵattribute */ \"Hb\"](\"align\", null);\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵstyleProp */ \"Pc\"](\"top\", ctx.fixedInViewport ? ctx.fixedTopGap : null, \"px\")(\"bottom\", ctx.fixedInViewport ? ctx.fixedBottomGap : null, \"px\");\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵclassProp */ \"Lb\"](\"mat-drawer-end\", ctx.position === \"end\")(\"mat-drawer-over\", ctx.mode === \"over\")(\"mat-drawer-push\", ctx.mode === \"push\")(\"mat-drawer-side\", ctx.mode === \"side\")(\"mat-drawer-opened\", ctx.opened)(\"mat-sidenav-fixed\", ctx.fixedInViewport);\n            }\n        }, inputs: { fixedInViewport: \"fixedInViewport\", fixedTopGap: \"fixedTopGap\", fixedBottomGap: \"fixedBottomGap\" }, exportAs: [\"matSidenav\"], features: [_angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵInheritDefinitionFeature */ \"Db\"]], ngContentSelectors: _c0, decls: 2, vars: 0, consts: [[\"cdkScrollable\", \"\", 1, \"mat-drawer-inner-container\"]], template: function MatSidenav_Template(rf, ctx) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵprojectionDef */ \"sc\"]();\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵelementStart */ \"Zb\"](0, \"div\", 0);\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵprojection */ \"rc\"](1);\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵelementEnd */ \"Yb\"]();\n            }\n        }, directives: [_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__[/* CdkScrollable */ \"a\"]], encapsulation: 2, data: { animation: [matDrawerAnimations.transformDrawer] }, changeDetection: 0 });\n    return MatSidenav;\n})();\nconst ɵMatSidenav_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵgetInheritedFactory */ \"bc\"](MatSidenav);\nlet MatSidenavContainer = /*@__PURE__*/ (() => {\n    class MatSidenavContainer extends MatDrawerContainer {\n    }\n    MatSidenavContainer.ɵfac = function MatSidenavContainer_Factory(t) { return ɵMatSidenavContainer_BaseFactory(t || MatSidenavContainer); };\n    MatSidenavContainer.ɵcmp = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdefineComponent */ \"Nb\"]({ type: MatSidenavContainer, selectors: [[\"mat-sidenav-container\"]], contentQueries: function MatSidenavContainer_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵcontentQuery */ \"Mb\"](dirIndex, MatSidenavContent, true);\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵcontentQuery */ \"Mb\"](dirIndex, MatSidenav, true);\n            }\n            if (rf & 2) {\n                let _t;\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵqueryRefresh */ \"Fc\"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵloadQuery */ \"kc\"]()) && (ctx._content = _t.first);\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵqueryRefresh */ \"Fc\"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵloadQuery */ \"kc\"]()) && (ctx._allDrawers = _t);\n            }\n        }, hostAttrs: [1, \"mat-drawer-container\", \"mat-sidenav-container\"], hostVars: 2, hostBindings: function MatSidenavContainer_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵclassProp */ \"Lb\"](\"mat-drawer-container-explicit-backdrop\", ctx._backdropOverride);\n            }\n        }, exportAs: [\"matSidenavContainer\"], features: [/*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵProvidersFeature */ \"Fb\"]([{\n                    provide: MAT_DRAWER_CONTAINER,\n                    useExisting: MatSidenavContainer\n                }]), _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵInheritDefinitionFeature */ \"Db\"]], ngContentSelectors: _c4, decls: 4, vars: 2, consts: [[\"class\", \"mat-drawer-backdrop\", 3, \"mat-drawer-shown\", \"click\", 4, \"ngIf\"], [\"cdkScrollable\", \"\", 4, \"ngIf\"], [1, \"mat-drawer-backdrop\", 3, \"click\"], [\"cdkScrollable\", \"\"]], template: function MatSidenavContainer_Template(rf, ctx) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵprojectionDef */ \"sc\"](_c3);\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵtemplate */ \"Sc\"](0, MatSidenavContainer_div_0_Template, 1, 2, \"div\", 0);\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵprojection */ \"rc\"](1);\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵprojection */ \"rc\"](2, 1);\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵtemplate */ \"Sc\"](3, MatSidenavContainer_mat_sidenav_content_3_Template, 2, 0, \"mat-sidenav-content\", 1);\n            }\n            if (rf & 2) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵproperty */ \"tc\"](\"ngIf\", ctx.hasBackdrop);\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵadvance */ \"Gb\"](3);\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵproperty */ \"tc\"](\"ngIf\", !ctx._content);\n            }\n        }, directives: [_angular_common__WEBPACK_IMPORTED_MODULE_2__[/* NgIf */ \"n\"], MatSidenavContent, _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__[/* CdkScrollable */ \"a\"]], styles: [_c5], encapsulation: 2, changeDetection: 0 });\n    return MatSidenavContainer;\n})();\nconst ɵMatSidenavContainer_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵgetInheritedFactory */ \"bc\"](MatSidenavContainer);\nlet MatSidenavModule = /*@__PURE__*/ (() => {\n    class MatSidenavModule {\n    }\n    MatSidenavModule.ɵmod = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdefineNgModule */ \"Rb\"]({ type: MatSidenavModule });\n    MatSidenavModule.ɵinj = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdefineInjector */ \"Qb\"]({ factory: function MatSidenavModule_Factory(t) { return new (t || MatSidenavModule)(); }, imports: [[\n                _angular_common__WEBPACK_IMPORTED_MODULE_2__[/* CommonModule */ \"c\"],\n                _angular_material_core__WEBPACK_IMPORTED_MODULE_4__[/* MatCommonModule */ \"j\"],\n                _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_0__[/* PlatformModule */ \"b\"],\n                _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__[/* CdkScrollableModule */ \"b\"],\n            ], _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__[/* CdkScrollableModule */ \"b\"],\n            _angular_material_core__WEBPACK_IMPORTED_MODULE_4__[/* MatCommonModule */ \"j\"]] });\n    return MatSidenavModule;\n})();\n/*@__PURE__*/ (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵsetNgModuleScope */ \"Lc\"](MatSidenavModule, { declarations: function () { return [MatDrawer, MatDrawerContainer, MatDrawerContent, MatSidenav, MatSidenavContainer, MatSidenavContent]; }, imports: function () {\n            return [_angular_common__WEBPACK_IMPORTED_MODULE_2__[/* CommonModule */ \"c\"],\n                _angular_material_core__WEBPACK_IMPORTED_MODULE_4__[/* MatCommonModule */ \"j\"],\n                _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_0__[/* PlatformModule */ \"b\"],\n                _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__[/* CdkScrollableModule */ \"b\"]];\n        }, exports: function () {\n            return [_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__[/* CdkScrollableModule */ \"b\"],\n                _angular_material_core__WEBPACK_IMPORTED_MODULE_4__[/* MatCommonModule */ \"j\"], MatDrawer, MatDrawerContainer, MatDrawerContent, MatSidenav, MatSidenavContainer, MatSidenavContent];\n        } });\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=sidenav.js.map\n\n\n/***/ })\n\n}]);","inputSourceMap":null}